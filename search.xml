<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mysql初体验]]></title>
    <url>%2F2018%2F10%2F15%2FMysql%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[数据库 数据库, 即database, 通过数据库我们可以实现数据的持久化 当我们左数据持久化操作是不仅仅是希望能够把数据长久的保存起来, 更重要的是便利的管理数据—方便的存取。 1970s IBM - 关系型数据库 12345理论基础: 关系代数和集合论具体表象: 用二维表来组织数据二维表: - 行, 即记录- 列, 即字段 SQL(Structure Query Language)结构化查询语言 12345678SQL对大小写不敏感SQL分为6个部分，分别为:- DQL数据查询语言(即数据检索select下的where、order by、group by、having)，- DML数据操作语言(即insert、update、delete)，- TPL事务处理语言(即begin transaction开始事务,commit提交,rollback回滚)，- DCL数据控制语言(即grant授予，revoke撤销，确定对单个用户和用户组对数据库对象的访问)，- DDL数据定义语言(即create创建表,drop删除表和alter修改表,为表加入索引，保留字)，- CCL指针控制语言(即)。 命令操作##数据库操作 12345678- create databaseCREATE DATABASE student DEFAULT CHARSET utf8;- drop databasedrop database if exists student;- alter database... ##数据表操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- create table# create table tb_name(column_name, datatype, constraint);# 命名方式给前缀如table - tb_student, 便于查看# 非空约束 -- not null# 默认值约束 -- default# 主键约束 -- primary key --&gt; 主键是表中能够唯一标识一条记录的列# instance:create table tb_student(stuid int not null, stuname varchar(4) not null, gender bit not null default 1, birth date, addr varchar(50),primary key(stuid) );- drop table# drop table if exists tb_name;- alter table# alter table tb_student add column tel char(11) not null;# alter table tb_student drop column tel;- insert-- a recordinsert into tb_student values(2018001, &apos;王晗旭&apos;, 1, &apos;1995-10-10&apos;, &apos;中国大陆&apos;);insert into tb_student (stuid, stuname, gender) values(2018002, &apos;卢姥爷&apos;, 1);-- many recordsinsert into tb_student (stuid, stuname, gender) values(2018003, &apos;卢姥爷&apos;, 1),(2018004, &apos;蛇姥爷&apos;, 1),(2018005, &apos;老姥爷&apos;, 1);- delete-- a recorddelete from tb_student where stuid = 2018005;--many recordsdelete from tb_student where stuid in (2018005, 2018006, 2018007);- truncate truncate table tb_name;- updateupdate tb_student set addr=&apos;Sichuan,China&apos;, gender=0 where stuid in (2018002, 2018003);- select select * from tb_name; DQL(数据查询)select select * from tb_name; 查询tb_name中的全部内容 select stuname as 姓名, gender as 性别 from tb_name; 别名式查询, 其中的as可以省略 12345- alias selectselect stuname as 姓名, gender as 性别 from tb_student;- alias select and handle filedselect stuname as 姓名, if (gender, &apos;男&apos;, &apos;女&apos;) as 性别 from tb_student;select stuname as 姓名, case gender when 1 then &apos;男&apos; else &apos;女&apos; end as 性别 from tb_student; filter筛选 对表中的某列或某些列做处理或给定筛选条件, 再查询 123456789select concat(stuname,&apos;: &apos; , addr) as 信息 from tb_student where gender = 0; 将stuname和addr字段连接起来再查询select * from tb_student where stuid between 2018001 and 2018010; 查询2018001和2018010之间的所有记录select * from tb_student where addr is null; -- 查询addr为空的所有记录select * from tb_student where addr is not null; -- 查询addr不为空的所有记录select * from tb_student where stuid &gt; 2018001 and gender = 0; -- 查询满足所有条件的记录select * from tb_student where stuid &gt; 2018001 or gender = 0; -- 查询满足至少一个条件的所有记录 fuzzy search 模糊查询 123select * from tb_student where stuname like &apos;%姥爷%&apos;; %表示0个或多个字符, 查询字段中有&apos;姥爷&apos;的所有记录select * from tb_student where stuname like &apos;_姥爷&apos;; _ 表示一个字符, 查询所有一个字符后&apos;姥爷&apos;的所有记录 ​]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之 Window]]></title>
    <url>%2F2018%2F10%2F13%2FJS%E4%B9%8BWindow%E7%AF%87%2F</url>
    <content type="text"><![CDATA[navigator对象12345678910111213141516171819202122232425属性 1.appCodeName -- 返回浏览器的代码名 Mozilla 2.appName -- 返回浏览器的名称 Netscape 3.appVersion -- 返回浏览器的平台和版本消息 4.cookieEnabled -- 启用cookie 5.platform -- 硬件平台 win32 6.userAgent --用户代理 7.systemLanguage -- 用户代理语言 浏览器版本黑历史:) Mosaic(马赛克)，最早的浏览器 Mozilla(魔斯拉)(意为Mosaic杀手) -- 后改名为Netscape Mozilla/1.0(Win3.1)，由于网景支持框架，而框架被大众喜爱，网站管理员探测userAgent时对Mozilla浏览器发送有框架的页面，对非Mozilla的浏览器发送没有框架的页面。网景拿微软寻开心，称微软是&quot;没有调试过的硬件驱动程序&quot;，微软很生气，开发了自己的浏览器。 微软 IE(Internet Explorer)--IE也支持框架，但它不是Mozilla，总是收不到含有框架的网页， 又等不及所有的网站管理员去了解IE，就宣布IE是兼容Mozilla的，并模仿Netscape，自称Mozilla/1.22(compatible; MSIE 2.0; Windows 95)，于是IE就能接受所有的含有框架的网页，微软开心了，网站管理员崩溃了。微软和Netscape的大战，由于微软的捆绑销售等原因，Netscape退出历史舞台。 FireFox火狐--Netscape以MOzilla的名义，开发了Gecko，它的渲染引擎很出色，Gecko变得出色，其他浏览器使用它的代码，并伪装成Mozilla，但是却使用Gecko。userAgent的探测规则偏向Gecko Linux下的conqueror -- 引擎是KHTML，但因为不是Gecko得不到好的页面，将自己伪装成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko) Opera欧朋 -- 跳出来说应该让用户决定想让我们伪装成什么浏览器。给定三个选项，“Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51”==IE或者“Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51”==火狐， 或者“Opera/9.51 (Windows NT 5.1; U; en)==欧朋 Safari苹果 -- 使用KHTML作为渲染引擎，后来基于KHTML另开辟分支WebKit，又不想抛弃哪些KHTML的页面，就自称Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5 chorme谷歌 --使用Webkit作为渲染引擎，它想要哪些Safari的页面，于是它伪装成Safari.Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36 于是Chrome使用WebKit，并将自己伪装成Safari，WebKit伪装成KHTML，KHTML伪装成Gecko，最后所有的浏览器都伪装成了Mozilla，这就是为什么所有的浏览器User-Agent里都有Mozilla。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js&#39;s BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识JS]]></title>
    <url>%2F2018%2F10%2F13%2F%E5%88%9D%E8%AF%86JS%2F</url>
    <content type="text"><![CDATA[js概要 JavaScript与java 123456JavaScript 与 Java 是两种完全不同的语言，无论在概念上还是设计上。Java（由 Sun 发明）是更复杂的编程语言。ECMA-262 是 JavaScript 标准的官方名称。JavaScript 由 Brendan Eich 发明。它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ECMA（一个标准协会）采纳。 JavaScript 是互联网上最流行的脚本语言, 对于网页来说, 它负责事件和渲染部分。因此通常我们将它放在网页的最后部分。 JS由ECMAScript + BOM + DOM 三部分组成 ECMAScript ,ECMA(European Computer Manufactures Association 欧洲电脑制造商协会)。它定义了JavaScript的标准, 现在我们大都使用ECMAScript 5.1，在ECMAScript 6以后添加了类和模块 BOM 是浏览器对象模型 对应window对象 DOM 是 文件对象模型 对应document对象 js基础 注释 单行注释使用// 多行注释使用/* */ 标识符 12341.要求是由数字、字母、下划线和$组成 2.对大小写敏感3.使用驼峰式命名, 不能是js中的关键字, 见名知意instance: var abc , var $12c 基本数据类型 123456789Number 数字类型(包含所有数字, 不支持复数) +12.2 10e2Boolean 布尔类型 true falseString 字符串 &apos;如果有来生&apos; &quot;apple&quot; 单双引号皆可Array 数组 [1,&apos;abc&apos;,true]Object 对象 &#123;a:100, name:&apos;张德帅&apos;,age:20&#125;特殊类型:NaN 不存在的数字null 空,一般用来清空变量的内容 underfined 变量没有赋值或没有结果时 js语句 12#1.一条语句结束后可以写分号，也可以不写,但是提倡写,便于js的压缩。如果一行有多条语句，必须写分号#2.js没有缩进语法的要求，需要使用代码块的时候使用大括号 变量 1231.变量声明: var 变量名 或 var 变量名 = 初值2.初值可有可无3.变量要声明再使用 运算符 123456数学运算符 + - * / % （**,js7）++ --比较运算符 &gt; &lt; = == != &gt;= &lt;= ===(完全相等) !== &gt;== &lt;==- ==只判断值相等 2 == &apos;2&apos; //true- ===类型和值都要相等逻辑运算符 &amp;&amp;与 ||或 !非三目运算符 表达式1？值1:值2 判断表达式，如果为真返回值1，否则返回值2 分支结构 1234567891011#if语句- if- if-else- if-else if-else#switch语句switch(表达式)&#123; case 值1: 代码段 break case 值2: 代码段 break ... default:代码段&#125; 循环结构 12345678910111213#for-in循环for(var 变量 in 序列)&#123;循环体&#125;#for循环for(表达式1:表达式2:表达式3)&#123;循环体&#125;#while循环while(条件语句)&#123;循环体&#125;#do-while循环do&#123;循环体&#125;while(条件语句) 函数 123456789function 函数名(参数列表)&#123; 函数体&#125;注:function:js中声明函数的关键字;函数名:标识符，不能是关键字,见名知意参数列表:形参js不能同时返回多个值js中函数能够作为变量 instance： var fn = function(参数列表) &#123;函数体&#125;js中函数能够作为参数或者返回值 ##]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷酷的aview]]></title>
    <url>%2F2018%2F10%2F12%2F%E9%85%B7%E9%85%B7%E7%9A%84aview%2F</url>
    <content type="text"><![CDATA[1.安装AAlibAA(Ascii Art),AAlib是一个便携式ascii艺术GFX库(GFX lib是一个小型的C库，用于开发针对伟大的MSX计算机的图形应用程序) aalib-1.2的最新版本是1.4, 但是后续安装bb是基于1.2的, 因此要先安装1.2的版本. 安装AAlib之前需要安装gcc和libtool,可以通过yum install xx直接安装. aalib-1.2默认安装在/usr/local下面 1234567891011121314#1 下载aalib-1.2wget http://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz#2 解压缩gunzip aalib-1.2.tar.gz#3 解归档tar -xvf aalib-1.2.tar#4 对安装的软件进行配置,检查依赖关系./configure#5 编译安装make &amp;&amp; make install (先执行make, 在执行make install) 出现的问题: 12345678ltconfig: you must specify a host type if you use `--no-verify&apos;Try `ltconfig --help&apos; for more information.configure: error: libtool configure failed出现这样的问题,其实是配置时不能识别系统类型,需要自己指定主机类型.解决方法是将下述的两个文件覆盖带/aalib-1.2/下面. (下述 . 指当前文件夹下)cp /usr/share/libtool/config/config.guess .cp /usr/share/libtool/config/config.sub . 2.安装bbbb是一种图形演示程序,它需要AAlib库 12345678910111213141516171819#1 下载bb源文件wget http://prdownloads.sourceforge.net/aa-project/bb-1.2.tar.gz#2 解压缩gunzip bb-1.2.tar.gz #3 解归档tar -xvf bb-1.2.tar #4 配置环境变量,使bb能找到AAlibexport CFLAGS=-I/usr/local/include#5 配置cd bb-1.2./configure注: 配置会出错,因为textform.c文件中很多位置缺少结束字符&quot; ,只要将报错的地方全部使用 &quot;&quot; 将之引起来就好了。(仿照正确的地方的格式)#6 编译生成可执行文件bbmake 3.安装aviewaview是一款高质量的图像(pnm)浏览器和动画(fli/flc)播放器，以ASCII-art方式输出。它是使用AA-lib实现的。 它提供了一个asciiview的脚本，利用convert转换图片格式，然后再传递给aview. aview是依赖aalib-1.4，因此需要先安装aalib-1.4, 安装方式与aalib-1.2相同, 链接https://downloads.sourceforge.net/aa-project/aalib-1.4rc5.tar.gz 123456789101112131415#1 安装aviewwget http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gz#2 解压缩gunzip aview-1.3.0rc1.tar.gz #3 解归档tar -xvf aview-1.3.0rc1.tar #4 配置cd aview-1.3.0./configure#5 编译安装make &amp;&amp; make install 4.安装ImageMagickImageMagick介绍在此http://www.imagemagick.org/script/index.php 它可以直接通过yum安装 5.try在此,应该是将所有软件安装完毕, 随便在浏览器上扣一张图,使用命令acsiiview 图片路径效果如下: 原图 ascii图 注: 上述使用linux的发行版本为CentOS 6.x。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>aview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xshell和linux]]></title>
    <url>%2F2018%2F10%2F11%2Fxshell%2F</url>
    <content type="text"><![CDATA[基本命令 who 显示当前连接服务器的所有用户 who am i 只显示本用户 w显示本用户详细信息 last显示最近登录的用户信息 ps 显示所有进程 1ps -ef 查看进程 kill pid 杀死指定id的进程 1kill -9 pid 强行杀死指定id的进程 用户管理 adduser username 添加新的用户 passwd username 为指定的用户建立密码(若是root用户, 可以修改任何用户的密码 userdel username 删除用户 userdel -r username 删除用户及其用户主目录(recursive递归的) userdel -f username 强制删除用户(force强制) su username 切换用户(switch user) tab制表键 自动补全 man 命令 查看指定命令的手册(manual手册) info 命令 查看命令的手册(以coder的角度) 命令 --help 查看指定命令的help pwd 查看工作目录(print work directory) cd 或 cd~ 返回到当前目录的主目录 cd /directory 绝对路径的方式改变当前目录 cd directory 相对路径的方式改变当前目录 wget 联网下载 cat filename 连接多个文件并查看文件内容(concatenates) history 查看历史命令 history -c 清除历史命令 ! historyid 执行历史命令编号的命令 pwd 打印当前工作目录(print name of work directory) ls 列出文件 123-a 显示隐藏文件-l 长格式显示文件-R 递归显示文件 alias newname = &quot;命令&quot; 将一个命令起一个别名 12alias rmd = &quot;rm -rf&quot; 使rmd称为直接强制删除的命令别名unalias rmd 取消所起的别名 rmdir 移除空目录(remove directory) mkdir 创建目录 (make directory) cp 拷贝文件 mv 剪切文件或文件夹 12mv index.html new.html 更改文件index.html为new.htmlmv index.html /abc/rz 剪切index.html到/abc/rz的目录下 rm 删除文件或目录 1234rm -f 直接删除指定的文件或目录rm -r 递归式的删除rm -i 交互式删除注:参数可以放在一起或分开 -r -f 等价于 -rf #表示root用户 $表示普通用户 echo 输出内容 1234echo &quot;print &apos;hello world!&apos;&quot; 在控制台打印字符串echo &quot;print &apos;hello world!&apos;&quot; &gt; hello.py 输出(覆盖)内容到hello.py文件中echo &quot;print &apos;hello world!&apos;&quot; &gt;&gt; hello.py 追加内容到hello.py文件中2&gt; 错误输出重定向 cal 查看日历 123cal 2018 查看2018整年的日历cal 2018 &gt; date.txt 将日历信息重定向到date.txt文件中cal 12 2018 查看2018年12月的日历 date 查看日期 bc 计算器 1scale = number number指小数点后几位的num shutdown / init 0 关机, 前者有1m的等待时间，后者直接关机 reboot / init 6 重启 head -n file 查看文件的前n行 tail -n file 查看文件最后n行 less/more file 分页查看文件 | 管道，用于进程间通信。把前一个进程的输出用于后一个进程的输入。 wc 用于统计(print newline, word, and byte counts for each file) 123-l 统计行数-c 统计字节数-m 统计单词个数 uniq 去重的作用(仅去重相邻的重复项) 1sort test.txt | uniq 先排序test.txt文件再去重 vim -d file1 file2比较2个文件的不同(通过创建2个子窗口) chmod 修改权限 chown 修改文件所有者 write 用户名 发送消息给用户,ctrl d结束 wall 发送消息给所有用户 !v 使用vim打开最近一次使用vim的文件 top 查看任务管理器 ls || cal 按顺序执行，若有一个命令执行成功，后续不执行 ls &amp;&amp; cal 按顺序执行，上一个命令执行成功，再执行后一个命令。若遇到执行不成功的,后续也不执行 ls; cal 按顺序执行命令(先ls 再cal) #Linux用户管理 用户添加 12345678910useradd [option] username -- 添加用户option:-c --&gt; 指定一段注释性描述-d --&gt; 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录-g --&gt; 指定用户所属的用户组-s --&gt; 指定用户登录的shell-u --&gt; 指定用户的用户号instance:# useradd -d /usr/mary -m Mary -- 创建名为Mary的用户,并指定其主目录为mary,若没有mary目录就创建一个目录# 默认下新建用户均会在/usr/目录下创建一个和用户名相同的用户主目录 删除账号 123userdel [option] username -- 删除用户option:-r --&gt; 删除用户的同时会删除用户的主目录和用户相关的记录 修改用户 12usermod [option] username -- 修改用户的信息option: 与添加用户部分的参数相同 口令管理(密码管理) 123456789passwd [option] [username]option:-l --&gt; 锁定口令,禁用账号-u --&gt; 解除锁定口令-d --&gt; 使账号无口令-f --&gt; 强迫用户下次登录时修改口令username:- 当没有指定username时, 修改当前用户的口令- 若当前用户是普通用户时, 修改口令需要指定旧口令; 若当前用户为root用户, 可以直接指定新的口令, 不需要旧口令。 Linux安装软件使用包管理工具yum/rpm123456yum search &lt;name&gt; -- 搜索相关包yum - y install &lt;name1&gt; &lt;name2&gt; -- -y参数是默认所有选项为yes，后可以接多个包进行安装yum -y remove &lt;name1&gt; &lt;name&gt; -- 卸载,也可以多个yum info &lt;name&gt; -- 查看软件的信息yum update &lt;name&gt; -- 更新指定的包,若没有指定name,则更新全部包yum list installed -- 将已经安装的包列出来 源代码构建安装 1gcc -- 通常linux系统自带 压缩文件 12gz --- 压缩gzip(解压缩gunzip)xz --- 压缩xzip(解压缩xz -d) 归档文件 12WinRAR --- 归档与解归档tar --- 归档文件(linux下) centos安装python3.x.x 12345678910111213141516171819201.下载源代码 -- wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz2.解压缩 -- gunzip Python-3.6.5.tgz 3.解归档 -- tar -xvf Python-3.6.5.tar (x抽离 v归档显示 f文件)4.安装Python依赖库 -- yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel5.安装前配置 -- 进入Python3.x.x文件，使用./configure --prefix=/usr/local/python36 --enable-optimizations6.源代码构建安装make &amp;&amp; make install(&amp;&amp;表示如果make成功马上执行make install)7.配置PATH环境变量export PATH=$PATH:/usr/local/python36/bin8.注册一个软链接(符号链接) --- 非必要注:软链接 -- 相当于文件的快捷方式，文件删除则链接失效硬链接 -- 文件的引用。只要引用数不为0，文件就会一直存在ln -s 带完整路径的文件名 链接文件名(不带s为硬链接，带s为软链接)对于一个可执行的文件: ./可执行文件配置永久环境变量ls -al | grep .bash_profilevim .bash_profilei修改第10行(:set nu) -- PATH=$PATH:/usr/local/python36/bin修改第11行 -- export PATH 系统目录介绍/bin 1bin是Binary的缩写, 这个目录存放着最经常使用的命令, 如cat cp ls等(通常为普通用户和root用户必备的命令) /sbin 1sbin是Superuser Binary, 这个用户存放系统管理的命令(也称程序) 如reboot shutdown init ifconfig等 /boot 1存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /dev 1device，存放linux的外部设备文件(在linux中访问设备和访问文件的方式相同) /etc 1234存放所有的系统管理所需要的配置文件/etc/profile /etc/csh.login /etc/csh.cshrc 启动shell执行的文件。修改此文件,能够在登录用户后给提示信息./etc/passwd 用户数据库, 其中给出了用户名, 家目录, 命令目录/etc/shells 列出所有可以使用的shell /usr 12345678/usr/bin -- usr下的bin目录放置可执行程序/usr/local -- 手动安装软件的默认目录/usr/share -- 放置共享数据,帮助手册(/usr/share/man)/usr/lib -- 程序和子系统的库文件/usr/include -- c语言编程中的头文件/usr/bin -- 通常放置应用软件工具的必备命令 如gcc zip man等/usr/sbin -- 通常放置放置网路管理的必备程序, 如httpd dhcpd sendmail等/usr/src -- 内核源代码默认的放置目录 /home 1用户的主目录, 里面放置所有用户的主目录文件 /lib 1放置最基本的动态链接共享库, 类似window下的dll文件, 几乎所有程序都需要用到这些共享库 /proc 1process - 放置进程文件,它是系统内存的映射, 是一个虚拟目录 /var 1234存放系统运行时要改变的数据/var/lib -- 存放系统正常运行要改变的文件/var/local -- 存放/usr/local中安装的程序的可变数据/var/log -- 存放各种程序的日志文件 /root 1作为系统管理员的主目录 vim命令模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344按 i 可切换到 编辑模式h/left -- 光标左移1j/down -- 光标下移1k/top -- 光标上移1l/right -- 光标右移1同时可以 10right/10l 的组合键向右移动10个字符0或home 移动到一行的首字符$或end 移动到一行的末字符H 光标移动到屏幕的第一行首字符M 光标移动弄到屏幕的中间行首字符L 光标移动到屏幕最后一行的首字符w 光标移动一个单词G 光标移动到文件的最后一行gg 光标移动到文件的第一行(相当于1G)nG 光标移动到第n行(20G -- 第20行) -- 配合set nu使用n&lt;Enter&gt; 光标向下移动n行/word 向光标之下寻找名称为word的字符串n/N 对应/word使用,前者为下一个,后者为上一个:n1,n2s/word1/word2/g 在n1到n2行之间,将word1字符串替换成word2:1,$s/word1/word2/g 在第一行到最后一行间,将word1字符串替换成word2:1,$s/word1/word2/gice c是confirm确认,i是ignore忽略大小写,g是global全局模式,e是error忽略错误?正则表达式 反向搜索(与/相反)ctrl f 屏幕向下移动1页(page down)ctrl b 屏幕向上移动1页(page up)ctrl e 向下翻1行ctrl y 向上翻1行x 向后删除一个字符 X 向前删除一个字符dd 删除光标所在一整行ndd 删除含光标所有n行yy 复制光标所在一行nyy 复制含光标所在n行p 将复制的数据在光标下一行贴上 P将复制的数据在上一行贴上u 复原前一个动作ctrl r 重做上一个动作 . 重做上一个动作ctrl x + ctrl o 代码提示r/R 进入取代模式(replace) r会取代光标所在的字符一次, R会一直取代ZZ --- 没改动则直接离开，若改动则保存退出 编辑模式 1234567enter 换行backspace 删除光标前一个字符delete 删除光标后一个字符home/end 移动光标到行首/行尾pg up/pg dn 上/下翻页insert 切换光标为输入/替换模式(replace)esc 切换到命令模式 底线命令模式 123456789101112131415在命令模式下,按下:冒号进入底线命令模式:systax off/on --- 关闭/打开高亮语法:set nu/nonu --- 设置行号/关闭行号:wq --- 保存退出:ls 查看打开的文件:b &lt;编号&gt; 查看指定编号文件(可实现vim同时打开多个文件):vs 垂直拆分窗口:sp 水平拆分ctrl w + ctrl w 切换窗口:qa 退出全部:wqa 全部保存退出:qa! 全部强制退出:map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行:inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 .vimrc(vim配置文件) 12345678syntax on/off 高亮语法打开/关闭set number 设置行号set tabstop=4 设置tab缩进为4 set ruler 显示标尺set nohls 搜索时去除高亮set autoindent 设置换行时自动缩进map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 linux锁屏与解锁 12ctrl s 会将终端terminal锁屏,造成假死的现象ctrl q 进行解除锁屏 ssh远程登录 1远程登录命令 ssh &lt;user&gt;@公网ip password ssh远程传输 12345scp &lt;local file&gt; &lt;user&gt;@公网ip:/传输的路径 passwd(注意用户的级别与所放置文件的目录访问权限有关) --- 将本地文件发送给别的用户的某个路径下例如:scp sohu2.html rzlong@120.77.178.218:/home/rzlongscp &lt;user&gt;@公网ip:/传输的路径 &lt;user&gt;@公网ip:/传输的路径 passwd1 passwd2 将用户1的某个文件发给用户2,如果要发送文件可以加上 -r 参数例如:scp rzlong@120.77.178.218:/home/rzlong/sohu2.html lnx@47.93.248.0:/home/lnx sftp安全文件传输 12345678910111213sftp &lt;user&gt;@公网ip passwd 进入sftp模式help可以查看相关命令相关命令:get [-Ppr] remote [local] Download filereget remote [local] Resume download fileput [-Ppr] local [remote] Upload filels [-1afhlnrSt] [path] Display remote directory listingmkdir path Create remote directoryrename oldpath newpath Rename remote filerm path Delete remote filermdir path Remove remote directorypwd Display remote working directory此时要在sftp模式中操纵本地 在以上命名前加上l(local),如lcd, lls, lpwd DoS和DDoS 12 查看端口情况 12netstat -anp | grep 80 查看所有占用80端口的情况 n数值型ip a是all p是进程例如:tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2033/sshd 进程id为2033, ip为0.0.0.0，端口号22, 传输协议为tcp, sshd是secure shell deamon安全外壳守护进程(后台程序) 服务相关 1234567891011121314151617centos 6.xservice &lt;name&gt; startservice &lt;name&gt; stopcentos 7.xsystemctl start &lt;name&gt; - 启动服务systemctl stop &lt;name&gt; - 停止服务systemctl restart &lt;name&gt; - 重启服务systemctl status &lt;name&gt; - 服务状态syatemctl enable &lt;name&gt; - 设置服务开机自启systemctl disable &lt;name&gt; - 设置服务不启动安装Appache服务器yum -y install httpdps -ef | grep nginx 进程后台运行 12345678910111213141516171819top -- 查看任务管理器jobs -- 查看后台运行的进程ctrl c -- 结束进程ctrl z -- 进程暂停置于后台ctrl d -- 停止输入bg %编号 -- 让暂停的进程继续在后台运行 backgroundfg %编号 -- 让后台的进程在前台(terminal)运行 foreground./hello.py &amp; -- 将一个程序置于后台运行说明:Key FunctionCtrl-c Kill foreground process Ctrl-z Suspend foreground processCtrl-d Terminate input, or exit shellCtrl-s Suspend output 暂停输出Ctrl-q Resume output 回复输出Ctrl-o Discard output 抛弃输出Ctrl-l Clear screen 清屏 计算机网络分层架构模型 1234567TCP/IP 协议族TCP -- Transfer Control Protocol 传输控制协议UDP -- User DataGram Protocol 用户数据报协议IP -- Internet Protocol 网际协议应用层(定义应用级协议)- HTTP / SMTP / POP3 / FTP / SSH / linux下防火墙firewall 123456789systemctl start firewalld -- 开启防火墙 firewall-cmd -- 配置防火墙 firewall-cmd --help 查看相关命令firewall-cmd --permanent --add-port=80/tcp 配置永久开启80端口firewall-cmd --remove-port=80/tcp 删除80端口firewall-cmd --query-port-80/tcp 查看端口是否开启firewall-cmd --query-service=ssh 查看ssh服务是否开启注:当修改了端口(打开或关闭),需要重启防火墙才能生效。 iptables Linux关于python代码风格检测12yun install pycodestyleyum install pylint Linux中好玩的命令pv 通过yum install pv命令进行安装, 其效果是输出的内容达到边敲边显示的样子。 sl 通过yum install sl 命令进行安装, 其效果为跑火车。 xeyes 通过yum install xeyes 命令进行安装,运行命令,会在图形显示界面会看到一双萌萌的眼睛盯着你。 Linux历史GNU和GPL GNU 建立一个自由、开放的 Unix 操作系统(FreeUnix) GPL(GNU General Public License) 为了避免 GNU 所开发的自由软件被其他人所利用而成为专利软件， 史托曼与律师草拟了有名的通用公共许可证(General Public License, GPL)， 并且称呼他为copyleft(相对于专利软件的 copyright！) Free Software和Close Software free software它更被能称为freedom software,自由软件。不是指免费的价格，而是拥有自由的权利。同时它还具有open source 开放源代码的特点。 1&quot;Free software&quot; is a matter of liberty, not price. To understand the concept, you should think of &quot;freespeech&quot;, not &quot;free beer&quot;. &quot;Free software&quot; refers to the users&apos; freedom to run, copy,distribute, study, change,and improve the software close software 即推出的可执行的二进制程序，是专利软件copyright常见的软件出售方式。 但是也有专利软件是免费使用的.Freeware和Shareware : 前者为免费软件，可以免费使用但是不会公开源代码；后者为共享软件，通常为有试用期，再试用期后就必须续费或者停止使用，它已经撰写好了失效程序。 Linux核心版本 可以使用uname -r查看当前linux版本: 12[root@izwz9gn12m5wual96636l2z ~]# uname -r3.10.0-514.26.2.el7.x86_64 主版本.次版本.释出版本-修改版本 在2.6.x版本前，托瓦兹将主次版本为奇数的定位发展中版本development，主要用于测试与发展；对于主次版本为偶数的定位稳定版本stable 在3.0版本后，依据主线版本MainLine开发，例如 3.10 就是在 3.9 的架构下继续开发出来的新的主线版本。而对于旧的版本，有两种机制来处理: 其一为结束开发End Of Live(EOL)，不会再维护；其二是长期维护版本Longterm，例如3.10为一个长期维护版本。 Linux Distrubution linux distrubution 即linux发行版，它是linux kernel+softwares+Tools+可完全安装程序 。常见的有Redhat /OpenSuSe/Fedora/Ubuntu/Debian/CentOS等，它们都是支持于标准的。 12 12]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本控制工具]]></title>
    <url>%2F2018%2F10%2F05%2Fgit-md%2F</url>
    <content type="text"><![CDATA[版本控制工具CVS/VSS – 锁定模式 2000年 - Subversion(SVN) – 合并模式上述为集中控制式的版本系统,必须有中央服务器。 2005年 - Git – 版本控制Mercury分布式的版本系统 区域划分工作区 — 暂存区 — 仓库 基本命令 git init 初始化，使当前目录初始化为git仓库，并创建.git的隐藏目录 git config –global user.name “name” 全局用户名可以随便写,仅标记主机 git config –global user.email “email@example.com“ 全局邮箱,可随便写 git add 将文件加入到暂存区 git add . 将当前目录下的所有文件加入到暂存区 git commit -m “版本提示内容” 将暂存区的内容提交到本地仓库 git status 查看暂存区状态 git log 查看当前版本日志(之前的版本) git reflog 查看所有版本git reset HEAD -将文件从暂存区移除 git checkout – 将暂存区回退到工作区，可用于文件恢复(用于上一次,并且还没有提交到本地仓库中；若是已经提交到仓库中，就可以使用hard来还原版本) git reset –hard 版本号 去往指定的版本 git reset –hard HEAD^ 还原到上个版本(HEAD^^还原到上上个版本) git reset –hard HEAD~num 还原到前num个版本 git clone - 将服务器的项目(仓库)克隆到本地 git push - 将代码推送到服务器(上传) git pull - 将服务器上代码同步到本地(下载) 代码托管平台用别人提供的git服务器github.comgitee.comcoding.net]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F10%2F05%2Fmutiphreading-md%2F</url>
    <content type="text"><![CDATA[##多线程技术 主线程 每个进程都会有一个线程, 这个线程是主线程。默认情况下, 所有代码都是在主线程中执行。 子线程 一个进程可以有多个线程,除了主线程的其他子线程需要去创建 创建线程通过导入threading模块。 threading是python中创建线程的内置模块，用来支持多线程。Thread类的对象就是线程，需要线程时，可创建这个类或其子类的对象。 实例 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingfrom datetime import datetimeimport time# 模拟下载电影def download(file): print(threading.currentThread()) print(file+&apos; 开始下载&apos;,datetime.now()) time.sleep(10) print(file+&apos; 结束下载&apos;, datetime.now())# 在两个子线程中去下载电影&apos;&apos;&apos;Thread(target,args)target:需要在在线程中调用的函数的函数名args: 函数的实参返回值:创建好的线程对象&apos;&apos;&apos;if __name__ == &apos;__main__&apos;: print(threading.current_thread()) print(&apos;主线程位置&apos;) print(&apos;===============================&apos;) t1 = threading.Thread(target=download, args=(&apos;闻香识女人&apos;,)) # t1.start()#想要子线程执行任务，通过线程对象调用start方法 print(&apos;=============================&apos;) t2 = threading.Thread(target=download, args=(&apos;猫鼠游戏&apos;,)) # t2.start() # 执行线程的代码result:&lt;_MainThread(MainThread, started 10552)&gt;主线程位置===============================&lt;Thread(Thread-1, started 8712)&gt;闻香识女人 开始下载 2018-09-15 09:27:07.418839=============================&lt;Thread(Thread-2, started 10564)&gt;猫鼠游戏 开始下载 2018-09-15 09:27:07.418839猫鼠游戏 结束下载 2018-09-15 09:27:17.419411闻香识女人 结束下载 2018-09-15 09:27:17.419411 ##面向对象的多线程 步骤1.声明一个类，继承Thread类2.重写run()方法,将需要在子线程中执行的任务，放到run()方法中3.在需要线程的位置，去创建这个类的对象然后用对象调用start方法，去执行run中的任务。 案例1234567891011121314151617rom threading import Threadfrom datetime import datetime # 从datetime包中引入datetime模块import timeclass R_Thread(Thread): &quot;&quot;&quot;下载线程类&quot;&quot;&quot; def __init__(self,name): super().__init__() self.name = name def run(self): print(self.name+&apos; 开始下载&apos;,datetime.now()) time.sleep(5) print(self.name+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: print(&apos;=========================&apos;) t1 = R_Thread(&apos;闻香识女人&apos;) t1.start() print(&apos;============================&apos;) ##join方法如果希望某个线程结束后才执行后续的操作，调用join方法 案例12345678910111213141516171819202122232425262728from threading import Threadfrom datetime import datetimeimport timefrom random import randint# 在两个子线程中下载两个电影,在主线程中国统计两个电影下载的总时间class R_Thread(Thread): def __init__(self,file): super().__init__() self.file = file def run(self): print(self.file+&apos; 开始下载&apos;,datetime.now()) time.sleep(randint(5,15)) print(self.file+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: t1 = R_Thread(&apos;闻香识女人&apos;) start = time.time() print(start) t1.start() t2 = R_Thread(&apos;美丽人生&apos;) t2.start() &apos;&apos;&apos; 如果希望某个线程结束后才执行后续的操作，调用join方法 &apos;&apos;&apos; t1.join() #这句代码后面的代码需要在t1对应的线程结束后执行 t2.join() end = time.time() print(end) print(end-start) ##多个线程数据共享通过加锁的方式，以解决多个线程同时对一个数据进行操作二带来的数据紊乱的问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import timefrom datetime import datetimefrom threading import Thread,Lock,RLockclass Account: &quot;&quot;&quot;账号类&quot;&quot;&quot; def __init__(self,balance): self.balance = balance # 创建锁对象 self.lock = Lock() # 存钱: 读余额, 确定钱的数目 def save_money(self,amount): self.lock.acquire() # 获取原来的余额 old_amount = self.balance # 模拟时间消耗 time.sleep(5) # 修改余额 self.balance = old_amount + amount print(&apos;存钱成功,余额&apos;,self.balance) self.lock.release() # 取钱 def get_money(self,amount): self.lock.acquire() old_amount = self.balance if old_amount &lt; amount: print(&apos;余额不足&apos;) return time.sleep(10) self.balance = old_amount - amount print(&apos;取钱成功,余额&apos;,self.balance) self.lock.release() def show_balance(self): print(&apos;余额:&apos;,self.balance)if __name__ == &apos;__main__&apos;: account = Account(1000) account.show_balance() &apos;&apos;&apos; 当多个线程同时对一个数据进行操作的时候,可能出现数据紊乱的问题 &apos;&apos;&apos; t1 = Thread(target=account.save_money,args=(200,)) t2 = Thread(target=account.get_money,args=(400,)) t1.start() t2.start() t1.join() account.show_balance() t2.join() account.show_balance() **]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
