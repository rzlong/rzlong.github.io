<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git版本控制工具]]></title>
    <url>%2F2018%2F10%2F05%2Fgit-md%2F</url>
    <content type="text"><![CDATA[版本控制工具CVS/VSS – 锁定模式 2000年 - Subversion(SVN) – 合并模式上述为集中控制式的版本系统,必须有中央服务器。 2005年 - Git – 版本控制Mercury分布式的版本系统 区域划分工作区 — 暂存区 — 仓库 基本命令 git init 初始化，使当前目录初始化为git仓库，并创建.git的隐藏目录 git config –global user.name “name” 全局用户名可以随便写,仅标记主机 git config –global user.email “email@example.com“ 全局邮箱,可随便写 git add 将文件加入到暂存区 git add . 将当前目录下的所有文件加入到暂存区 git commit -m “版本提示内容” 将暂存区的内容提交到本地仓库 git status 查看暂存区状态 git log 查看当前版本日志(之前的版本) git reflog 查看所有版本git reset HEAD -将文件从暂存区移除 git checkout – 将暂存区回退到工作区，可用于文件恢复(用于上一次,并且还没有提交到本地仓库中；若是已经提交到仓库中，就可以使用hard来还原版本) git reset –hard 版本号 去往指定的版本 git reset –hard HEAD^ 还原到上个版本(HEAD^^还原到上上个版本) git reset –hard HEAD~num 还原到前num个版本 git clone - 将服务器的项目(仓库)克隆到本地 git push - 将代码推送到服务器(上传) git pull - 将服务器上代码同步到本地(下载) 代码托管平台用别人提供的git服务器github.comgitee.comcoding.net]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F10%2F05%2Fmutiphreading-md%2F</url>
    <content type="text"><![CDATA[##多线程技术 主线程 每个进程都会有一个线程, 这个线程是主线程。默认情况下, 所有代码都是在主线程中执行。 子线程 一个进程可以有多个线程,除了主线程的其他子线程需要去创建 创建线程通过导入threading模块。 threading是python中创建线程的内置模块，用来支持多线程。Thread类的对象就是线程，需要线程时，可创建这个类或其子类的对象。 实例 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingfrom datetime import datetimeimport time# 模拟下载电影def download(file): print(threading.currentThread()) print(file+&apos; 开始下载&apos;,datetime.now()) time.sleep(10) print(file+&apos; 结束下载&apos;, datetime.now())# 在两个子线程中去下载电影&apos;&apos;&apos;Thread(target,args)target:需要在在线程中调用的函数的函数名args: 函数的实参返回值:创建好的线程对象&apos;&apos;&apos;if __name__ == &apos;__main__&apos;: print(threading.current_thread()) print(&apos;主线程位置&apos;) print(&apos;===============================&apos;) t1 = threading.Thread(target=download, args=(&apos;闻香识女人&apos;,)) # t1.start()#想要子线程执行任务，通过线程对象调用start方法 print(&apos;=============================&apos;) t2 = threading.Thread(target=download, args=(&apos;猫鼠游戏&apos;,)) # t2.start() # 执行线程的代码result:&lt;_MainThread(MainThread, started 10552)&gt;主线程位置===============================&lt;Thread(Thread-1, started 8712)&gt;闻香识女人 开始下载 2018-09-15 09:27:07.418839=============================&lt;Thread(Thread-2, started 10564)&gt;猫鼠游戏 开始下载 2018-09-15 09:27:07.418839猫鼠游戏 结束下载 2018-09-15 09:27:17.419411闻香识女人 结束下载 2018-09-15 09:27:17.419411 ##面向对象的多线程 步骤1.声明一个类，继承Thread类2.重写run()方法,将需要在子线程中执行的任务，放到run()方法中3.在需要线程的位置，去创建这个类的对象然后用对象调用start方法，去执行run中的任务。 案例1234567891011121314151617rom threading import Threadfrom datetime import datetime # 从datetime包中引入datetime模块import timeclass R_Thread(Thread): &quot;&quot;&quot;下载线程类&quot;&quot;&quot; def __init__(self,name): super().__init__() self.name = name def run(self): print(self.name+&apos; 开始下载&apos;,datetime.now()) time.sleep(5) print(self.name+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: print(&apos;=========================&apos;) t1 = R_Thread(&apos;闻香识女人&apos;) t1.start() print(&apos;============================&apos;) ##join方法如果希望某个线程结束后才执行后续的操作，调用join方法 案例12345678910111213141516171819202122232425262728from threading import Threadfrom datetime import datetimeimport timefrom random import randint# 在两个子线程中下载两个电影,在主线程中国统计两个电影下载的总时间class R_Thread(Thread): def __init__(self,file): super().__init__() self.file = file def run(self): print(self.file+&apos; 开始下载&apos;,datetime.now()) time.sleep(randint(5,15)) print(self.file+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: t1 = R_Thread(&apos;闻香识女人&apos;) start = time.time() print(start) t1.start() t2 = R_Thread(&apos;美丽人生&apos;) t2.start() &apos;&apos;&apos; 如果希望某个线程结束后才执行后续的操作，调用join方法 &apos;&apos;&apos; t1.join() #这句代码后面的代码需要在t1对应的线程结束后执行 t2.join() end = time.time() print(end) print(end-start) ##多个线程数据共享通过加锁的方式，以解决多个线程同时对一个数据进行操作二带来的数据紊乱的问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import timefrom datetime import datetimefrom threading import Thread,Lock,RLockclass Account: &quot;&quot;&quot;账号类&quot;&quot;&quot; def __init__(self,balance): self.balance = balance # 创建锁对象 self.lock = Lock() # 存钱: 读余额, 确定钱的数目 def save_money(self,amount): self.lock.acquire() # 获取原来的余额 old_amount = self.balance # 模拟时间消耗 time.sleep(5) # 修改余额 self.balance = old_amount + amount print(&apos;存钱成功,余额&apos;,self.balance) self.lock.release() # 取钱 def get_money(self,amount): self.lock.acquire() old_amount = self.balance if old_amount &lt; amount: print(&apos;余额不足&apos;) return time.sleep(10) self.balance = old_amount - amount print(&apos;取钱成功,余额&apos;,self.balance) self.lock.release() def show_balance(self): print(&apos;余额:&apos;,self.balance)if __name__ == &apos;__main__&apos;: account = Account(1000) account.show_balance() &apos;&apos;&apos; 当多个线程同时对一个数据进行操作的时候,可能出现数据紊乱的问题 &apos;&apos;&apos; t1 = Thread(target=account.save_money,args=(200,)) t2 = Thread(target=account.get_money,args=(400,)) t1.start() t2.start() t1.join() account.show_balance() t2.join() account.show_balance() **]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
