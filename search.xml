<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[中火烹饪]]></title>
    <url>%2F2019%2F10%2F18%2FPython%E7%83%B9%E9%A5%AA%2F</url>
    <content type="text"><![CDATA[鸭子类型鸭子类型总是在动态语言中被提到，所谓鸭子类型就是：如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子（If it walks like a duck and quacks like a duck, it must be a duck）。我们不关心它到底是不是鸭子，只关注行为（即关注对象的是不是有相似的方法） 动态语言与静态语言：动态语言能够在运行的时候改变其结构（属性、方法），如Python的类定义完成后，可以随时添加或删除它的属性；相比较静态语言，任何类一旦定义后，就决不能在运行时改变其结构（引申出强类型和弱类型语言问题：） 可以举出很多例子： 对于定义了__iter__和__next__的方法的任何对象就是迭代器，对象本身不收限制，它可以是列表、元组或者类 列表的extend方法，它的参数可以是任何可迭代的对象（list、tuple、str），而不局限与列表 1234567891011class Bar: def __iter__(self): pass def __next__(self): passa = Bar()isinstance(a, Iterator) # Trueisinstance(a, Iterable) # True 猴子补丁在维基百科上这样定义: 12the term &quot;monkey patch&quot; only refers to dynamic modifications of a class or module at runtime, motivated by the intent to patch existing third-party code as a workaround to a bug or feature which does not act as desired.“ 猴子补丁 ”一词仅指在运行时对类或模块的动态修改，其目的是为了修补现有的第三方代码，以解决错误或功能无法正常运行。 也就是猴子补丁通常就是在引用三方库或者标准库时，需要使用另外的值去修改当前引用的对象或者方法 使用math标准库中对pi使用猴子补丁（wiki上的例子） 123456import mathmath.pi # 3.141592653589793math.pi = 3math.pi # 3# restartmath.pi # 3.141592653589793 使用ujson代替json（如果在入口处执行，直接使用json） 123456789import json import ujson def monkey_patch_json(): json.__name__ = 'ujson' json.dumps = ujson.dumps json.loads = ujson.loads monkey_patch_json() 新旧式类在Python 3中所有的类都是新式类 在Python 2中，只有显示的指明父类才是新式类 1234567891011class Person: """旧式类""" passclass Person(): """旧式类（没有显示的指明父类）""" passclass Person(object): """新式类""" pass 混入类1234567891011121314class SetOnceDictMinxin: """定义混入类""" __slots__ = () def __setitem__(self, key, value): if key in self: raise KeyError(f'&#123;key&#125; already exists') return super().__setitem__(key, value) class SetOnceDict(SetOnceDictMixin, dict): # passclass Person(metaclass=SetOnceDict) pass 方法解析顺序MROMRO即Method Resolution Order 如果是单一继承 123456789101112# super(xx, self) 就是找self当前对象关于xx类的父类# 因此下述B类中 super(A, self).who() 就相当于找self对象关于A类的父类，即object类的who方法，报错AttributeError: 'super' object has no attribute 'who'class A: def who(self): print('A', end='')class B(A): def who(self): super(B, self).who() print('B', end='')b = B()b.who() 如果是多继承 1234567891011121314class A: def who(self): print('A', end='')class B: def who(self): print('B', end='')class C(A, B): def who(self): super(C, self).who() print('C', end='')c = C()c.who()# AC 如果出现菱形继承(钻石继承)，方法解析顺序 Python 3中，类似于广度优先搜索 C3算法，可以使用class.mro()就可以直接查到类的执行顺序 Python 2中旧式类，类似于深度优先搜索 12345678910111213141516171819202122232425class A: def who(self): print('A', end='') # 5class B(A): def who(self): super(B, self).who() # 3 print('B', end='') # 7class C(A): def who(self): super(C, self).who() # 4 print('C', end='') # 6class D(B, C): def who(self): super(D, self).who() # 2 print('D', end='') # 8# mro() 有魔方方法 __mro__print(D.mro())d = D()d.who() # 1# d.who() 执行，先到D类，先到B类(B类中super(B, self).who()的self是D类的对象)，此时根据类方法解析顺序到C类的who方法，再到A类的who方法，输出A，再返回到C类的输出C，再返回B类的输出B，再返回到D类输出B# 如果上述B类中self是A对象，那么就会直接调到A类，打印A[&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]ACBD]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>鸭子类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jieba中文分词和词云]]></title>
    <url>%2F2019%2F10%2F10%2Fjieba%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%92%8C%E8%AF%8D%E4%BA%91%2F</url>
    <content type="text"><![CDATA[中文分词和词云利用jieba和wordcloud分别处理中文分词和词云制作 下面是根据github上的文档做的词云 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from os import pathfrom PIL import Imageimport numpy as npimport matplotlib.pyplot as pltimport osimport jieba.analysefrom wordcloud import WordCloud, STOPWORDS# get data directory (using getcwd() is needed to support running example in generated IPython notebook)d = path.dirname(__file__) if "__file__" in locals() else os.getcwd()# Read the whole text.text = open(path.join(d, 'sky.txt'),encoding='utf-8').read()# 通过词性过滤allow_pos = ('nr',)# 进行jieba分词content2 = jieba.analyse.extract_tags(text, topK=100, withWeight=False, allowPOS=allow_pos)# 连接字符串result = ' '.join(c for c in content2)# read the mask image# taken from# https://raw.githubusercontent.com/amueller/word_cloud/master/examples/alice_mask.pngalice_mask = np.array(Image.open(path.join(d, "alice_mask.png")))# 后面用来过滤使用的，但源文档中均是对英语词汇的过滤(可以自己写一个过滤文档或者使用jieba进行词性过滤)stopwords = set(STOPWORDS)stopwords.add("said")# 注意需要添加字体(汉语)wc = WordCloud(background_color="white", max_words=2000, mask=alice_mask, stopwords=stopwords, contour_width=3, contour_color='steelblue', font_path=r'C:\Windows\Fonts\simhei.ttf')# generate word cloudwc.generate(result)# store to filewc.to_file(path.join(d, "alice.png"))# showplt.imshow(wc, interpolation='bilinear')plt.axis("off")plt.figure()plt.imshow(alice_mask, cmap=plt.cm.gray, interpolation='bilinear')plt.axis("off")plt.show() 效果图 在线词云生成工具推荐站点]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>分词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas]]></title>
    <url>%2F2019%2F09%2F30%2Fpandas%2F</url>
    <content type="text"><![CDATA[介绍pandas是一个Python软件包，提供快速，灵活和富于表现力的数据结构，旨在使结构化（表格，多维，潜在异构）和时间序列数据的处理既简单又直观。 具有异构类型列的表格数据，例如在SQL表或Excel电子表格中 有序和无序（不一定是固定频率）时间序列数据。 具有行和列标签的任意矩阵数据（同类型或异类） 观察/统计数据集的任何其他形式。实际上，数据根本不需要标记即可放入pandas数据结构中 pandas的两个主要数据结构分别是Series（一维）和DataFrame（二维），可处理金融，统计，社会科学以及许多工程领域中的绝大多数典型用例。pandas建立在numpy上，旨在与许多其他第三库很好地集成在科学计算环境中。 轻松处理浮点数据和非浮点数据中的缺失数据（表示为NaN） 大小可变性：可以从DataFrame和更高维的对象中插入和删除列 自动和显式的数据对齐：可以将对象显式地对齐到一组标签，或者用户可以简单地忽略标签并让Series，DataFrame等自动为您对齐数据 强大，灵活的分组功能，可对数据集执行拆分应用合并操作，以汇总和转换数据 使它易于转换其他Python和NumPy的数据结构参差不齐，不同索引的数据转换成数据帧对象 基于智能标签的切片，花式索引和 大数据集子集 直观的合并和联接数据集 灵活地重塑和旋转数据集 轴的分层标签（每个刻度可能有多个标签） 强大的IO工具，用于从平面文件（CSV和定界），Excel文件，数据库加载数据，以及从超快HDF5格式保存/加载数据 特定于时间序列的功能：日期范围生成和频率转换，移动窗口统计信息，移动窗口线性回归，日期移动和滞后等。 Series行索引 索引取值 DataFrame]]></content>
      <categories>
        <category>Python</category>
        <category>data_analyses</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现windows桌面背景自动变换]]></title>
    <url>%2F2019%2F09%2F27%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%A1%8C%E9%9D%A2%E8%87%AA%E5%8A%A8%E5%8F%98%E6%8D%A2%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[首先​ 在某个下午，无意中感觉自己的桌面背景太丑了，想换一张有特色的的图。马上就上花瓣网，找到类似的星期图，然后就想到自己能不能写个程序，让它根据时间自己变换到符合星期X的图片。 想法： 搞一个bat执行文件 写个python程序，转成exe执行文件 后面确认第二个想法 具体实现三方库安装需要的包，处理图片的Pillow（远古win9x时期，通常使用bmp作为图片格式，使用jpeg格式需要打开web支持；现在主流windows都是支持的），处理windows功能的pywin32（64位的系统也装这个）h和win32gui，打包exe的PyInstaller 程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import osimport datetimeimport timeimport win32apiimport win32conimport win32guifrom PIL import ImageDAY_DICT = &#123;0: 'Mon', 1: 'TUE', 2: 'WE', 3: 'THU', 4: 'FRI', 5: 'SA', 6: 'SU'&#125;def set_desktop(today_pic): """修改桌面图片""" key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER, "Control Panel\\Desktop", 0, win32con.KEY_SET_VALUE) win32api.RegSetValueEx(key, "WallpaperStyle", 0, win32con.REG_SZ, "2") # 2拉伸适应桌面,0桌面居中 win32api.RegSetValueEx(key, "TileWallpaper", 0, win32con.REG_SZ, "0") win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, today_pic, 1+2)def jpg2bmp(): pic_file = os.listdir('pics') pic_loc = os.path.dirname(os.path.abspath(__file__)) + '\\pics\\' # 将jpg转换为bmp图片 for pic in pic_file: image = Image.open(pic_loc + pic) image.save((pic_loc + pic).replace('jpg', 'bmp'), 'BMP')def rtn_pic(): # weekday 返回0-6 对应周一到周日 pic_loc = os.path.dirname(os.path.abspath(__file__)) + '\\pics\\' day_of_week = datetime.datetime.today().weekday() today_pic = pic_loc + DAY_DICT[day_of_week + 1] + '.bmp' return today_picdef main(today_pic): while True: set_desktop(today_pic) today = datetime.date.today() new_time = time.time() # 明天时间 tomorrow = today + datetime.timedelta(days=1) # 明天时间戳 tomorrow_start_time = int(time.mktime(time.strptime(str(tomorrow), '%Y-%m-%d'))) diff = tomorrow_start_time - new_time if diff &gt; 0: time.sleep(diff)if __name__ == '__main__': main(rtn_pic()) 打包exe使用时，在主程序文件目录使用命令 pyinstaller -F -w -i 图标文件 程序文件 -F 指的打包成exe文件 -w 取消控制台显示 -i 忽略错误继续打包 举例 pyinstaller -F -w -i my.ico release_1.py 由于我的功能只需要一个执行文件就解决了，当有多个执行文件，可以参看这篇文档 操作成功后会在当前目录下生成build目录(存放配置文件和库文件)，dist目录(执行文件)，程序名.spec(包含引用程序文件、总结、包文件说明等等) 设置自启动自启动主要是通过修改注册表项文件而实现的 具体位置，通常位于 计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run 然后点击Run，能看见本机已经存在的很多启动项，新建项(程序名)和数值数据（程序存放位置 如d:\work\a.exe）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>桌面背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绘图]]></title>
    <url>%2F2019%2F09%2F25%2F%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[matplotlib pandas]]></content>
      <categories>
        <category>Python</category>
        <category>data_analyses</category>
      </categories>
      <tags>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql命令行程序相关]]></title>
    <url>%2F2019%2F09%2F23%2FMysql%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[常规命令查看/使用使用数据库 show databases; |use database; 查看表/查看表结构 show tables; | show columns from table / desc table 查看已创建的表、数据库的语句 show create table tb_name / show create database db_name 查看相关的帮助命令 help show 注意事项 MySQL不要求单条语句后加上分号，但是在命令行程序中单条语句必须分号结束 不区分大小写，但是最好按大小写惯例来写(标识符大写，表库等名小写，函数名首字母大写) NULL和空值(‘’)是不一样的，NULL占有空间，而后者不占空间(装空气打的杯子和真空的杯子); 判断NULL使用 IS NULL和IS NOT NULL，判断空值使用&lt;&gt;、==和!= MySQL可以使用任意AND和OR的组合，但是AND的优先级高于OR，因此特殊情况别忘了给OR加括号，并且鼓励在任何使用AND和OR操作符时都加上括号，它并不会给你带来任何损失 %通配符匹配0、1和多个字符，并且它是不能匹配NULL的， _只能匹配1个字符；除此，不要过度使用它，除非有必要，也不要将通配符放在首位(%放在首位索引不能命中)。 like匹配整个值，REGEXP可以匹配值的任意长度(若想匹配特定值可以使用定位符^和$) 组合查询UNION会去重，并且在使用ORDER BY时，只能使用一次排序，并且只能对最后一个SELECT语句使用 使用一个INSERT插入多条语句比多次使用INSERT插入一条语句快得多 使用EXPLAIN命令可以查询索引命中情况]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python富比较]]></title>
    <url>%2F2019%2F09%2F20%2Fpython%E5%AF%8C%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Python富比较 富比较，即Rich Comparisons，创立于python2.1时期，使用富比较取代了__cmp__返回值(0,-1,1)的传统比较方式(后者在python3.4已被废除)。 富比较的主要方式有__eq__ __ne__ __gt__ __lt__ __ge__ __le__6种比较 其主要用于复杂对象之间的比较 下面分析其主要用法和注意事项： 当程序员定义了所有的比较方式，此时对象之间的比较就会一一对应到其定义的方法 当同时实现__eq__方法和__ne__方法时，此时使用!=和==会调用各自的方法 1234567891011121314151617181920212223class Apple: def __init__(self, color, price): self.color = color self.price = price def __eq__(self, other): print(&apos;execute __eq__&apos;) return self.price == other.price def __ne__(self, other): print(&apos;execute __ne__&apos;) return self.price != other.priceap1 = Apple(&apos;red&apos;, 10)ap2 = Apple(&apos;green&apos;, 10)print(ap1==ap2)print(ap1!=ap2)execute __eq__Trueexecute __ne__False 当实现__eq__方法，未实现__ne__方法，此时使用!=相当于执行__eq__后再取反 12345678910111213141516171819class Apple: def __init__(self, color, price): self.color = color self.price = price def __eq__(self, other): print(&apos;execute __eq__&apos;) return self.price == other.priceap1 = Apple(&apos;red&apos;, 10)ap2 = Apple(&apos;green&apos;, 10)print(ap1==ap2)print(ap1!=ap2)execute __eq__Trueexecute __eq__False 当实现__ne__方法，未实现__eq__方法，此时使用==相当于使用is 123456789101112131415161718class Apple: def __init__(self, color, price): self.color = color self.price = price def __ne__(self, other): print(&apos;execute __ne__&apos;) return self.price != other.priceap1 = Apple(&apos;red&apos;, 10)ap2 = Apple(&apos;green&apos;, 10)print(ap1==ap2)print(ap1!=ap2)Falseexecute __ne__False 当单独实现__gt__(或__lt__)，此时使用&lt;(或&gt;)相当于执行__gt__(或__lt__)再取反]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Rich Comparisons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密和数字摘要]]></title>
    <url>%2F2019%2F01%2F16%2F%E5%8A%A0%E5%AF%86%E5%92%8C%E6%95%B0%E5%AD%97%E6%91%98%E8%A6%81%2F</url>
    <content type="text"><![CDATA[数字摘要数字摘要是将任意长度的信息变成固定长度的短信息, 它类似于一个自变量是消息的函数。 加密算法]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>加密和数字摘要</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts使用]]></title>
    <url>%2F2019%2F01%2F12%2Fecharts%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍ECharts，缩写来自Enterprise Charts，商业级数据图表，一个纯Javascript的图表库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器（IE6/7/8/9/10/11，chrome，firefox，Safari等），底层依赖轻量级的Canvas类库ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。 支持折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）、雷达图（填充雷达图）、和弦图、力导向布局图、地图、仪表盘、漏斗图、事件河流图等12类图表，同时提供标题，详情气泡、图例、值域、数据区域、时间轴、工具箱等7个可交互组件，支持多图表、组件的联动和混搭展现。 写一个接口拿取一些要显示的数据 1234567891011def chart_data(request): """返回图表需要的数据""" names, totals = [], [] with connections['default'].cursor() as cursor: cursor.execute('select name, total from ( ' ' select agentid, count(agentid) as total from tb_agent_estate group by(agentid)) as t1 ' ' inner join tb_agent t2 on t1.agentid=t2.agentid') for row in cursor.fetchall(): names.append(row[0]) totals.append(row[1]) return JsonResponse(&#123;'names': names, 'totals': totals&#125;) 在线导入echarts 1&lt;script src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts.min.js"&gt;&lt;/script&gt; 找到一个简单的柱状图的例子，如https://www.echartsjs.com/examples/editor.html?c=bar-tick-align , 将对应的代码放到AJAX执行成功返回的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; 'url': '/backend/chart/', 'type': 'get', 'dataType': 'json', 'success': function(data)&#123; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init($('#main')[0]); // 指定图表的配置项和数据 option = &#123; color: ['#3398DB'], title: &#123; text: 'XX楼盘' &#125;, legend: &#123; data:['楼盘数'] &#125;, tooltip : &#123; trigger: 'axis', axisPointer : &#123; // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis : [ &#123; type : 'category', data : data.names, axisTick: &#123; alignWithLabel: true &#125; &#125; ], yAxis : [ &#123; type : 'value' &#125; ], series : [ &#123; name:'楼盘数', type:'bar', barWidth: '60%', data: data.totals &#125; ] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &#125;, 'error': function(data)&#123; &#125; &#125;);&lt;/script&gt; 效果 附录echarts实例 echarts文档]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django进阶]]></title>
    <url>%2F2019%2F01%2F12%2FDjango%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[多路数据库配置使用多个数据库的最简单方法是设置数据库路由方案。默认路由方案可确保对象对其原始数据库保持“粘性”（即，从foo数据库检索的对象将保存在同一数据库中）。默认路由方案可确保在未指定数据库的情况下，所有查询都会回退到default数据库。 在Django中支持多路数据库联合使用, ·详细内容可以查看官方文档 数据库配置 12345678910111213141516171819202122232425DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'fangtx', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': 3306, 'TIME_ZONE': 'Chongqing', &#125;, 'hrs': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'hrs', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': 3306, 'TIME_ZONE': 'Chongqing', &#125;&#125;# 指定一个提供数据库路由的类DATABASE_ROUTERS = [ 'common.routers.BackendRouter'] 数据库路由类 如上在common/routers.py中创建路由类BackendRouter 12345678910111213141516171819202122232425262728293031class BackendRouter: """ 在已认证的app中,控制所有数据库模型操作的类 """ def db_for_read(self, model, **hints): """ 从对应数据库中读入 """ if model._meta.app_label == 'hrs': return 'hrs' return 'default' def db_for_write(self, model, **hints): """ 写数据到对应数据库 """ if model._meta.app_label == 'hrs': return 'hrs' return 'default' def allow_relation(self, obj1, obj2, **hints): """ 若app已注册,允许建立联系 """ return True def allow_migrate(self, db, app_label, model_name=None, **hints): """ 允许迁移 """ return None 迁移反向生成和反向迁移 12345# 反向生成key为hrs的数据库模型到backend.models.py中python manage.py inspectdb --database hrs &gt; backend/models.py# 正向迁移key为hrs的数据库中python manage.py migrate --database=hrs 给模型文件指定数据库 如上, 在common.models.py中, 在需要的模型对象中 12# 在meta中指定这个类对应的数据库, hrs是数据库配置中的keyapp_label = 'hrs' ##正向迁移和反向生成 正向迁移通过手动建立模型(models), 然后使用python manage.py makemigrations 进行生成迁移文件, 在使用python manage.py migrate执行迁移 反向生成生成SQL文件 使用PowerDesigner反向生成逻辑模型, 将逻辑模型生成物理模型, 再将物理模型反向生成数据库建库建表sql文件 生成数据库表 12# 登录mysql(以MySQL为例)source &lt;sql文件位置&gt; 反向生成模型 123# 在settings配置好数据库后, 默认反向生成key为default的数据库模型文件# backend是app名python manage.py inspectdb &gt; backend/models.py 数据库性能优化取消外键约束如果要优化数据库性能, 就要减少不必要的外键约束, 通过代码层面的约束来保证参照完整性使用正向工程时, 可以给ForeignKey添加一个db_contraint=False的设定来取消外键约束 1+N问题如果查询对象的同时还是要查询它的关联对象, 就会引发1+N查询(或N+1查询), 程序的性能会下降的非常明显, 而且数据库的压力非常大。因此, 必须对自动生成的SQL语句进行优化. 如果有一对多关联, 需要用连接查询加载关联对象, 使用select_related()加载 如果有多对多关联, 需要用连接查询加载关联对象, 使用prefetch_related()加载 映射通过映射(投影)的方式, 限制查询对象的字段 使用only()限制只要哪些字段 使用defer限制不要哪些字段 ###原生SQL Django中可以使用聚合函数aggregate()和分组函数annotate(), 但是真正使用对象来操作时, 非常麻烦, 可使用原生SQL代替ORM的方式 from django.db import connection, connections 通过引入connection来选择默认的数据库连接去建立游标对象; coonections可以用字典的形式取任意数据库的连接的游标, 它的键对应数据库配置的键 1234567891011from django.db import connectionsdef chart_data(request): names, totals = [], [] with connections['default'].cursor() as cursor: cursor.execute('select name, total from ( ' ' select agentid, count(agentid) as total from tb_agent_estate group by(agentid)) as t1 ' ' inner join tb_agent t2 on t1.agentid=t2.agentid') for row in cursor.fetchall(): names.append(row[0]) totals.append(row[1]) return JsonResponse(&#123;'names': names, 'totals': totals&#125;) 除此还有raw方法 1Emp.objects.raw('select empno, ename, job from TbEmp where dno=10') 日志日志相关查看SQL执行情况 Django中可以配置日志, 通过日志查看数据库操作执行时间和执行次数 日志级别** NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; FATAL 日志级别越低，内容越详细 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, # 配置日志格式化器 'formatters': &#123; 'simple': &#123; 'format': '%(asctime)s %(module)s.%(funcName)s: %(message)s', 'datefmt': '%Y-%m-%d %H:%M:%S', &#125;, 'verbose': &#123; 'format': '%(asctime)s %(levelname)s [%(process)d-%(threadName)s] ' '%(module)s.%(funcName)s line %(lineno)d: %(message)s', 'datefmt': '%Y-%m-%d %H:%M:%S', &#125; &#125;, # 配置日志过滤器 'filters': &#123; 'require_debug_true': &#123; '()': 'django.utils.log.RequireDebugTrue', &#125;, &#125;, # 配置日志处理器 'handlers': &#123; 'console': &#123; 'class': 'logging.StreamHandler', 'level': 'DEBUG', 'filters': ['require_debug_true'], 'formatter': 'simple', &#125;, 'file1': &#123; 'class': 'logging.handlers.TimedRotatingFileHandler', 'filename': 'access.log', 'when': 'W0', 'backupCount': 12, 'formatter': 'simple', 'level': 'INFO', &#125;, 'file2': &#123; 'class': 'logging.handlers.TimedRotatingFileHandler', 'filename': 'error.log', 'when': 'D', 'backupCount': 31, 'formatter': 'verbose', 'level': 'WARNING', &#125;, &#125;, # 配置日志器 'loggers': &#123; 'django': &#123; 'handlers': ['console', 'file1', 'file2'], 'propagate': True, 'level': 'DEBUG', &#125;, &#125;&#125; Debug工具Django-Debug-Toolbar，非常好用的工具，可以查看当前django版本、设置、sql查询详情、请求、请求头、静态文件、模板、缓存、信号量、日志等（强烈建议） 1234567891011121314151617181920# appINSTALLED_APPS = [ 'debug_toolbar',]#configDEBUG_TOOLBAR_CONFIG = &#123; # 引入jquery库 'JQUERY_URL': 'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js', # 工具栏是否折叠 'SHOW_COLLAPSED': True, # 是否显示工具栏 'SHOW_TOOLBAR_CALLBACK': lambda x: True,&#125;# middlewareMIDDLEWARE = [ # 放在第一个 'debug_toolbar.middleware.DebugToolbarMiddleware',] 短信服务借助第三方短信服务提供商, 如云片,SendClound 螺丝帽, 秒赛, 互亿无线,云之讯等等这样的平台非常多, 我们选择的时候通常以它的性价比, 短信到达率,到达时间作为使用的参考点。下面以秒赛作为例子: 实现进入秒赛官网,注册登录 进行签名配置 进行模板配置, 后续代码中的message内容就源于此 找到API或者实例中python部分 官方给的基础的实现 1234567891011121314151617181920212223242526class SendCode: def send(self, account, pswd, mobile, msg, ts, state): url = 'http://139.196.108.241:8080' + &#123; 1: '/Api/HttpSendSMYzm.ashx', 2: '/Api/HttpSendSMYx.ashx', 3: '/Api/HttpSendSMVoice.ashx' &#125;[state] if ts != "": m = hashlib.md5() strs = account + pswd + str(ts) m.update(strs.encode("utf8")) pswd = m.hexdigest() body = &#123;"account": account, "pswd": pswd, "mobile": mobile, "msg": msg, "ts": str(ts)&#125; header_dict = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko', "Content-Type": "application/x-www-form-urlencoded"&#125; response = requests.post(url, data=body, headers=header_dict) return json.loads(response.text)# account 用户账号# pswd 必填参数。用户密码# mobile 必填参数。合法的手机号码# msg 必填参数。短信内容# ts 可选参数，时间戳，格式yyyyMMddHHmmss# state 必填参数 状态 1:验证码短信 2:营销短信 3:语音验证码 进行自己的封装 1234567891011121314151617ACCOUNT = xxxPASSWORD = xxxdef random_code(length=6): items = StringIO() for _ in range(length): items.write(str(random.randint(0, 9))) return items.getvalue()def message(code): return f'您的验证码是&#123;code&#125;，如非本人操作，请忽略本短信！' def send_msg(mobile, code): sd = SendCode() msg = message(code) res = sd.send(ACCOUNT, PASSWORD, mobile, msg, (int(time.time())), 1) return res 视图函数 123456789def message_code(request, mobile): """发送短信验证码""" code = random_code() res = send_msg(mobile, code) # 调用短信网关的函数返回字典对象就用JsonResponse处理 # 若返回字符串就用HttpResponse并制定MIME类型处理即可, ensure_ascii使在返回的数据能以真正的编码方式呈现(这里是utf-8,没有返回的数据就会以utf-8编码的字节形式呈现) msg = json.dumps(&#123;'code': 200, 'msg': '短信已发出, 注意查收'&#125;, ensure_ascii=False) return HttpResponse(msg, content_type='application/json') # return JsonResponse(&#123;'code': 200, 'msg': '短信已发出, 注意查收'&#125;) 缓存缓存配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768CACHES = &#123; # 默认缓存 # LOCATION中配置redis的实际位置, 如果有奴隶redis, 只需将他们放到主人的后面即可. # 例如: 'LOCATION': [master, slave1, slave2 ...] # KEY_PREFIX 键的前缀, 在实际开发中区分不同应用的关键 # redis默认下有16库, 索引号0-15, 端口号6379后接数据库索引号 'default': &#123; 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ 'redis://xx.xxx.xxx.xx:6379/0', ], 'KEY_PREFIX': 'app_name', 'OPTIONS': &#123; 'CLIENT_CLASS': 'django_redis.client.DefaultClient', 'CONNECTION_POOL_KWARGS': &#123; 'max_connections': 1000, &#125;, 'PASSWORD': '123456', &#125; &#125;, # 页面缓存 'page': &#123; 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ 'redis://xx.xxx.xxx.xx:6379/1', ], 'KEY_PREFIX': 'app_name:page', 'OPTIONS': &#123; 'CLIENT_CLASS': 'django_redis.client.DefaultClient', 'CONNECTION_POOL_KWARGS': &#123; 'max_connections': 500, &#125;, 'PASSWORD': '123456', &#125; &#125;, # 会话缓存 # TIMEOUT 超时时间, 此处为14天 'session': &#123; 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ 'redis://xx.xxx.xxx.xx:6379/2', ], 'KEY_PREFIX': 'app_name:session', 'TIMEOUT': 1209600, 'OPTIONS': &#123; 'CLIENT_CLASS': 'django_redis.client.DefaultClient', 'CONNECTION_POOL_KWARGS': &#123; 'max_connections': 2000, &#125;, 'PASSWORD': '123456', &#125; &#125;, # 接口数据缓存 'api': &#123; 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': [ 'redis://xx.xxx.xxx.xx:6379/3', ], 'KEY_PREFIX': 'app_name:api', 'OPTIONS': &#123; 'CLIENT_CLASS': 'django_redis.client.DefaultClient', 'CONNECTION_POOL_KWARGS': &#123; 'max_connections': 500, &#125;, 'PASSWORD': '123456', &#125; &#125;,&#125; session信息缓存到redis中在已经配置好缓存的情况下, 将下面的配置添加到系统配置中 12SESSION_ENGINE = 'django.contrib.sessions.backends.cache'SESSION_CACHE_ALIAS = 'session' 添加session信息 12# 在视图函数执行的时候, 添加session信息, 将会将session缓存到redis中request.session['mobile_code'] = code 短信记录缓存到redis中由于已经配置好了redis缓存, 我们利用缓存直接在发送短信时候, 将自定义内容缓存到redis中;当然, 也可以通过redis连接的方式,将数据存入到redis中 通过cache和caches 12345# cache使用缓存中的key为default的库, cache使用键值对的方式去找配置的对应一个redis库 from django.core.cache import cache, caches# 在发送短信时, 将短信记录存入redis, 设置超时时间120秒caches['default'].set(f'mobile_code:&#123;mobile&#125;', code, timeout=120) 通过redis连接 1234567# 通过django-redis获得原生redis连接, 功能过多, 更具有拓展性# django-redis默认使用Pickle序列化来(反)序列化字符串(字符串与字节变换)from django_redis import get_redis_connection# 在发送短信, 将短信记录存入到redis, 设置超时时间120秒, alias可以指定是哪个redis库redis_conn = get_redis_connection(alias='default')redis_conn.set(f'mobile_code:&#123;mobile&#125;', code, ex=120) 短信发送频率限制实际使用中, 我们不可能让用户发送短信后又可以马上发复发送短信, 这无疑大大增加了成本, 并且短信的处理也是需要时间的, 因此应该将发送短信限制一个有效时间, 如60秒或者120秒 上面已经实现了将发送短信的记录存入到redis中, 因此我们只需在发送短信给一个判断, 去取这个redis记录, 如果没有, 当然你可以继续发送短信, 若有记录, 你就必须等待这个记录的有效时间长度了 1234567# 采用django框架封装的redis调用(简单弱小)if caches['default'].get(f'mobile_code:&#123;mobile&#125;'): return JsonResponse(&#123;'code': 1001, 'message': '120秒后可重新发送'&#125;)# 采用原生redis连接, 可以使用所有redis的方法或者类型if get_redis_connection().get(f'mobile_code:&#123;mobile&#125;'): return JsonResponse(&#123;'code': 1001, 'message': '120秒后可重新发送'&#125;) 中间件控制对应上面短信有效时间限制处理的另外一种有效的方式, 就是中间件。它更准确应该成为拦截过滤器, 属于代理模式 django最新关于中间件的写法, 已经变成了类似于装饰器的写法, 在函数中写函数的方式。 中间件函数 123456789101112131415161718192021222324252627282930import refrom django.http import JsonResponsefrom django_redis import get_redis_connectionPATTERN = re.compile(r'/common/send_msg/(?P&lt;mobile&gt;1[3-9]\d&#123;9&#125;)')def block_sms_middleware(get_resp): def middleware(request, *args, **kwargs): # 对应执行函数匹配执行的路由 if request.path.startswith('/common/send_msg'): matcher = PATTERN.fullmatch(request.path) # 手机号码格式正确 if matcher: mobile = matcher.group('mobile') conn = get_redis_connection(alias='default') # 如果redis中已经存在短信记录, 就直接返回 if conn.get(f'mobile_code:&#123;mobile&#125;'): return JsonResponse(&#123;'code': 1001, 'message': '120秒后可重新发送'&#125;) else: resp = get_resp(request, *args, **kwargs) else: return JsonResponse(&#123;'code': 1001, 'message': '手机号码不正确'&#125;) else: resp = get_resp(request, *args, **kwargs) return resp return middleware 配置 在系统配置文件中加入要使用中间件 1'common.middlewares.block_sms_middleware', 异步化处理如上, 调用第三方平台而且不需要马上出结果的应用, 我们都应该进行异步化处理。因为, 调用三方平台所需要的时间总是不可预估的, 不能使这个调用阻塞到其他功能，而解决这个问题的方式, 可以采用消息队列处理, 让执行函数延期执行 python三方库中, 提供一个异步化处理的库– celery 注意: 如果你使用的是windows系统并且celery的版本是4以上的时候, 因为celery对它已经不再支持, 你就需要考虑再安装一个eventlet的库. 配置 1234567# 注册环境变量os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'fangtx.settings')# broker代表消息代理(从哪里获取队列服务), backend将所得结果存储起来app = celery.Celery('common.utils', broker='redis://:123456@xx.xxx.xxx.xx:6379/0',)# 从项目的配置文件读取Celery配置信息app.config_from_object('django.conf:settings') 使用 有了上面的配置, 就是使用`@app.task`作为你想要使用函数的装饰器 12345678@app.taskdef send_msg(mobile, code): sd = SendCode() msg = message(code) res = sd.send(ACCOUNT, PASSWORD, mobile, msg, (int(time.time())), 1) redis_conn = get_redis_connection(alias='default') redis_conn.set(f'mobile_code:&#123;mobile&#125;', code, ex=120) return res 在调用上面被装饰的函数时, 使用send_msg.delay()的方式, 使用异步化处理 12345678def message_code(request, mobile): """发送短信验证码""" code = random_code() request.session['mobile_code'] = code # delay延期处理 res = send_msg.delay(mobile, code) msg = json.dumps(&#123;'code': 200, 'msg': '短信已发出, 注意查收'&#125;, ensure_ascii=False) return HttpResponse(msg, content_type='application/json') 此时, 我们发送的短信就会被缓存到redis的列表类型的数据中， 它会帮我们创建一个key为celery的列表数据, 并遵守队列即先入先出的原则。当我们使用下面的命令就会帮我们处理. 这也是典型的空间换取时间的做法。 1celery -A common.utils worker -l info -P eventlet Django-Rest-Frameworkrest和restful 知识点 官方文档地址 安装配置安装 1pip install djangorestframework 配置 123INSTALLED_APPS = [ 'rest-framework', ] rest-framework配置 1234567891011121314151617181920REST_FRAMEWORK = &#123; # 配置默认页面大小 'PAGE_SIZE': 5, # 配置默认的分页类 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', # 配置默认的限流类 'DEFAULT_THROTTLE_CLASSES': ('rest_framework.throttling.AnonRateThrottle', ), # 配置限流的策略 # 'DEFAULT_THROTTLE_RATES': &#123; # 'anon': '3/min', # &#125;, # 配置默认授权类 # 'DEFAULT_PERMISSION_CLASSES': ( # 'rest_framework.permissions.IsAuthenticated', # ), # 配置默认认证类 # 'DEFAULT_AUTHENTICATION_CLASSES': ( # 'rest_framework_jwt.authentication.JSONWebTokenAuthentication', # ),&#125; rest-framework分页器有3种: 分别为PageNumberPagination / LimitOffsetPagination / CursorPagination 限流策略, 即限制同一个ip访问接口的次数, 在FBV中使用@throttle_classes(())装饰器能够阻止限流 序列化器为了得到自己想要的对象或者复杂对象的组合（即数据序列化），可以使用列表和字典类型取组装，但无疑效率低下，提倡的做法是利用rest_framework中的serializers编写序列化模块, 将数据序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from rest_framework import serializersfrom common.models import Districtclass DistrictSerializer(serializers.ModelSerializer): class Meta: model = District # fields = __all__ 就是使用所有字段 fields = ('distid', 'name')class DistrictDetailSerializer(serializers.ModelSerializer): # 定义一个使用序列化方法的字段 cities = serializers.SerializerMethodField() # 方法名要与上面的字段对应 @staticmethod def get_cities(district): # 使用自关联字段去找distid queryset = District.objects.filter(parent__distid=district.distid).only('distid', 'name') # results = [] # for city in queryset: # results.append(DistrictSerializer(city).data) # return results return DistrictSerializer(queryset, many=True).data class Meta: model = District fields = ('distid', 'name', 'intro', 'cities')class AgentSerializer(serializers.ModelSerializer): class Meta: model = Agent fields = ('agentid', 'name', 'tel')class EstateSerializer(serializers.ModelSerializer): district = serializers.SerializerMethodField() agents = serializers.SerializerMethodField() @staticmethod def get_district(estate): return DistrictSerializer(estate.district).data @staticmethod def get_agents(estate): return AgentSerializer(estate.agents, many=True).data class Meta: model = Estate fields = '__all__'class HouseTypeSerializer(serializers.ModelSerializer): class Meta: model = HouseType fields = '__all__' 装饰器实现缓存1234567891011121314151617181920212223242526272829303132from django.views.decorators.cache import cache_pagefrom rest_framework.decorators import api_viewfrom rest_framework.response import Responsefrom api.serializers import DistrictSerializerfrom api.serializers import DistrictDetailSerializer# 指定http只使用GET操作@api_view(['GET'])# 对于经常使用又不修改的数据, 进行缓存, 下次使用的时候直接读缓存@cache_page(timeout=None, cache='api')# 通过cache_page装饰器, 配置缓存和超时时间# @throttle_classes(())# 阻止限流def provinces(request): # 通过自关联字段去找其有没有distid值, 若没有就是省级区域 queryset = District.objects.filter(parent__isnull=True) # 通过自定义的序列化器序列化数据 many=True表示查询多个对象 serializer = DistrictSerializer(queryset, many=True) # 通过序列化器获得序列化之后的数据(字典或列表)生成响应 # 方式1 # msg = json.dumps(serializer.data, ensure_ascii=False) # return HttpResponse(msg, content_type='application/json') # 方式2 # return JsonResponse(serializer.data, safe=False) # 方式3 return Response(serializer.data)@api_view(['GET'])@cache_page(timeout=None, cache='api')def cities(request, distid): district = District.objects.filter(distid=distid).first() serializer = DistrictDetailSerializer(district) return Response(serializer.data) 使用id和pid的方式, pid为id的上一级id, 并且将pid指定为自关联字段, 通过上面的cities方法, 就能逐层显示数据(查询省显示市一级, 查询市显示县一级)。主要应用于能够自关联的模型结构。 通过省查看市一级 通过市查看县一级 @cache_page用于基于函数的视图函数提供缓存的装饰器 rest-framework配置中已经提供了分页功能, 但是注意, 这个功能只对CBV(基于类的视图函数)生效, 而不对上面的FBV(基于函数的视图函数)生效。 基于类使用装饰器缓存 123456@method_decorator(cache_page(timeout=120, cache=&apos;api&apos;), name=&apos;get&apos;)class EstatesView(ListAPIView): # 指定查询集 queryset = Estate.objects.all().select_related(&apos;district&apos;).prefetch_related(&apos;agents&apos;) # 指定序列化器 serializer_class = EstateSerializer 对于使用类的视图函数, 要使用@method_decorator装饰器, name=&#39;get&#39;参数表示装饰器要装饰的函数使用, 它也表示HTTP要操作的动词 使用装饰器非常灵活, 这样我们能够自定义 ListAPIView123456# 通过drf-extension配置缓存, 使用CacheResponseMixin混入类class EstatesView(CacheResponseMixin, ListAPIView): # 指定查询集 queryset = Estate.objects.all().select_related('district').prefetch_related('agents') # 指定序列化器 serializer_class = EstateSerializer 路由 123urlpatterns = [ path('estates/', views.EstatesView.as_view(), name='estates'),] ListAPIView是继承于mixins.ListModelMixin, GenericAPIView, 所以有列出所有记录的功能 drf-extensions的使用需要安装pip install drf-extensions， 并且配置 123456789# 配置DRF扩展来支持缓存API接口调用结果REST_FRAMEWORK_EXTENSIONS = &#123; 'DEFAULT_CACHE_RESPONSE_TIMEOUT': 300, # 使用哪个缓存库的key 'DEFAULT_USE_CACHE': 'api', # 配置默认缓存单个对象的key函数 'DEFAULT_OBJECT_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_object_cache_key_func', # 配置默认缓存对象列表的key函数 'DEFAULT_LIST_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_list_cache_key_func', ModelViewSet12345class HouseTypeViewSet(CacheResponseMixin, ModelViewSet): queryset = HouseType.objects.all() serializer_class = HouseTypeSerializer # 指定不分页 pagination_class = None ModelViewSet这个类其实继承于多个操作模型的类, 因此它能够实现查看一条或多条记录, 增加, 修改, 删除的功能 1mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet 除此还有一个ReadOnlyModelViewSet 它只支持查看一条和多条的功能 路由 1234router = DefaultRouter()# 注册路由集, 可使用多个路由pathrouter.register('housetypes', HouseTypeViewSet)urlpatterns += router.urls 分页DRF中提供的分页共有三种，分别为 PageNumberPagination 根据Page_size和page来进行分页 LimitOffsetPagination 根据限制查询数目和偏移量来分页 CursorPagination 该分页只显示前进和后退两个控件，不允许用户直接任意导航位置；基于游标的分页要结果集顺序唯一不变，因此通常将排序即ordering设置为时间戳字段（必须为queryset中的一个字段） 注：三种方式都提供了限制当前页总数的功能，防止被恶意调用 配置12345# 使用基于PageNumber的分页器REST_FRAMEWORK = &#123; 'PAGE_SIZE': 5, 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination'&#125; 使用只能CBV 12345678# views.pyclass HouseTypeViewSet(ModelViewSet): """视图集""" queryset = Estate.objects.all().select_related('district').prefetch_related('agents') serializer_class = EstateSerializer # 使用默认的分页器 # pagination_class = None pagination_class = CustomCursorPagination 自定义分页器12345678910111213141516171819202122# paginations.pyfrom rest_framework.pagination import PageNumberPagination, LimitOffsetPagination, CursorPaginationclass CustomPageNumberPagination(PageNumberPagination): max_page_size = 6 page_size = 4 page_size_query_param = 'page_size'class CustomLimitOffsetPagination(LimitOffsetPagination): default_limit = 4 max_limit = 6class CustomCursorPagination(CursorPagination): # 对当前页即时修改不生效，只有使用下次调用api才生效page_size page_size = 5 max_page_size = 8 # 根据排序的字段默认升序，使用-name为降序 ordering = 'name' page_size_query_param = 'page_size' 缓存缓存主要是将热数据或者长时间不改变的数据缓存到数据库/文件系统/缓存服务器/本地内存缓存中，减轻数据库服务器的工作压力。 下面以redis缓存为例，采用django-redis三方库处理缓存（中文文档） 配置1234567891011CACHES = &#123; "default": &#123; "BACKEND": "django_redis.cache.RedisCache", "LOCATION": "redis://127.0.0.1:6379/0", "OPTIONS": &#123; "CLIENT_CLASS": "django_redis.client.DefaultClient", "PASSWORD": "mysecret" &#125; &#125;&#125;# 也可以配置多个缓存，照着模板做如配置一个机遇session的缓存(默认是缓存在数据库中--&gt;上面短信认服务--&gt;缓存) FBV即function base view基于函数实现视图显示 在FBV方式中可以采用三种方式处理缓存 django提供cache_page 1234567891011from rest_framework.decorators import api_viewfrom rest_framework.response import Responsefrom django.views.decorators.cache import cache_page@api_view(['GET', 'POST'])@cache_page(timeout=86400, key_prefix='rzlong')def cache_foo(request): queryset = District.objects.all() serializer = DistrictSerializer(queryset, many=True) return Response(serializer.data) 会建立两个缓存项（page和head），并且会拼接前缀和setting中配置组成新的前缀 django提供的cache和caches 123456789101112131415from django.core.cache import caches, cachefrom rest_framework.decorators import api_viewfrom rest_framework.response import Response@api_view(['GET', 'POST'])def cache_foo2(request): data = caches['default'].get('api:foo2') if data is None: queryset = District.objects.all() serializer = DistrictSerializer(queryset, many=True) caches['default'].set('api:foo2', serializer.data, timeout=500) return Response(serializer.data) else: return Response(data) cache默认使用default库，caches必须指定使用的库；key是字符串，value是任何可以pickle序列化（转字节串）的python对象；除此其set方法也不能指定前缀；建立一个缓存项会使用settings中前缀名与自己设立的前缀进行组合 django-redis提供的get_redis_connection（建议使用） 12345678910111213141516from django_redis import get_redis_connectionfrom rest_framework.decorators import api_viewfrom rest_framework.response import Response@api_view(['GET',])def estates(request): conn = get_redis_connection('default') data = conn.get('api:estates') if data is None: queryset = Estate.objects.all().select_related('district').prefetch_related('agents') serializer = EstateSerializer(queryset, many=True) conn.set('api:estates', json.dumps(serializer.data), timeout=400) return Response(serializer.data) else: return Response(json.loads(data)) 该方法是基于django.core.cache.caches实现的；测试的时候序列化后的对象是list类型，必须使用json进行序列化；并且此时不会使用settings中默认前缀进行拼接 CBV django提供的method_decorator – 将作用于函数的装饰器变成装饰类中方法的装饰器 12345678910111213# 对View使用@method_decorator(cache_page(timeout=300), 'get')class CBVView(ListAPIView): queryset = District.objects.all() serializer_class = DistrictSerializer # 对ViewSet使用# @method_decorator(cache_page(timeout=3600), 'list')# @method_decorator(cache_page(timeout=3600), 'retrieve')class CBVViewSet(ModelViewSet): queryset = District.objects.all() serializer_class = DistrictSerializer drf-extensions三方库提供，使用混入类进行设定 12345678910111213141516# drf-extensions的配置REST_FRAMEWORK_EXTENSIONS = &#123;# # 默认的缓存超时时间 'DEFAULT_CACHE_RESPONSE_TIMEOUT': 300,# # 默认使用哪一组缓存 'DEFAULT_USE_CACHE': 'default',# # 配置默认缓存单个对象的key函数 'DEFAULT_OBJECT_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_object_cache_key_func',# # 配置默认缓存对象列表的key函数 'DEFAULT_LIST_CACHE_KEY_FUNC': 'rest_framework_extensions.utils.default_list_cache_key_func',&#125;# 使用CacheResponseMixinclass CBVViewSet(CacheResponseMixin, ModelViewSet): queryset = District.objects.all() serializer_class = DistrictSerializer 通过自定义中间件，使用decorator_from_middleware方法将中间件变成装饰器打在对应的类上 过滤原生通过重载get_queryset()方法，然后再方法中定义所需的筛选数据（或者排序其他的都行）的代码 12345678910111213141516171819202122232425262728293031323334# urls.pyurlpatterns = [ path('estates/', EstatesView.as_view()), # &#123;pk:pk_value&#125;的字典数据会传到request中的kwargs参数中 path('estates/&lt;int:pk&gt;/', EstatesView.as_view()),]# views.pyclass EstatesView(RetrieveAPIView, ListAPIView): def get(self, request, *args, **kwargs): if 'pk' not in kwargs: self.action = 'list' return ListAPIView.get(self, request, *args, **kwargs) else: self.action = 'retrieve' return RetrieveAPIView.get(self, request, *args, **kwargs) def get_serializer_class(self): if self.action == 'list': return EstateSimpleSerialzier return EstateSerializer def get_queryset(self): """Q对象实现或关系过滤""" queryset = Estate.objects.all().select_related('district').prefetch_related('agents') q = Q() name = self.request.GET.get('name', None) if name: q |= Q(name__icontains=name) distid = self.request.GET.get('distid', None) if distid: q |= Q(district__distid=distid) queryset = queryset.filter(q) return queryset 如果想要XxxView使用Retrieve和List两种APIView的组合（没有在通用模块generic定义），需要重新定义get()方法，如果要使两种方式返回的序列化数据结构也不同，需要重新定义序列化器和重写get_serializer_class()方法；除此Q()对象可以实现或的过滤 django-filter 配置 使用三方库django-filter能够使处理对象的序列化非常容易，首先需要安装它 pip install django-filter 然后进入setting中配置 12345678INSTALLED_APPS = [ 'django-filters',]# 对全局有效，也可以直接View或ViewSet中单独定义REST_FRAMEWORK = &#123; 'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']&#125; django-filter**提供的过滤器（文档）有三种，分别为DjangoFilterBackend 容易定制化的过滤 / SearchFilter 用于搜索单个参数关键字过滤 / OrderingFilter 用于数据排序 123456789101112131415class EstatesView(RetrieveAPIView, ListAPIView): queryset = Estate.objects.all().select_related('district').prefetch_related('agents') filter_backends = [DjangoFilterBackend, OrderingFilter] # 用于DjangoFilterBackend filterset_fields = ['district', 'name'] # 用于搜索过滤 # search_fields = ['district', 'name'] # 用于数据排序 ordering = 'district' ordering_fields = ['district', 'name'] def get(self, request, *args, **kwargs): pass def get_serializer_class(self): pass ordering指定默认排序方式，ordering_fields可用于排序的可选参数集 通过自定义过滤器类实现过滤 123456789101112131415161718192021222324import django_filters as filtersfrom django.db.models import Qclass HouseInfoFilter(filters.FilterSet): title = filters.CharFilter(field_name='title', lookup_expr='icontains') hmin = filters.NumberFilter(field_name='price', lookup_expr='gte') hmax = filters.NumberFilter(field_name='price', lookup_expr='lte') district = filters.NumberFilter(method='filter_by_district') @staticmethod def filter_by_district(queryset, param_name, param_value): queryset = queryset.filter(Q(district_level2__distid=param_value) | Q(district_level3__distid=param_value) ) return queryset class Meta: model = HouseInfo fields = ('title', 'hmin', 'hmax', 'district')class EstatesView(RetrieveAPIView, ListAPIView): queryset = 'xxx' filter_backends = [DjangoFilterBackend, OrderingFilter] filterset_class = HouseInfoFilter 定义过滤器类，method()指定复杂的过滤方法，field_name指定模型字段名，lookup_expr指定过滤规则，filterset_class指定过滤器类 认证JWT与令牌我们知道目前使用的CS结构是基于HTTP协议的，而HTTP协议是一个无状态的协议，也就是说在两次请求之间不能保存任何会话状态，也就不能跟踪用户。但是我们有必须保存用户状态，目前有三种方式可选： URL重写，就是访问服务端时通过修改URL，加入参数以达到保存用户状态的作用，典型的就是百度搜索关键词进行URL重写 隐式表单域，即埋点，就是在表单标签中加入类型为hidden的标签，以达到故武器进行识别，典型的就是django中CSRF（跨站请求伪造问题） 本地存储，通过cookie、localStorage或sessionStorage进行存储服务器上表示用户身份的信息 然后我们本地存储开始谈，它主要包含三种思路： 第一种使用cookie+session的方式，用户向服务器发出请求（登陆），服务器会为改用户创建一个session对象保存用户状态，同时将sessionid作为cookie的一个字段的值保存在浏览器上，下一次就可以通过session的方式进行身份认证；（问题：扩展性不好，在服务器集群情况下，需要做session数据共享；同时内存消耗也大） 第二种使用session持久化，基于上面的方案，当时是将session数据保存到数据库中，而不是在内存中（问题：数据库出错，直接就验证不了用户会崩溃） 第三种直接不使用session，通过JWT（JSON Web Token）的方式，将代表用户身份的标识（token）传到浏览器上保存下来，下次访问时带上token一起访问（问题：用户验证信息保存在浏览器中，一旦指定有效时长，服务器端不能修改） 目前来看使用JWT是最有利用服务器的方式，python实现它的方式是三方库PyJWT，JWT能够通过签名和加密，有效的防止数据被篡改；同时，也可以指定有效时长，使token失效。 身份令牌有了，就可以通过认证和JWT结合使用，为用户生成身份令牌，认证类再进行识别令牌达到认证的目的 自定义认证类12345678910111213class CustomAuthentication(BaseAuthentication): def authenticate(self, request): token = request.META.get('HTTP_TOKEN', None) if token: try: payload = jwt.decode(token, SECRET_KEY, algorithms='HS256') user = User() user.id = payload['data']['userid'] return user, token except: raise AuthenticationFailed() raise AuthenticationFailed() 官方文档 授权限流Django-Debug-Toolbar用于Django调试的工具栏, 提供了查看SQL执行记录 / 查看缓存记录 / 查看执行时间 / 查看日志 / 查看模板 / 查看使用静态文件记录等功能, 非常强大。 安装1pip install django-debug-toolbar 配置系统配置 123INSTALLED_APPS = [ 'debug_toolbar', ] 12345DEBUG_TOOLBAR_CONFIG = &#123; 'JQUERY_URL': 'https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js', 'SHOW_COLLAPSED': True, 'SHOW_TOOLBAR_CALLBACK': lambda x: True,&#125; 123MIDDLEWARE = [ 'debug_toolbar.middleware.DebugToolbarMiddleware', ] 路由 1234from django.conf import settingsif settings.DEBUG: import debug_toolbar urlpatterns.insert(0, path("__debug__/", include(debug_toolbar.urls))) 运行 图形验证码]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>inspectdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker简单上手]]></title>
    <url>%2F2019%2F01%2F11%2Fdocker%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[介绍Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。（相当于虚拟机） Docker属于对Linux容器技术的一种封装，它提供了简单易用的容器使用接口，是目前最流行的 Linux 容器解决方案。Docker将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker就再也不用担心环境问题了 Docker中文社区 Docker官网 安装以Cent OS系统为例, Ubuntu和Mac OS可以点这里 首先要确认Linux系统是64位的, 目前还不支持32位的系统；Cent OS 7确保内核版本3.10+, CentOS确保内核版本2.6+ 1uname -r 安装 使用包管理工具yum 1yum -y install docker-io 开启/关闭docker服务 12systemctl start dockersystemctl stop docker 查看Docker版本 12docker --versiondocker version 查看帮助 123docker --helpdocker pull --help总是可以在任何时候使用--help 下载镜像文件可以使用docker search 检索镜像文件 123docker pull xxx如:docker pull redis 对于部分文件可能下载下载非常慢，可以配置镜像curl -sSL http://oyh1cogl9.bkt.clouddn.com/setmirror.sh | sh -s &lt;镜像加速地址&gt; 镜像加速地址 123&quot;https://reg-mirror.qiniu.com&quot;&quot;http://hub-mirror.c.163.com&quot;,&quot;https://registry.docker-cn.com&quot; 也可以直接到/etc/docker/daemon.json写入配值 123456&#123; &quot;registry-mirrors&quot;: [ &quot;http://hub-mirror.c.163.com&quot;, &quot;https://registry.docker-cn.com&quot; ]&#125; 查看镜像文件 1docker images 查看已运行的容器 1docker ps 查看所有的容器 1docker container ls -a 删除容器 123docker rm &lt;container-name&gt;docker rm -f &lt;container-name&gt; -- 强删（删除正在运行中的容器）docker rmi &lt;container-name&gt; 删除容器的镜像文件 删除所有容器 1docker container prune 停止容器 12docker stop &lt;container-name&gt;docker stop &lt;container-id&gt; 强行停止 1docker container kill &lt;container-id&gt; 使用安装MySQL下载镜像文件 12docker pull mysql:5.7# 若不输入版本, 默认下最新版本latest 创建容器 12345docker run -d -p 3306:3306 --name mysql57 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 # -d表示容器后台运行 -p为宿主机对容器的端口# --name指定容器名（用于后续访问）# -e指定mysql的root用户# 最后是镜像文件名 使用docker run命令，如果没有镜像文件，会直接下载再进行搭建服务 数据卷映射 将数据映射到指定的文件夹中 实际开发中或应用中, 我们可以随时删除一个容器, 但是应该将数据库类的容器中数据保存起来 1234567891011121314docker run -d -p 3306:3306 -v /root/mysql/conf:/etc/mysql/mysql.conf.d -v /root/mysql/data:/var/lib/mysql --name mysql57 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7# -v 是将docker指定的文件夹映射到本地文件夹# 配置mysqld.cnf文件[mysqld]pid-file=/var/run/mysqld/mysqld.pidsocket=/var/run/mysqld/mysqld.sockdatadir=/var/lib/mysqllog-error=/var/log/mysql/error.logserver-id=1log-bin=/var/log/mysql/mysql-bin.logexpire_logs_days=30max_binlog_size=256Msymbolic-links=0 进入容器 当我们创建好容器，此时若想连接数据库，首先需要先进入容器 12# mysql57是mysql对应的容器名docker exec -it mysql57 /bin/bash 然后通过mysql -uroot -p的命令连接容器中的数据库 白名单 在大量同一公网IP用户访问阿里云服务会导致阿里云判断服务器异常，会隔断所有部署在上面服务，通过个人头像 -&gt; 安全管控 -&gt;IP白名单 -&gt;添加，添加的IP来源为公网IP 安装Redis下载镜像文件 1docker pull redis 创建容器 1234docker run -d -p 6379:6379 --name redis-master redis:latest redis-server [--requirepass 123456][--port 6379]# --requirepass 指定redis密码# --port修改容器的端口, 后面修改后, -p 参数也要改变 奴隶容器 12345678910111213docker run -d -p 6380:6379 --name redis-slave-1 --link redis-master:redis-master redis:latest redis-server --replicaof redis-master 6379[--slaveof redis-master 6379 --masterauth 123456] # 奴隶是不需要给端口, 主人会将自己传给奴隶# --link 容器的ip地址可能因为容器重启发生变化导致无法连接主机，因此给主人容器取别名,而不是ip地址(取别名取相同值) # redis:latest 指定镜像名, 最新的redis镜像# --slaveof 指定主人容器名 端口号# --replicaof 指定使用别名而不是地址# --masterauth 指定主人容器redis的密码# redis-server 指定服务器的命令docker run -d --name redis-slave-1 redis:lastest redis-server --slaveof 127.17.0.2 6379# /etc/hosts 当前主机上的网络地址 使用 当redis服务配置完成后，可以根据其对外暴露的端口进行访问 1redis-cli -p 6380 进入容器 123456# 以命令终端的形式进入redis-master容器docker exec -it redis-master /bin/bash# 进入客户端redis-cli# 查看奴隶info replication 安装GitLab由于GitLab会使用SSH协议，即使用22端口，因此如果使用阿里云(连接服务器需要22端口)，就 需要修改端口，进入文件 1vim /etc/ssh/sshd_config 修改 12#Port 22Port 220 重启sshd服务 1systemctl restart sshd 基于gitlab/gitlab-ce 创建镜像容器，并暴露22和80端口 1docker run -d -p 80:80 -p 22:22 --name gitlab -v /root/gitlab/config:/etc/gitlab -v /root/gitlab/logs:/var/log/gitlab -v /root/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce gitlab/gitlab-ce是镜像文件名 可以使用docker pull gitlab/git/gitlab-ce进行下载 构建镜像commit方式假设现有使用Docker配置好一个服务，以MySQL为例 1234docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES87a1144796bb mysql:5.7 "docker-entrypoint..." 2 hours ago Up 2 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql57 使用docker commit指定容器id来构建镜像 1docker commit 87a1144796bb rzlong/rz_mysql 查看这个镜像文件 1234docker imagesREPOSITORY TAG IMAGE ID CREATED SIZErzlong/rz_mysql latest 4fb387f72318 9 minutes ago 372 MB build+Dockerfile 在一个空文件夹下创建一个Dockerfile文件 12touch Dockerfilevim Dockerfile 编辑文件 123456# version: 0.0.1FROM ubuntu:14.04MAINTAINER rzlong "rzlongs@126.com"RUN apt-get update &amp;&amp; apt-get install -y nginxRUN echo 'hello, world!' &gt; /usr/share/nginx/html/index.htmlEXPOSE 80 对于编辑好的Dockerfile文件，使用build 1234567docker build -t=&quot;rzlong/rz_server:0.1&quot; .# . 表示当前文件夹下的文件# -t 后面接镜像名和版本(注意后面一个小数点，表示当前文件夹下)docker build -t=&quot;rzlong/rz_server:0.1&quot; -f /root/Dockerfile# -f 指定Dockerfile文件路径 ？？]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础算法]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法递归程序调用自身的编程技巧称为递归（ recursion）。 阶乘 123456def factorial(num): """阶乘""" assert num &gt;= 0 if num in (0, 1): return 1 return num * factorial(num - 1) 贪心法贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 小偷问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Goods(): """物品类""" def __init__(self, name, price, weight): """初始化""" self.name = name self.price = price self.weight = weight @property def values(self): """返回物品价格重量比""" return self.price / self.weightdef thing(): """输入物品信息""" inputs = input().split() return inputs[0], int(inputs[1]), int(inputs[2])def main(): """主函数""" total_weight, total_nums = map(int, input().split()) goods_list = [] for _ in range(total_nums): # 解包语法(对thing方法返回的元组进行解包操作) goods_list.append(Goods(*thing())) goods_list.sort(key=lambda x: x.values, reverse=True) final_weight, final_price = 0, 0 for goods in goods_list: if goods.weight + final_weight &lt;= total_weight: final_weight += goods.weight final_price += goods.price print(f'小偷拿了&#123;goods.name&#125;') print(f'小偷偷取的物品总价为&#123;final_price&#125;') """20 6电脑 200 20收⾳机 20 4钟 175 10花瓶 50 2书 10 1油画 90 9""" 动态规划多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划 在编程中, 我们通常使用空间换时间的方式是是实现”动态规划” 斐波那契数列 12345678910def fib(num, results=&#123;&#125;): """递归-斐波那契数列""" assert num &gt; 0 if num in (1, 2): return 1 try: return results[num] except KeyError: results[num] = fib(num - 1) + fib(num - 2) return results[num] 通过牺牲空间换取时间的方式，将每次得到的值存到字典中, 需要计算的时候直接去取值，代替每次都去计算, 这种方式能够极大地缩短程序运行时间, 对代码的性能提高很大。 分治分而治之，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 分割：递归地把当前序列平均分割成两半 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并） 归并排序 将两个已经排序的序列合并成一个序列的操作，依赖于归并操作 12345678910111213141516171819202122232425def merge(left, right, cmp=lambda x, y: x &lt;= y):"""归并操作""" result = [] while left and right: if left[0] &lt;= right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) result.extend(left) result.extend(right) return result def merge_sort(items, cmp=lambda x, y: x &lt;= y):"""归并排序""" if len(items) &lt;= 1: return items[:] mid = len(items) &gt;&gt; 1 left = items[:mid] right = items[mid:] left = merge_sort(left, cmp) right = merge_sort(right, cmp) return merge(left, right, cmp) b = [7, 4, 5, 2, 6, 9, 1]print(merge_sort(b)) # [1, 2, 4, 5, 6, 7, 9] 快速排序 回溯回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 骑士巡游问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# import os# import time# import sysSIZE = 5TOTAL = 0def print_loc(board): """打印每一步的数字""" # 清屏, 有的是os.system('clear') # os.system('cls') for raw in board: for col in raw: print(str(col).center(4), end=' ') print()def move(board, raw, col, step=1): """移动""" if raw &gt;= 0 and raw &lt; SIZE and \ col &gt;= 0 and col &lt; SIZE and \ board[raw][col] == 0: board[raw][col] = step # 单步骤打印 # time.sleep(1) # print_loc(board) if board[raw][col] == SIZE * SIZE: global TOTAL TOTAL += 1 print(f'第&#123;TOTAL&#125;个') print_loc(board) move(board, raw + 2, col + 1, step + 1) move(board, raw + 1, col + 2, step + 1) move(board, raw - 1, col + 2, step + 1) move(board, raw - 2, col + 1, step + 1) move(board, raw - 2, col - 1, step + 1) move(board, raw - 1, col - 2, step + 1) move(board, raw + 1, col - 2, step + 1) move(board, raw + 2, col - 1, step + 1) board[raw][col] = 0def main(): """主函数""" board = [[0] * SIZE for _ in range(SIZE)] move(board, SIZE - 1, SIZE - 1) 深度优先算法… Python中list、dict、set的大规模查找辨析列表数据类型其底层实现是基于顺序表实现的，其查找效率为O(n),因此在面对大数量级查找时就相当笨拙。 集合类型是会做出去重操作(其底层实现是通过__hash__和__eq__去判断是否去重)，再根据哈希表进行查找，其查找效率理想化是O(1) 字典类型会对键进行hash运算，与集合一样也是基于哈希表，但它只对键的引用进行而没有值得引用。查找效率理想上是O(1)，这在理想化的没有冲突的哈希表中才成立(一一对应的映射关系)，但是实际上值是会存在重复，也就是多对一的关系，在数据结构这被称为哈希冲突或哈希碰撞，因此其查找效率是在O(1)~O(n)之间。并且因为字典类型需要对键进行hash运算，因此它叫set类型要稍慢一些。 总结下来，对于大数量级的查找：set &gt; dict &gt; list 代码测试: 12345678910111213141516171819202122232425262728293031323334def differ(): d_list = [] d_set = set() d_dict = dict() data = randint(0, 10000000, 100000) for d in data: d_list.append(d) d_set.add(d) d_dict.setdefault(d, 1) start = time.clock() for item in range(100): status = item in d_list end = time.clock() t1 = end - start start = time.clock() for item in range(100000): status = item in d_set end = time.clock() t2 = end - start start = time.clock() for item in range(100000): status = item in d_dict end = time.clock() t3 = end - start return t1,t2,t3print(differ())#(1.8686458943706916, 0.00849873291109482, 0.010258474940004536)# 在list只判断100个数据时其查找时间就远大于字典和集合的100000量级 在线排序算法动态展示动态展示]]></content>
      <categories>
        <category>Python</category>
        <category>算法问题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序和查找]]></title>
    <url>%2F2019%2F01%2F06%2F%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[算法评定评价一个算法的好坏, 通常是由空间复杂度和时间复杂度决定的。 而现实中很难做到时间复杂度time complexity和空间复杂度space complexity都很低, 一种被认可的的做法就是牺牲空间换取时间。 常见时间复杂度 表示方法 解释 算法 O(c) 常量级 哈希存储/bloom过滤器 O(log2n) 对数级 二分查找 O(n) 线性级 顺序查找 O(nlog2n) 线性对数级 归并排序/快速排序 O(n^2) 平方级 冒泡排序/选择排序 O(n^3) 立方级 Floyd算法 O(2^n) 指数级 汉诺塔问题 O(n!) 阶乘级 旅行经销商问题 查找顺序查找说明 顺序查找是按照序列原有顺序对数组进行遍历比较查询的基本查找算法。 时间复杂度 O(n), 即线性时间复杂度 代码实现 123456def seq_search(items, elem): """顺序查找""" for index, item in enumerate(items): if item == elem: return index return -1 二分查找说明 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 时间复杂度 O(log2n), 即对数时间复杂度 代码实现 123456789101112def bin_search(items, elem): """二分查找""" start, end = 0, len(items) - 1 while start &lt;= end: mid = (start + end) // 2 if elem &gt; items[mid]: start = mid + 1 elif elem &lt; items[mid]: end = mid - 1 else: return mid return -1 排序快速排序说明 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 图解 时间复杂度 O(nlog2n), 即线性对数时间复杂度 代码实现 12345678910111213def sort_arr(arr): """快速排序""" _less = [] _greater = [] if len(arr) &lt;= 1: return arr _pivot = arr.pop() for _item in arr: if _item &lt;= _pivot: _less.append(_item) else: _greater.append(_item) return sort_arr(_less) + [_pivot] + sort_arr(_greater) 归并排序说明 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 图解 时间复杂度 O(nlog2n), 即线性对数时间复杂度 代码实现 123456789101112131415161718192021222324def merge_sort(items, cmp=lambda x, y: x &gt; y): """归并排序""" if len(items) &lt; 2: return items[:] mid = len(items) // 2 left = merge_sort(items[:mid], cmp) right = merge_sort(items[mid:], cmp) return merge(left, right, cmp)def merge(items1, items2, cmp=lambda x, y: x &gt; y): """将两个有序列表组成一个新的有序列表""" items = [] index1, index2 = 0, 0 while index1 &lt; len(items1) and index2 &lt; len(items2): if cmp(items1[index1], items2[index2]): items.append(items2[index2]) index2 += 1 else: items.append(items1[index1]) index1 += 1 items += items1[index1:] items += items2[index2:] return items 冒泡排序说明 冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。 图解 时间复杂度 O(n^2), 即平方时间复杂度 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def bubble_sort(origin_items): """判断特殊情况(差一个数就有序呢)""" items = origin_items[:] for i in range(1, len(items)): swapped = False for j in range(0, len(items) - i): if items[j] &gt; items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j] swapped = True if not swapped: break return itemsfrom operator import gtdef bubble_sort(origin_items, *, cmp=gt): """可以比较类对象 *之后是命名关键字参数，之前是位置参数""" items = origin_items[:] items_len = len(items) for i in range(1, items_len): swapped = False for j in range(0, items_len - i): if cmp(items[j], items[j + 1]): items[j], items[j + 1] = items[j + 1], items[j] swapped = True if not swapped: break return items def bubble_sort(origin_items, *, cmp=lambda x, y: x &gt; y): """加上搅拌排序， 正向再反向""" items = origin_items[:] for i in range(1, len(items)): swapped = False for j in range(i - 1, len(items) - i): if cmp(items[j], items[j + 1]): items[j + 1], items[j] = items[j], items[j + 1] swapped = True if swapped: swapped = False for j in range(len(items)- i - 1, i - 1, -1): if cmp(items[j - 1], items[j]): items[j], items[j - 1] = items[j - 1], items[j] swapped = True if not swapped: break return items"""注:1. 初始冒泡程序2. 对其进行开头检测, 若遇到已经排好序的情况break3. 对其进行末尾检测, 若遇到已经排好序的情况break4. 解耦合， 通过函数对数据进行比较, 默认用lambda x,y: x&gt;y(对类的实例的进行比较可以使用__gt__)5. *符号其分界作用, 它之后为命名关键字参数, 前面为位置参数""" 选择排序说明 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 图解 时间复杂度 O(n^2), 即平方时间复杂度 代码实现 12345678def select_sort(origin_items, cmp=lambda x, y: x &gt; y): """选择排序""" items = origin_items[:] for i in range(len(items)): for j in range(i, len(items)): if items[i] &gt; items[j]: items[i], items[j] = items[j], items[i] return items]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>排序查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码检测]]></title>
    <url>%2F2019%2F01%2F06%2F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[代码检查工具pep8/pycodestylepep8 安装: pip3 install pep8 使用: pep8 &lt;file name or directory name&gt; 12345678910111213141516(practice) D:\pycharm\pythoncode\practice\whiteboard&gt;pep8 practice01.pyd:\pycharm\venv\practice\lib\site-packages\pep8.py:2124: UserWarning:pep8 has been renamed to pycodestyle (GitHub issue #466)Use of the pep8 tool will be removed in a future release.Please install and use `pycodestyle` instead.$ pip install pycodestyle$ pycodestyle ... &apos;\n\n&apos;practice01.py:16:1: E302 expected 2 blank lines, found 0practice01.py:49:1: E302 expected 2 blank lines, found 1practice01.py:53:80: E501 line too long (94 &gt; 79 characters)practice01.py:64:16: W291 trailing whitespacepractice01.py:94:1: W391 blank line at end of file 他告诉我们pep8工具在未来将会被移除, 并且使用pycodestyle来代替 pycodestyle 安装: pip3 install pycodestyle 使用: pycodestyle &lt;file name or directory name&gt; pycodestyle的使用非常灵活, 他有很多参数, 我们可以自己去选择或者配置, 他的文档在这里。可以在pypi.org上面去查看这个第三方库。下面将几种可能使用的参数 --statistics -qq对结果进行汇总 1python test01.py --statistics -qq --show-source 查看更详细的输出, 它会具体告诉是哪个文件的具体位置 1python test01.py --show-source --ignore 忽略指定的输出 1python test01.py --ignore=E302,E501 ​ pyflakesPyflakes做出了一个简单的承诺：它永远不会抱怨风格，它会非常非常努力地永远不会发出误报。 Pyflakes也快于pylint的 或Pychecker。这主要是因为Pyflakes只分别检查每个文件的语法树。因此，Pyflakes在它可以检查的事物类型方面受到更多限制。 如果你喜欢Pyflakes但也想要风格检查，你需要 flake8，它将Pyflakes与PEP 8样式检查相结合， 并增加了每个项目的配置能力。 安装 pip3 install pyflakes 使用 pyflasks &lt;file name or directory name&gt; 123举例:(practice) D:\pycharm\pythoncode\practice\whiteboard&gt;pyflakes practice02.pypractice02.py:15: &apos;line_profiler&apos; imported but unused flake8flake8结合了pep8和pyflakes的特点, 并添加了新的特点。因此我们可以使用flake8完全代替pep8和pyflakes。 安装 pip3 install flake8 使用 flake8 &lt;file name or directory name&gt; pylintPylint是一个Python静态代码分析工具，它可以查找编程错误，帮助强制执行编码标准，嗅探代码异味并提供简单的重构建议。 它具有高度可配置性，具有特殊的编译指示来控制代码中的错误和警告，以及广泛的配置文件。也可以编写自己的插件来添加自己的检查或以某种方式扩展pylint。 它是根据GNU通用公共许可证分发的免费软件。 pylint的实用性很高, 对有代码洁癖的人很友好, 但是它可能也会产生一些误判风格问题。它会对代码进行打分, 如果你的代码产生了负分, 可能你不得不想办法改正这些问题, 否则, 它不在优雅。 pylint 和 flake8都是值得推荐的静态代码检测工具 安装 pip3 install pylint 使用 pylint &lt;file name or directory&gt;, pylint相当严格, 检测文件夹时,产生很多问题不益于查看. 例子 123456(practice) D:\pycharm\pythoncode\practice\whiteboard&gt;pylint example09.py************* Module example09example09.py:28:0: R0903: Too few public methods (1/2) (too-few-public-methods)------------------------------------------------------------------Your code has been rated at 9.62/10 (previous run: 9.23/10, +0.38) 代码执行效率检测line_profiler和kernprofmemory_profilercprofiler]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postgresql]]></title>
    <url>%2F2019%2F01%2F02%2Fpostgresql%2F</url>
    <content type="text"><![CDATA[ubuntu安装sudo apt-get install postgresql 安装成功后, 默认会创建: 创建名为postgres的linux用户 创建名为postgres 不带月密码的默认数据库账号作为数据库管理员 创建名为postgres的表 有关postgresql的默认信息如下: 12345config /etc/postgresql/9.5/main data /var/lib/postgresql/9.5/main locale en_US.UTF-8 --&gt; 我们是zh_CN.UTF-8socket /var/run/postgresql port 5432 psql命令 进入postgres的身份访问PostgreSQL的客户端psql(此时系统用户名,数据库用户名,数据名均为postgres) sudo -u postgres psql 修改密码 \password 查看sql命令的解释 \h delete 查看psql命令列表 \? 查看所有数据库 \l 连接其他数据库 \c [database_name] 查看当前数据库的所有表 \d 查看当前数据库指定的表 \d [table_name] 查看所有用户 \du 查看当前数据库和连接的信息 \conninfo 默认管理员postgres管理 修改密码 \passwordalter user postgres with password ‘xxx’; 创建新用户 create user [username] with password ‘password’; 对用户创建数据库 create database [database_name] owner [username]; 授权(新创建的数据库没有任何数据库操作权限) grant all privileges on database [database_name] to [username]; 在shell中创建普通用户/超级用户 sudo -u postgres createuser [username]sudo -u postgres createuser –superuser [username] 在shell中创建数据库并指定所有者 sudo -u postgres createdb -O [username][database_name] 连接数据库 psql -U [username] -d [database_name] -h 127.0.0.1 -p 5432 基本数据库操作命令大部分操作和mysql相同, 说一些不同的点: 自增字段直接使用serial(mysql中是integer auto_increment) 大小写相关 PostgreSQL中对表名,字段名均区分大小写，但是对SQL大小写不敏感。在不加引号的情况下, 创建时无论使用大/小写, 表中都会统一转换为小写, 查询时语句中字段名统一改称小写 , 在加双引号的情况下, 查询表名也必须是双引号表名 查询时, 会发生双引号被抹去或大写转小写中的一个, 优先去双引号]]></content>
      <categories>
        <category>Postgresql</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进阶]]></title>
    <url>%2F2019%2F01%2F02%2Fpython%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[魔法方法__init__ 和 __new__ __init__通常用于初始化一个新实例, 对这个实例添加一些属性, 做一些额外的工作, 属于对象方法 __new__通常用于控制生成一个新的实例, 属于类方法 __init__在实例生成后生效, __new__控制实例生成, 因此__init__在__new__后执行 __iter__和__next__通常要创建一个可迭代的对象(可迭代的类对象)，需要定义__iter__和__next__对象，iter获取迭代器，next获取迭代器对象中值，若对象中的元素为空时，引出StopIteration错误 12345678910111213141516171819202122232425class Counter: def __init__(self, num): self.num = num self.index = 0 def __iter__(self): return self def __next__(self): self.index += 1 while self.index &lt;= self.num: if is_prime(self.index): return self.index self.index += 1 raise StopIteration def is_prime(item): if item in (0, 1): return False for i in range(2, int(item ** 0.5) + 1): if item % i == 0: return False return Truecounter = Counter(50)print(list(counter))# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] __enter__和__exit__通常要创建一个上下文管理器对象，就需要定义__iter__和__exit__两个魔法方法，其中前者用于打开对象时执行的功能，后者用于关闭对象后执行的功能。 如果在执行 with 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 None。 12345678910111213141516171819202122import timeclass TimeThis: def __init__(self, label): self.label = label def __enter__(self): self.start = time.time() time.sleep(1) def __exit__(self, exc_type, exc_value, traceback): end = time.time() print(f'&#123;self.label&#125;waste time &#123;str(end-self.start)&#125;') return self.label with TimeThis('波斯猫') as tt: print('func()') '''func()波斯猫waste time 1.0010571479797363''' __hash__和__eq__对于两个类，是不能直接使用比较运算的；而为了达到这个目的，根据__hash__和__eq__两个魔法方法可以实现类对象之间的比较 集合类型和字典类型其底层实现原理就是根据__hash__和__eq__去判断元素是否相同或不同的元素 123456789101112131415161718class Person: def __init__(self, name, age): self.name = name self.age = age def __hash__(self, other): return hash((self.name, self.age)) == hash(other.name, other.age) def __eq__(self, other): return self.name == other.name and self.age == other.age p1 = Person('王安石', 40)p2 = Person('王安石', 40)p3 = Person('王维'， 50)p1 == p2, p1 == p1, p1 == p3# (True, True, False) __call__在Python中，函数是一等的对象，可以传递到函数和方法中。如果要使一个类的对象也表现跟函数一样的特点，可以使用__call__方法去实现 123456789101112131415class Entity: '''表示一个实体的类，调用它的实例可以更新实体的位置''' def __init__(self,size,x,y): self.x, self.y = x, y self.size = size def __call__(self,x,y): '''改变实体的位置''' self.x, self.y = x, yentity = Entity(20, 4, 5)print(entity.x, entity.y)entity(2, 10)print(entity.x, entity.y)# 4 5# 2 10 运算__eq__ __ne__ __lt __gt__ __le__ __ge__ 单例单例指的是对一个单一的类, 它负责创建自己的对象, 同时确保单个对象只有一个实例。 注意: 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有其他对象提供这个实例 单例的实现方式很多，但是使用类的装饰器和元类构建装饰器是最容易被使用的方式 装饰器实现12345678910111213141516171819202122232425262728from functools import wrapsdef singleton(cls): instances = &#123;&#125; @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper@singletonclass TestSingleton: def __init__(self, name): self.name = name def __str__(self): return self.name a = TestSingleton('实例a')b = TestSingleton('实例b')c = TestSingleton.__wrapped__('实例c')d = TestSingleton.__wrapped__('实例d')print(a,b,c,d) # 实例a 实例a 实例c 实例d 以上的内容只能保证在单线程下的正确性，但是在多线程环境下，线程之间可能重复执行导致丢失更新，需要给数据加锁 12345678910111213141516from functools import wrapsfrom threading import RLockdef singleton(cls): instances = &#123;&#125; lock = RLock() #重入锁，可再次取到锁对象(普通锁是Lock) @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: # 先判断有没有实例，若有直接返回 with lock: # 加锁，保证多线程环境 if cls not in instances: # 加锁判断实例 instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper 元类对象是类的实例，而类就是元类的实例 自定义元类继承于type，要重写__new__/__init__,__call__等魔术方法 其中 __call__相当于元类造出类的构造器 Python 3中使用元类可以在定义类时通过(metaclass=元类)来使用 Python 2中可以在类中添加__metaclass__魔法属性 123456789101112131415161718192021222324class SingletonMeta(type): """自定义元类,继承于type""" def __init__(cls, *args, **kwargs): super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if not hasattr(cls, 'instance'): cls.instance = super().__call__(*args, **kwargs) return cls.instanceclass Person(metaclass=SingletonMeta): # __metaclass__=SingletonMeta #python2的做法现在也支持 def __init__(self, name): self.name = name def __str__(self): return self.namedef main(): p1 = Person('dawda') p2 = Person('apple') print(p1.name) print(p2) 也可以直接写在__new__魔术方法中实现单例 12345class Singleton(object): def __new__(cls): if not hasattr(cls, 'instance'): cls.instance = super(Singleton, cls).__new__(cls) return cls.instance 迭代器和生产器迭代器拥有__iter__和__next__两个魔方方法的对象(字符串、列表、元祖或类)，它就是一个迭代器 iter方法可以将一个对象变成迭代器对象 123456789# 使用hashlib模块检查文件的哈希摘要import hashlibhasher = hashlib.md5()with open(r'xadmin.zip', 'rb') as f: for data in iter(lambda: f.read(1024), b''): hasher.update(data)print(hasher.hexdigest()) 生成器在Python中，使用关键字的yield的函数就是一个生成器generator 生成器返回的就是一个迭代器对象，只能用于迭代操作；每次遇到yield函数（让步操作，让出CPU）时会暂停保存当前的所有运行信息和状态，并在下一次执行next方法会从上一次运行的位置继续执行 123456789def foo(num): a = 0 b = 1 for _ in range(num): a, b = b, a + b yield ab = foo(5)print(list(b)) 生成式案例: 将字典实现反转 1234567i_dict = &#123;1: 'a', 2: 'b', 3: 'c'&#125;# 用dict(列表生成式), 列表中是二位元素组成的元组im_dict = dict([(v, k) for k, v in i_dict.items()]) # &#123;'a': 1, 'b': 2, 'c': 3&#125;# 使用字典生成式im2_dict = &#123;v:k for k, v in i_dict.items()&#125; # &#123;'a': 1, 'b': 2, 'c': 3&#125;# 使用dict(zip)im3_dict = dict(zip(i_dict.values(), i_dict.keys())) # &#123;'a': 1, 'b': 2, 'c': 3&#125; 案例: 一行代码实现阶乘 12345678from functools import reducefrom operator import mul# 方法1 使用int.__mul__ 实现乘法fact = reduce(int.__mul__, range(1, 10)) # 实现9的阶乘# 方法2 使用operator.mul 实现乘法fact = reduce(mul, range(1, 10)) # 实现9的阶乘# 方法3 使用lambda函数, 不推荐使用fact = reduce(lambda x, y: x * y, range(1, 10)) # 实现9的阶乘 中间件旧写法 12345678910111213141516class XxxMiddleware(): def process_request(self, request): pass def process_view(self, request): pass def process_template_response(self, request, response): pass def process_response(self, request, response): pass def process_exception(self, request, exception): pass 新写法 123456789def xxx_middleware(get_response): def middleware(request, *args, **kwargs): resp = get_response(request, *args, **kwargs) return resp return wrapper 上下文语法上下文语法都需要提供__enter__和__exit__两个魔术方法 contextmanger上下文管理器12345678910111213141516171819from contextlib import contextmanagerfrom time import time# contextmanager 提供了__enter__方法@contextmanagerdef record_time(): start = time() yield 'yield 返回值' end = time() print(f'执行时间&#123;end - start&#125;') def foo(num): if num in (0, 1): return 1 return num * foo(num - 1)with record_time() as msg: print(msg) print(foo(100)) atomic事务上下文管理器Django提供的一种直接给函数 事务环境的方法 1234567891011from django.db.transaction import atomic# 使用withdef foo_view(request): with atomic(): pass# 使用装饰器@atomic()def foo2_view(request): pass 装饰器装饰器属于代理模式，实际上是给某个程序增加功能。而装饰器需要满足 不能修改被装饰函数的源代码 不能修改被装饰函数的调用方式 满足上述2个条件，给函数增加功能 不带参装饰器12345678910111213141516171819202122232425from functools import wrapsdef decorate(func): @wraps(func) def wrapper(*args, **kwargs): # 装饰代码 result = func(*args, **kwargs) # 装饰代码 if isinstance(result, str): result = result[::-1] return result return wrapper @decoratedef foo(): return 'hello wraps' print(foo(), foo.__name__)# wraps的作用# 1. 没有wraps时执行 foo.__name__ 会返回装饰器内返回的函数名(wrapper)# 2. __wrapped__ 魔法方法会执行被装饰的函数(无装饰器作用)print(foo.__wrapped__()) 带参装饰器12345678910111213141516171819202122232425262728293031from functools import wrapsfrom time import time, sleepdef record_time(output): def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) end = time() output(func.__name__, end - start) return result return decorate return decoratedef output_file(name, duration): with open(r'abc.txt', 'a') as f: f.write(f'&#123;name&#125;执行时间是&#123;duration&#125;')@record_time(output_file)def foo(): sleep(2) return 'hello foo'if __name__ == '__main__': a = foo() print(a) python高阶函数filter过滤使用方法: filter(function, iterable)对可迭代对象, 根据function函数进行过滤(对序列中的每个元素过滤)同时, python2.x中filter返回的是一个列表, python3返回的是一个迭代器对象 1234567def is_odd(n): return n % 2newlist = filter(is_odd, range(1,10))t_list = [i for i in newlist]print(t_list)# 输出: [1,3,5,7,9] map映射使用方法: map(function, iterable) 对可迭代对象, 根据function函数进行转换(function函数作用于序列中的每一个元素), 返回一个迭代器对象 123456&gt;&gt;&gt; def f(x):... return x*x... &gt;&gt;&gt; r = map(f,[1,2,3])&gt;&gt;&gt; list(r)[1, 4, 9] sorted排序内置排序函数, 对所有可迭代对象生效使用方法: sorted(iterable[, cmp[, key[], reverse]]) cmp 比较的函数, 它具有两个参数, 参数的值从可迭代的对象取出(遵守的规则为大于返回1, 小于返回-1，等于返回0) –&gt; python3.x中已取消这个参数 key 比较的函数, 具有一个参数, 参数的值从可迭代的对象中取出 reverse 排序规则， 默认为升序False, 为True降序 functools模块reduce化简使用方法：reduce(function, iterable[, initializer]) 对可迭代对象使用, 根据function函数进行转换(function函数必须有两个参数, 并且对序列中两两之间作累积运算), 返回一个元素(值);最后一个参数是初始值参数, 可选。 例如: reduce(f, [a, b, c, d]) = f(f(f(a,b),c),d) 1234567&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def f2(x, y):... return x*10 + y... &gt;&gt;&gt; r2 = reduce(f2, [1, 2, 3, 4])&gt;&gt;&gt; r21234 实现将str转换成int 1234567891011&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def f1(x, y):... return x*10 + y... &gt;&gt;&gt; def char2int(key):... num_dict = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;... return num_dict[key]... &gt;&gt;&gt; result = reduce(f1, map(char2int, '12345'))&gt;&gt;&gt; result12345 wrapswraps可以方便的使用函数装饰器的功能，它能够自动的设定选择是否选用装饰器12345678910111213141516171819202122&gt;&gt;&gt; from functools import wraps&gt;&gt;&gt; def my_decorator(f):... @wraps(f)... def wrapper(*args, **kwds):... print('Calling decorated function')... return f(*args, **kwds)... return wrapper...&gt;&gt;&gt; @my_decorator... def example():... """Docstring"""... print('Called example function')...&gt;&gt;&gt; example()Calling decorated functionCalled example function&gt;&gt;&gt; example.__wrapped__()Called example function&gt;&gt;&gt; example.__name__'example'&gt;&gt;&gt; example.__doc__'Docstring' 没有wraps时执行 foo.__name__会返回装饰器内函数的名字(wrapper)，有wraps时，其返回被装饰函数的名字(exmaple) __wrapped__ 魔法方法会执行被装饰的函数(无装饰器作用) partial偏函数，先看核心源码 123456789def partial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*args, *fargs, **newkeywords) newfunc.func = func newfunc.args = args newfunc.keywords = keywords return newfunc 其结构类似于装饰器，但是其改变被装饰函数的结构，因此又不能成为装饰器。 看上面代码，partial函数将自己的关键字参数**kwargs更新到被装饰函数中，将自己的位置参数*args放到被装饰函数的位置参数前，然后再执行被装饰函数，再举个例子 1234567891011from functools import partialdef adds(x, *args): print(x, *args) return x + sum(args) p = partial(adds, 4,5,6)p(1,2,3) #output（partial的位置参数放在被装饰函数的位置参数前，再执行使用被装饰函数）4 5 6 1 2 321 lru_cache最近最久未使用 itertools模块groupby数据分组用法: groupby(iterable, key=function) groupby()函数扫描整个序列并且查找连续相同值，并根据key函数返回值相同的元素序列。在每次迭代的时候，它会返回一个值和一个迭代器对象，这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。 必须注意的是，这个待操作数据是预先已排好序的。因为groupby仅仅检查连续的元素，它不会做排序操作。如果没有预先排序，得到的结果就不是预期的结果。 一个比较好的操作就是将数据分组和defaultdict(构建多值字典)结合使用 。 12345678910111213141516from itertools import groupbytest5 = [ &#123;'classroom': '1401', 'name': 'joy', 'age': 11&#125;, &#123;'classroom': '1402', 'name': 'chrome', 'age': 12&#125;, &#123;'classroom': '1403', 'name': 'scape', 'age': 20&#125;, &#123;'classroom': '1403', 'name': 'safril', 'age': 15&#125;, &#123;'classroom': '1401', 'name': 'ie', 'age': 12&#125;, &#123;'classroom': '1403', 'name': 'abc', 'age': 14&#125;]test5_sort = sorted(test5, key=itemgetter('classroom', 'age'))e = defaultdict(list)for classroom, items in groupby(test5_sort, key=itemgetter('classroom')): for item in items: e[classroom].append(item)print(e)# defaultdict(&lt;class 'list'&gt;, &#123;'1401': [&#123;'classroom': '1401', 'name': 'joy', 'age': 11&#125;, &#123;'classroom': '1401', 'name': 'ie', 'age': 12&#125;], '1402': [&#123;'classroom': '1402', 'name': 'chrome', 'age': 12&#125;], '1403': [&#123;'classroom': '1403', 'name': 'abc', 'age': 14&#125;, &#123;'classroom': '1403', 'name': 'safril', 'age': 15&#125;, &#123;'classroom': '1403', 'name': 'scape', 'age': 20&#125;]&#125;) compress过滤它是将一个可迭代对象序列根据另一个由布尔类型元素组成的序列进行过滤，返回一个迭代器。 使用方法: compress(iterable, bool_seq) 1234test6 = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']from itertools import compresstest6_cp = compress(test6, [True, False, False, False, True, True])print(list(test6_cp)) # ['first', 'fifth', 'sixth'] permutations排列combinations组合product笛卡尔积collections模块deque双端队列deque, 即双端队列(double-ended queue), 它增加了从头部操作的popleft()和appendleft()，并且它同时也支持列表的一些方法(如append(),pop(),insert()等) deque给定一个maxlen参数，指定队列的最大长度。如果队列中的元素超过最大长度，就会去除旧元素。 与列表相比, 队列在两端插入或删除的时间复杂度都是O(1)，而在列表的开头插入或删除的时间复杂度是O(N)，在列表的结束插入append或删除pop的时间复杂度是O(1)，pop(index)是O(N) 12345678910from collections import dequeb = deque([1,2,3,4,5], maxlen=5)b.append(6)print(b) # deque([2, 3, 4, 5, 6], maxlen=5)b.popleft()print(b) # deque([3, 4, 5, 6], maxlen=5)b.appendleft(10)print(b) # deque([10, 3, 4, 5, 6], maxlen=5)b.pop()print(b) # deque([10, 3, 4, 5], maxlen=5) Counter计数器Counter, 作为计数器使用, 作用对象是可序列化的对象，它的底层是通过字典来实现的，因为也可以通过字典的方法增加计数器的值。 Counter对象之间能够使用数学运算 most_common(N)能返回前N个元素 123456789101112131415161718192021222324252627282930In [62]: from collections import CounterIn [63]: test1 = ['a', 1, 2, 'a', 10, 'b', 2]In [64]: test2 = ('x', 4, 'info', 4, 10)In [65]: counter1 = Counter(test1)In [66]: counter2 = Counter(test2)In [67]: counter1Out[67]: Counter(&#123;'a': 2, 1: 1, 2: 2, 10: 1, 'b': 1&#125;)In [68]: counter2Out[68]: Counter(&#123;'x': 1, 4: 2, 'info': 1, 10: 1&#125;)# 对相同键的元素进行加法操作In [69]: counter1 + counter2Out[69]: Counter(&#123;'a': 2, 1: 1, 2: 2, 10: 2, 'b': 1, 'x': 1, 4: 2, 'info': 1&#125;)# 减操作，不够减的情况删除键In [70]: counter1 - counter2Out[70]: Counter(&#123;'a': 2, 1: 1, 2: 2, 'b': 1&#125;)# 返回前两个统计数据In [71]: counter1.most_common(2)Out[71]: [('a', 2), (2, 2)]# 返回所有的统计数据In [72]: counter1.most_common()Out[72]: [('a', 2), (2, 2), (1, 1), (10, 1), ('b', 1)]# 在返回所有的情况进行切片操作In [73]: counter1.most_common()[:2]Out[73]: [('a', 2), (2, 2)] OrderedDict有序字典OrderedDict，作为有序字典使用, 在python2.x时期, 字典是无序的, 在python3.x后字典没有被定义成有序的, 但是对于同一个字典, 使用标识连接内部的数据, 因此读取时是按存储顺序取数据的 在序列化或编码后需保证字段的顺序的场合，它很有效。但是有序字典内部维护这一个根据键插入顺序排序的双向链表，对于已经存在键的重复赋值不会改变键的顺序。这种数据结构的大小是普通字典的两倍，如果要构建大量数据的数据结构，它可能不合适。 12345678&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = OrderedDict()&gt;&gt;&gt; d = OrderedDict([('name','lisa'),('age',11),('gender','female')])&gt;&gt;&gt; dOrderedDict([('name', 'lisa'), ('age', 11), ('gender', 'female')])&gt;&gt;&gt; d['face']='nice'&gt;&gt;&gt; dOrderedDict([('name', 'lisa'), ('age', 11), ('gender', 'female'), ('face', 'nice')]) defaultdict默认字典defaultdict, 作为默认字典使用，它能够在定义时给给定一个初始的类型， 这样就能够在输出定义没有的键值对时，初始化一个值。 使用方法: a = defaultdict(factory_function)， 其中参数是工厂函数,它通常用于int,str,list,tuple,dict等，更多工厂函数点击 123456&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; a = defaultdict(int)&gt;&gt;&gt; a['age']0&gt;&gt;&gt; adefaultdict(&lt;class 'int'&gt;, &#123;'age': 0&#125;) 它的另一个使用场合就是为字典的键映射多个值 123456789101112131415#普通实现也很容易pairs = [('a',1), ('a',2), ('b',1), ('c',2), ('b',2)]print(pairs)d = &#123;&#125;for key, value in pairs: if key not in d: d[key] = [] d[key].append(value)print(d) # &#123;'a': [1, 2], 'b': [1, 2], 'c': [2]&#125;# defaultdict实现from collections import defaultdicte = defaultdict(list)for key, value in pairs: e[key].append(value)print(e) # defaultdict(&lt;class 'list'&gt;, &#123;'a': [1, 2], 'b': [1, 2], 'c': [2]&#125;) namedtuple命名元组namedtuple函数通过一个普通的元组对象映射名称到元组中的每个元素。它返回一个Python标准元组类型子类的工厂方法。需要传入类型名和需要的字段(由[]括起来)，它返回一个能够初始化的类，并为定义的字段传递值。 namedtuple与普通元组是可交换的， 它支持所有的普通元组操作， 例如切片、解压。 命名元组主要用途之一就是将你从下标操作解脱出来，你可以像使用对象的属性一样使用命名元组，但是你仍然也能使用下标。 123456from collections import namedtupleSubscriber = namedtuple('Student', ['name', 'age'])sub = Subscriber('joy', 15)print(sub) # Student(name='joy', age=15)print(sub.name, sub[0]) # joy joyprint(sub.age, sub[1]) # 15 15 命名元组另一个主要用途就是作为字典的替代，因为字典存储需要更多的存储空间。但是注意， 不同于字典，一个命名元组时不可更改的。 123456789print(type(sub))sub.age = 20'''&lt;class '__main__.Student'&gt;Traceback (most recent call last): File "D:\pycharm\pythoncode\practice\whiteboard\python_cookbook.py", line 224, in &lt;module&gt; sub.age = 20AttributeError: can't set attribute''' 如果你非要改变命名元组， 你可以使用_replace()方法 12sub = sub._replace(age=21, name='new_name')print(sub) # Student(name='new_name', age=21) ChainMap 合并字典用法: ChainMap(dict, dict, …) chain意思是连锁，map意思是映射(在python中映射对应就是由键值对组成的字典类型)，ChainMap就是将两个或多个字典(并没有真正的合并)从逻辑组成一个新字典。 这个字典能够使用字典的大部分方法。 也有一些需注意的地方: 如果出现重复键，总是会返回第一次出现键位置的值；对这个新字典使用更新或删除操作，它总是影响列表中的第一个字典。 12345678910fromcollections import ChainMapa = &#123;'name': 'joy', 'age': 21&#125;b = &#123;'height': 180, 'hobby': ['sing', 'play games']&#125;d = &#123;'class': 'Student', 'location': 'Sichuan'&#125;c = ChainMap(a, b, d)print(c) # ChainMap(&#123;'name': 'joy', 'age': 21&#125;, &#123;'height': 180, 'hobby': ['sing', 'play games']&#125;, &#123;'class': 'Student', 'location': 'Sichuan'&#125;) print(c['name']) # joyprint(c['hobby']) # ['sing', 'play games']print(c['location']) # Sichuan 另外一种字典的合并方式就是使用update()方法 123e = dict(b)e.update(a)print(e) # &#123;'name': 'joy', 'height': 180, 'hobby': ['sing', 'play games'], 'age': 21&#125; heapq模块heapq堆队列heapq模块通过nsmallest和nlargest可以实现查找一个集合中最小或最大的N(小于集合元素数量)个元素，它的底层实现是将集合数据进行堆排序后放入到一个列表中(heapify方法)。 所谓堆排序，就是….。堆数据结构最重要的特征就是heap[0]永远是最小的元素，并且通过heappop()可以获取下一个最小的元素，时间复杂度是O(log2N)；heappush()方法 1234567891011121314&gt;&gt;&gt; import heapq&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]&gt;&gt;&gt; part = heapq.nlargest(3, nums)&gt;&gt;&gt; print(part)[42, 37, 23]&gt;&gt;&gt; heapq.heapify(nums)&gt;&gt;&gt; print(nums)[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]&gt;&gt;&gt; heapq.heappop(nums)-4&gt;&gt;&gt; heapq.heappop(nums)1&gt;&gt;&gt; print(nums)[2, 2, 8, 23, 7, 37, 18, 23, 42] 同时nlargest和nsmallest两个方法，都有key参数，可以自定义比较方式。 12345678910portfolio = [&#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125;,&#123;'name': 'AAPL', 'shares': 50, 'price': 543.22&#125;,&#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;,&#123;'name': 'HPQ', 'shares': 35, 'price': 31.75&#125;,&#123;'name': 'YHOO', 'shares': 45, 'price': 16.35&#125;,&#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125;]cheap = heapq.nlargest(3, portfolio, key=lambda x: x['shares'])print(cheap) # [&#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;, &#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125;, &#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125;] min和max sorted(seq)[:N]通过排序切片操作 operator模块基本上每个运算都可以使用其对应的魔术方法 比较运算cmp用于python2.x中比较两个元素大小的函数, 在python3中已经被去掉了, 可以使用operator模块中的函数进行比较 123456operator.lt(a, b) operator.__lt__(a, b) operator.le(a, b) operator.__le__(a, b)operator.eq(a, b) operator.__eq__(a, b)operator.ne(a, b) operator.__ne__(a, b)operator.ge(a, b) operator.__ge__(a, b)operator.gt(a, b) operator.__gt__(a, b) 数学运算123456789abs(obj)add(a, b) 加 iadd(a,b) +=sub(a, b) 减 isub(a,b) -=mul(a,b) __mul__(a,b) 乘积 imul(a,b) *=truediv(a,b) __truediv__(a,b) 除 itruediv(a,b) /=floordiv(a, b) 整除 ifloordiv(a,b) //=mod(a, b) __mod__(a,b) 求模matmul(a,b) __matmul_(a,b) 矩阵乘积pow(a,b) __pow__(a,b) a的b次方 逻辑运算123456and_(a, b) __and__(a, b) 与运算 iand(a,b) a &amp;= b or_(a, b) __or__(a, b) 或运算 ior(a,b) a |= bxor(a, b) __xor__(a,b) 异或运算(上下相同取0，相异取1) ixor(a.b) a ^= binv(obj) invert(obj) __inv__(obj) __invert__(obj) 按位取反(一个有符号的二进制数的补码)lshift(a, b) __lshift__(a, b) a数左移b位 ilshift(a,b) a &lt;&lt;= brshift(a, b) __rshift__(a, b) a数右移b位 移位运算符 1234568 &gt;&gt; 1 48 &lt;&lt; 1 # 左移相当于 8 * (2 ** 1)168 &gt;&gt; 3 # 右移相当于 8 // 2**31 异或运算应用 12345678# 对于一个有奇数个N个整数组成的数组， 其中只有一个整数的数量为1个，其余全为2个或偶数个，找出这个整数# 用普通循环的方式肯定不可行，需要利用异或运算的性质# n ^ 0 = n n ^ n = 0items = [1, 2, 3, 5, 3, 2, 1]result = 0for item in items: result ^= itemprint(result) # 5 序列运算itemgetter基本数据排序itemgetter是一个函数，它作用于一个对象来获取指定位置的值 123a = [1,2,3,4]func = itemgetter(0,1,3)print(func(a)) # (1, 2, 4) 处理列表、元祖数据 1234567fruits = [('orange',20),('apple', 10), ('banana', 15), ('banana', 10)]fruit2 = sorted(fruits, key=itemgetter(0))fruit3 = sorted(fruits, key=itemgetter(1))fruit4 = sorted(fruits, key=itemgetter(0,1)) # 作用多个属性排序print(fruit2) # [('apple', 10), ('banana', 15), ('banana', 10), ('orange', 20)]print(fruit3) # [('apple', 10), ('banana', 10), ('banana', 15), ('orange', 20)]print(fruit3) # [('apple', 10), ('banana', 10), ('banana', 15), ('orange', 20)] 处理字典列表数据排序 123456789101112131415from operator import itemgettertest4 = [ &#123;'name': 'joy', 'age': 20, 'gender': 'male'&#125;, &#123;'name': 'haro', 'age': 20, 'gender': 'male'&#125;, &#123;'name': 'zqi', 'age': 24, 'gender': 'female'&#125;, &#123;'name': 'rocket', 'age': 21, 'gender': 'male'&#125;, ]# sorted方法不会改变被处理的序列stus = sorted(test4, key=itemgetter('age', 'name'))# sort方法会改变被处理的序列test4.sort(key=itemgetter('age', 'name'))print(stus)# [&#123;'name': 'haro', 'age': 20, 'gender': 'male'&#125;, &#123;'name': 'joy', 'age': 20, 'gender': 'male'&#125;, &#123;'name': 'rocket', 'age': 21, 'gender': 'male'&#125;, &#123;'name': 'zqi', 'age': 24, 'gender': 'female'&#125;]print(test4)# [&#123;'name': 'haro', 'age': 20, 'gender': 'male'&#125;, &#123;'name': 'joy', 'age': 20, 'gender': 'male'&#125;, &#123;'name': 'rocket', 'age': 21, 'gender': 'male'&#125;, &#123;'name': 'zqi', 'age': 24, 'gender': 'female'&#125;] 当然，我们使用匿名函数也能实现，但是itemgetter的性能要好些 1stus = sorted(test4, key=lambda item: (item['age'], item['name'])) 还有max和min函数也是支持key参数的， 因此他们也能使用上述的方法 12stus = max(test4, key=itergetter('age', 'name'))stus = min(test4, key=lambda item: (item['age'], item['name'])) attrgetter类的对象排序对类的实例化对象进行排序。 12345678910111213from operator import attrgetterclass User: def __init__(self, userid, name): self.userid = userid self.name = name def __repr__(self): return f'&lt;User &#123;self.userid&#125; &#123;self.name&#125;&gt;'users = [User(10, 'joy'), User(5, 'google'), User(12, 'april'), User(5, 'apple')]user_sort = sorted(users, key=attrgetter('userid', 'name'))# [&lt;User 5 apple&gt;, &lt;User 5 google&gt;, &lt;User 10 joy&gt;, &lt;User 12 april&gt;] 匿名函数也可以实现 1user_sort = sorted(users, key=lambda obj: (obj.userid, obj.name)) 除此, 不要忘记min/max两个函数也能使用上述的函数 python内置函数hasattrhasattr(object, name) 1234class test(): name='lip' def run(self): return 'runing' 判断一个对象里面是否有name属性或name方法, 返回bool 1234567&gt;&gt;&gt; a= test()&gt;&gt;&gt; hasattr(a, 'name')True&gt;&gt;&gt; hasattr(a, 'run')True&gt;&gt;&gt; hasattr(a, 'age')False getattrgetattr(object, name[, default]) 获取对象object的属性或者方法, 若存在, 就将值打印出来;若不存在, 就返回错误，也可以使用默认值 12345678910111213&gt;&gt;&gt; getattr(a, 'name')'lip'&gt;&gt;&gt; getattr(a, 'run')&lt;bound method test.run of &lt;__main__.test object at 0x7f5861d50828&gt;&gt;&gt;&gt;&gt; getattr(a, 'run')()'running'&gt;&gt;&gt; getattr(a, 'age')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'test' object has no attribute 'age'&gt;&gt;&gt; getattr(a, 'age', 10)10&gt;&gt;&gt; setattrsetattr(object, name[, default])** 给对象的属性赋值(若属性不存在, 它会先创建再赋值) 12345&gt;&gt;&gt; hasattr(a, 'hobby')False&gt;&gt;&gt; setattr(a, 'hobby', 'sing song')&gt;&gt;&gt; a.hobby'sing song' 综合使用: 1234&gt;&gt;&gt; getattr(a, 'status', setattr(a, 'status', 'well'))'well'&gt;&gt;&gt; a.status'well' zipzip函数用于将两个或多个可迭代对象进行整合(成元组形式的数据结构)，也可以用于二维数组到一维数组的转换。它的是实现是将同索引位置的元素进行最短序列长度的组合。更合适的使用方式是将两个等长序列组成字典的场景。 注意:zip()函数返回的是一个迭代器(迭代器都只能使用一次) 1234567891011121314151617181920212223242526&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [7,8,9]&gt;&gt;&gt; zip1 = zip(a,b,c)&gt;&gt;&gt; for i in zip1:... print(i)... (1, 4, 7)(2, 5, 8)(3, 6, 9)&gt;&gt;&gt; &gt;&gt;&gt; list(zip1)[(1,4,7),(2,5,8),(3,6,8)]# 注: 当上面使用for...in就使用完迭代器zip1, 此时不能再使用list(zip1)# 将两个序列组成字典&gt;&gt;&gt; keys = ['a', 'b', 'c']&gt;&gt;&gt; values = ['1', '2', '3']&gt;&gt;&gt; items = dict(zip(keys, values))&gt;&gt;&gt; items&#123;'a': '1', 'b': '2', 'c': '3'&#125;# 将两个序列组成列表&gt;&gt;&gt; items2 = list(zip(keys, values))&gt;&gt;&gt; items2[('a', '1'), ('b', '2'), ('c', '3')] all和anyall(iterable)/any(iterable)，前者对一个序列中的所有数据进行检测是否为真，全为真就返回True；后者检查序列中是否存在真，存在就返回True 12345678910import os# 取当前文件夹中所有文件files = os.listdir(os.path.dirname(__file__))print(files)if all(name.endswith('.py') for name in files): print('all file is python')elif any(name.endswith('.py') for name in files): print('exist file is python')else: print('no python') 上面隐藏一个知识点就是生成器表达式作为独立参数时，可以省略括号。而这个生成器也可以使用列表表达式替换。但是当数据量较大的时候，列表表达式因为会单独生成一个列表结构，浪费内存空间；而使用生成器表达式就不会有这样的问题。 12345# 生成器all(name.endswith('.py') for name in files)all((name.endswith('.py') for name in files))# 列表表达式all([name.endswith('.py') for name in files]) globals和localseval / exec / compile并发编程多进程多线程异步IOaiohttp asyncio await async 协程yield yield from 哈希对象和可变类型unhashable和hashablehashable即可哈希，unhashable即不可哈希 一个对象能被称为 hashable ， 它必须有个 hash 值，这个值在整个生命周期都不会变化，而且必须可以进行相等比较，所以一个对象可哈希，它必须实现__hash__() 与 __eq__() 方法. python的某些链接库在内部需要使用hash值，例如集合中添加对象需要使用__hash__()的方法获取哈希值，并比较它是否与集合中已有对象的hash值相同，若相同就比较__eq__()方法比较是否相等，以确定能否加入集合中 另外一种集合中添加数据必须是可哈希的对象，字典中添加键值对中的键也必须是可哈希的对象。 对于python的内建类型来说，建立之后的数据无法修改的类型immutable才能是hashable,如字符串，元组，数值型int、float和bytes，除此对于自定义的方法(函数)或者类也是可哈希的；可修改的数据mutable才能是不可哈希的unhashable: 列表、字典、集合，它们在改变值的时候没有改变id，无法由地址定位值的唯一性，因此是不可哈希的。 总结: 可修改的数据就是不可哈希的，不可修改的数据就是可哈希的(因为它们总能有由id定位值的唯一性) 集合中的元素必须是可哈希的， 但是集合本身却不可哈希 字典的键也必须是可哈希的 immutable和mutableimmutable即不可变， mutable即可变 python里面， 传递的都是对象的引用，也可以理解成地址。 可变类型就是对数据的修改是在原内存单元中进行。对于不可变类型，是不能修改值的，例如 12345678a = 1print(id(a))a = 2print(id(a))# 输出:20129925602012992576 当使用a=2时， 原数据1的引用就已经被销毁了，此时是将2的引用给了a 可变类型有: list, dict, set 不可变类型有: int, float, complex, str, tuple python规范 lambda使用与单行函数, 如果代码超过60-80个字符，还是定于常规函数；对于常见的操作符， 如乘法，应该使用operator.mul而不是lambda x, y: x * y 对于单行条件语句， 建议使用条件表达式，如x = 1 if item else -1 鼓励使用默认参数值， 但是不要在默认参数是可变对象时使用 鼓励使用if not user 或者 if user， 但是对于None和False的区分时, 可以使用if a is None 或者 if a is not None, 对于整数如0和False的区分，使用if a == 0 而不是if not a, 因为a可能取到空串, 空列表等出现误判]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Map/Reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy]]></title>
    <url>%2F2018%2F12%2F28%2Fnumpy%2F</url>
    <content type="text"><![CDATA[介绍numpy用于处理大数组的数据，并进行数值运算 numpy是在一个连续的内存块中存储数据，独立于其他python内置对象。numpy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起python的内置序列，numpy数组使用的内存更更少。 numpy可以在整个数组上执行复杂的计算，而不需要python的for循环 基于numpy的算法比纯python快10-100倍，并且内存使用的更少 直接使用pip install numpy进行安装, 并且通常我们使用import numpy as np进行别名使用 ndarray多维数组对象即n维数组对象 数组创建随机二维数组和多维数组几个参数就是几维数组 123456789101112131415161718192021# 二维数组In [5]: a = np.random.randn(2,3)In [6]: aOut[6]:array([[ 0.40782246, 1.01188141, -0.72254947], [-0.33912128, -0.83395203, -0.62968705]])In [8]: type(a)Out[8]: numpy.ndarray# 三维数组In [10]: np.random.randn(2,3,2)Out[10]:array([[[ 0.06468234, 1.35577864], [ 0.65733334, 0.76170521], [ 1.14480233, -0.02904135]], [[-0.32580275, -0.97027343], [-1.09083706, 2.13423053], [ 0.27216318, 1.01170855]]]) 自定义多维数组12345678In [14]: data1 = [[1,2,3],[4,5,6]]In [15]: array1 = np.array(data1)In [16]: array1Out[16]:array([[1, 2, 3], [4, 5, 6]]) 相关属性取维度大小和内容 123456# 维度大小In [20]: array1.ndimOut[20]: 2# 维度内容In [21]: array1.shapeOut[21]: (2, 3) 取数据类型 123# 取数据类型In [22]: array1.dtypeOut[22]: dtype('int32') 全1数组ones根据指定的形状和dtype创建一个全1数组； ones_like以一个数组为参数，创建一个形状和dtype相同全为1的数组 12345678910# 三维全1In [25]: np.ones((2,3,2))Out[25]:array([[[1., 1.], [1., 1.], [1., 1.]], [[1., 1.], [1., 1.], [1., 1.]]]) 全0数组zeros根据指定的形状和dtype创建一个全0数组； ones_like以一个数组为参数，创建一个形状和dtype相同全为0的数组 12345# 二维全0In [26]: np.zeros((2,3))Out[26]:array([[0., 0., 0.], [0., 0., 0.]]) 无具体值empty创建新数组，只分配空间不填充任何值，一维参数为int，多维参数是一个元祖 对应empty_like方法，以另一个数组为参数，并根据它的形状和dtype创建创建一个数组 12345# np.empty 返回上得是没有初始化的垃圾值In [28]: np.empty((2,3))Out[28]:array([[0., 0., 0.], [0., 0., 0.]]) 全x数组full根据指定的形状和dtype，创建一个全为填充值x的数组 full_like参数为数组，如上 1234567b = np.full((2,3), 5)array([[5, 5, 5], [5, 5, 5]]) c = np.full_like(b, 2)array([[2, 2, 2], [2, 2, 2]]) 指定类型dtype和类型转换astype123456789101112In [44]: a = np.array([1,2,3,4,5], dtype=np.int32)In [45]: aOut[45]: array([1, 2, 3, 4, 5])In [46]: a.dtypeOut[46]: dtype('int32')In [47]: a1 = a.astype(np.int64)In [48]: a1.dtypeOut[48]: dtype('int64') 创建单位矩阵 123456789101112131415161718# N * N的单位矩阵(对角线为1 其余为0)In [50]: a = np.eye(4)In [51]: aOut[51]:array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]])In [52]: b = np.identity(4)In [53]: bOut[53]:array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) 数组运算大小相同的数组之间的任何算数运算会将运算进行的元素级上 大小相同数组与标量运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849In [54]: array1 = np.array([[1,2,3],[4,5,6]])In [55]: array1Out[55]:array([[1, 2, 3], [4, 5, 6]])# 加In [56]: array1 + array1Out[56]:array([[ 2, 4, 6], [ 8, 10, 12]])# 减In [57]: array1 - array1Out[57]:array([[0, 0, 0], [0, 0, 0]])# 乘In [58]: array1 * array1Out[58]:array([[ 1, 4, 9], [16, 25, 36]])# 除In [59]: 1 / array1Out[59]:array([[1. , 0.5 , 0.33333333], [0.25 , 0.2 , 0.16666667]])# 乘方In [60]: array1**2Out[60]:array([[ 1, 4, 9], [16, 25, 36]], dtype=int32)# 整除In [61]: array1 // 2Out[61]:array([[0, 1, 1], [2, 2, 3]], dtype=int32)# 取余In [62]: array1 % 2Out[62]:array([[1, 0, 1], [0, 1, 0]], dtype=int32)# 布尔In [63]: array2 = [[1,5,2],[1,4,2]]In [64]: array1 &gt; array2Out[64]:array([[False, False, True], [ True, True, True]]) 索引与切片切片规则与列表相同 shape的看法: 从左到右，维数减少；数值的多少表示该维度下有几个元素(数组) 切片的使用也可以对应shape 123456789101112131415161718192021222324252627282930In [65]: array1 = np.array([1,2,3,4,5,6])In [67]: array1[1:5]Out[67]: array([2, 3, 4, 5])# 切片会给数组的对应的索引位置全部赋值In [68]: array1[2:5] = 100In [69]: array1Out[69]: array([ 1, 2, 100, 100, 100, 6]# 对多维数组In [70]: array2 = np.array([[1,2,3],[4,5,6],[7,8,9]])In [71]: array2[:2]Out[71]:array([[1, 2, 3], [4, 5, 6]])# 两种方式一样In [72]: array2[1,2]Out[72]: 6In [73]: array2[1][2]Out[73]: 6# 进行多个切片In [74]: array2[:2,:2]Out[74]:array([[1, 2], [4, 5]])# 只有'冒号'时, 选取整个轴In [75]: array2[:,1]Out[75]: array([2, 5, 8]) 布尔型索引分别使用 &amp; | ~ 表示与或非得关系 123456789101112131415a = np.array([ False, True, True, False])b = np.random.randn(4,5)array([[-0.99938879, -0.0535668 , -0.16032889, 1.08049267, 0.35588453], [-0.28420901, 1.05329939, -1.35097747, 0.41424505, 0.42079163], [ 0.24882717, -1.14601162, 0.51924268, -1.26684902, 1.54417874], [ 0.34665976, 0.28197566, -1.10021705, -0.39085565, -0.25763008]])# 注意两组数组中的行数应该相同b[a==True]array([[-0.28420901, 1.05329939, -1.35097747, 0.41424505, 0.42079163], [ 0.24882717, -1.14601162, 0.51924268, -1.26684902, 1.54417874]])# 使用非关系b[~a==True]array([[ 2.10217141, 1.8107804 , 0.1177351 , -0.7263583 , -0.74179261], [-1.3267273 , -0.05289648, 0.42071815, -0.29748229, -1.39459566]]) 花式索引123456789101112131415161718192021222324252627282930313233343536373839404142# fancy indexing 指利用整数数组进行索引# 指定一个由32位整数组成的二维8行4列的数组In [23]: array1 = np.arange(32).reshape(8,4)In [24]: array1Out[24]:array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]])# 花式索引In [25]: array1[[1,4,6]]Out[25]:array([[ 4, 5, 6, 7], [16, 17, 18, 19], [24, 25, 26, 27]])# 重新指定数组的形状In [26]: array1.reshape(4,8)Out[26]:array([[ 0, 1, 2, 3, 4, 5, 6, 7], [ 8, 9, 10, 11, 12, 13, 14, 15], [16, 17, 18, 19, 20, 21, 22, 23], [24, 25, 26, 27, 28, 29, 30, 31]])# 也可以使用负数索引In [27]: array1[[-1,-4,-6]]Out[27]:array([[28, 29, 30, 31], [16, 17, 18, 19], [ 8, 9, 10, 11]])# 取指定位置的元素# 选择出的是(1,1), (4,3), (6,2)位置的元素# 注意使用花式索引选用具体的值时, 两边索引个数必须相等,此处都是3个索引In [41]: array1[[1,4,6],[1,3,2]]Out[41]: array([ 5, 19, 26])# 取索引后 也可以再次取索引In [45]: array1[[1,4,6]][[0,1,2],[1,3,2]]Out[45]: array([ 5, 19, 26]) 转置矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 行变列 列变行In [49]: array1 = np.arange(12).reshape(4,3)In [50]: array1Out[50]:array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]])# 转置方法1 T方法 适用于一维和二维In [51]: array1.TOut[51]:array([[ 0, 3, 6, 9], [ 1, 4, 7, 10], [ 2, 5, 8, 11]])# 矩阵内积 # 矩阵a和它的转置矩阵aT 索引轴上所有数据对应乘所得到的# 如 (0,0) 0*0+1*1+2*2=5 (2,3) 6*9+7*10+8*11=212In [52]: np.dot(array1, array1.T)Out[52]:array([[ 5, 14, 23, 32], [ 14, 50, 86, 122], [ 23, 86, 149, 212], [ 32, 122, 212, 302]])# 转置方法2 transpose方法# 注意tranpose方法 与shape相关 如array2.shape -&gt; (2,2,4) -- (0,1,2)# 如整数6 其索引是(0,1,2) 若transpose(1,0,2) 整数6通过变化位置的索引就变成(1,0,2) 也就是转置后的位置In [60]: array2 = np.arange(16).reshape(2,2,4)In [61]: array2.shapeOut[61]: (2, 2, 4)In [62]: array2Out[62]:array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]])In [63]: array2.transpose(1,0,2)Out[63]:array([[[ 0, 1, 2, 3], [ 8, 9, 10, 11]], [[ 4, 5, 6, 7], [12, 13, 14, 15]]])# 转置方法3 swapaxes方法# swapaxes使用的轴的变化 与shape有关 array2.shape -&gt; (2,2,4) --&gt;shape标号(0,1,2)# 如下swapaxes(1,0) 就将shape中0代表的轴和1代表轴交换位置# 举例： 整数6(0,1,2) 交换0轴1轴 即(1,0,2)# 同时 swapaxes的参数是两个整数, 并且位置无关(1,0)和(0,1)作用一样In [73]: array2.swapaxes(1,0)Out[73]:array([[[ 0, 1, 2, 3], [ 8, 9, 10, 11]], [[ 4, 5, 6, 7], [12, 13, 14, 15]]]) 通用函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546In [76]: array1 = np.arange(10)In [77]: array1Out[77]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])# 开根(0.5次方)In [78]: np.sqrt(array1)Out[78]:array([0. , 1. , 1.41421356, 1.73205081, 2. , 2.23606798, 2.44948974, 2.64575131, 2.82842712, 3. ])# 以e为底的指数函数In [79]: np.exp(array1)Out[79]:array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03])In [80]: arr1 = np.random.randint(5)In [81]: arr1Out[81]: 1In [82]: arr1 = np.random.randn(5)In [83]: arr1Out[83]: array([-0.44545786, -1.97082844, 0.5864768 , -0.58903824, 0.69115051])In [84]: arr2 = np.random.randn(5)In [85]: arr2Out[85]: array([-1.13874562, -0.30752957, -0.80933734, 0.37003582, 0.54560881])# maxinum将两个ndarray进行找最大值操作In [86]: np.maximum(arr1, arr2)Out[86]: array([-0.44545786, -0.30752957, 0.5864768 , 0.37003582, 0.69115051])# 返回浮点数数组中的小数 整数部分In [92]: decimal, integer = np.modf(arr1)In [93]: decimalOut[93]: array([-0.44545786, -0.97082844, 0.5864768 , -0.58903824, 0.69115051])In [94]: integerOut[94]: array([-0., -1., 0., -0., 0.]) 逻辑判断where 12345678910# where 将数组arr1中大于0变成True, 否则变成FalseIn [108]: arr1Out[108]: array([-0.44545786, -1.97082844, 0.5864768 , -0.58903824, 0.69115051])In [109]: np.where(arr1&gt;0, True, False)Out[109]: array([False, False, True, False, True])# where 将数组arr1中大于0变成True, 否则保持arr1中值不变(True变成了1)In [110]: np.where(arr1&gt;0, True, arr1)Out[110]: array([-0.44545786, -1.97082844, 1. , -0.58903824, 1.] 数学运算和统计 mean sum std cumsum cumprod any all unique in1d intersect1d setdiff1d union1d axis为0求列，axis为1求行 12345678910111213141516171819202122232425262728293031323334353637383940In [112]: array2Out[112]:array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]])# 求整个数组平均值# mean(1) 即mean(axis=1)计算每行的平均值In [113]: array2.mean()Out[113]: 7.5# 求整个数组和# sum(0) 即sum(axis=0)计算每列的和In [114]: array2.sum()Out[114]: 120# 求方差-各数据与平均值的差的平方和的平均数（数值越大波动越大，越不稳定） std# 求累计和-当前元素与前面所有元素的和 cumsum()a = np.arange(9)array([0, 1, 2, 3, 4, 5, 6, 7, 8])a.cumsum()array([ 0, 1, 3, 6, 10, 15, 21, 28, 36], dtype=int32)# 求累积积-当前元素与前面所有元素的和 cumprod()a[1:].cumprod()array([ 1, 2, 6, 24, 120, 720, 5040, 40320], dtype=int32)# 判断存在True any()# 判断全部为True all()# 排序函数-默认是快速排序 sort()# 去重 unique()c = np.full_like(a, 5)array([5, 5, 5], dtype=object)np.unique(c)array([5], dtype=object)# 测试一个数组的元素在另一个数组的是否出现 in1d()d = np.array([1,2,3,2,5,1])np.in1d(d, [1,3])array([ True, False, True, False, False, True])# 求交集 intersect1d()# 求并集 union1d()# 求差集 setdiff1d(x, y) 元素在x中不在y中 随机函数np.random.x rand 生成均匀分布的伪随机数(分布在[0,1)之间) rand(2,3) –&gt; 生成分布在[0,1)之间的两行三列的随机数 uniform 生成均匀分布的伪随机数(在[0,1)之间) uniform(2,3) –&gt; 生成在[2,3)之间的伪随机数 randn 生成标准正态分布的伪随机数(均值为0，方差为1) randint 给定范围内取随机整数 shuffle 对一个序列进行随机排列操作 permutation 返回一个序列的随机排列 normal产生正态分布的样本值 关键词123456array random ones ones_like zeros zeros_like empty empty_like full full_like dtype astypeshape reshape T dot transpose swapaxesmaximum modf where mean sum stdcumsum cumprod any all unique in1dintersect1d setdiff1d union1d]]></content>
      <categories>
        <category>Python</category>
        <category>data_analyses</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django关于mangodb的使用]]></title>
    <url>%2F2018%2F12%2F06%2FDjango%E4%B8%ADmongo%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Django+Mongo​:point_right: 安装需要的包 在django中要使用模型就需要使用mongoengine 因此安装 pip3 install mongoengine==0.16.0 :point_right:settings配置 django官方文档没有包含mongodb使用说明，按照下面修改就能使连接到mongodb 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': None, # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;from mongoengine import connectconnect('django')# 注： django是数据库名 :point_right:简单的models.py 12345678import mongoengineclass MongoDjangoTest(mongoengine.Document): name = mongoengine.StringField(max_length=20) content = mongoengine.StringField(max_length=100) # 指定连接mongo数据库对应的集合名(表名)， 即test2就是表名, 如果不指定就是模型名的小写 meta = &#123;'collection':'test2'&#125; :point_right:增删改查 123456789101112131415161718192021222324252627from django.http import request, HttpResponsefrom app.models import MongoDjangoTestdef add_data(request): if request.method == &apos;GET&apos;: test1 = MongoDjangoTest() test1.name = &apos;test1&apos; test1.content = &apos;WOWOWOWOOOWOWOWOW&apos; test1.save() return HttpResponse(&apos;success&apos;)def remove_data(request): if request.method == &apos;GET&apos;: MongoDjangoTest.objects.filter(name=&apos;test1&apos;).delete() return HttpResponse(&apos;success&apos;)def query_data(request): if request.method == &apos;GET&apos;: mongos = MongoDjangoTest.objects.all() print(mongos) return HttpResponse(mongos)def update_data(request): if request.method == &apos;GET&apos;: mongos = MongoDjangoTest.objects.filter(name=&apos;test1&apos;).update(content=&apos;update data&apos;) return HttpResponse(&apos;success&apos;) ​:closed_lock_with_key: 使用mongoengine建立的模型后,其操作数据库表使用方式与其他数据库(mysql, postgresql)的方式差不多 Mongomongo将数据插入到collection集合中, 而插入的数据又被称为document文档. 文档的数据结构和JSON基本一样。 所有存储在集合中的数据都是BSON格式。 BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。 数据库(mangodb shell)​:point_right: 连接数据库 1234mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]# 使用用户名和密码连接登录到本地的mongo指定test数据库mogondb://root:123456@localhost/test ​:point_right: 使用数据库,若数据库不存在就创建 use db_name 其他更多的可以看菜鸟教程 pymango:point_right:1 .简单使用 123456789101112131415# pip3 install pymangofrom pymango import MangoClient# 自定义端口和地址(默认本地127.0.0.1,端口27017) # client = MangoClient('mangodb://127.0.0.1:27019') 或者# client = pymongo.MongoClient(host='localhost', port=27017)client = MangoClient()# 连接数据库, 假设数据库名为db_name# db = client['db_name'] 或者db = client.db_name# 连接到数据集(即表), 假设数据集名为dataset# coll = db['dataset']coll = db.dataset :point_right:2 .插入数据 123456789101112# 插入单条数据, coll_name是数据集名, document是bson格式的数据, doucments就是数据序列db.coll_name.insert_one(document)#eg:document = db.student.insert_one(&#123; &apos;name&apos;: &apos;lisa&apos;, &apos;age&apos;: 21, &apos;scores&apos;: [&#123;&apos;subject&apos;: &apos;chinese&apos;, &apos;grade&apos;: 90&#125;, &#123;&apos;subject&apos;: &apos;mathematic&apos;, &apos;grade&apos;: 80&#125;] &#125;)db.coll_name.insert_many(documents) :point_right:3 .查询数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 查询数据'''find(filter=None, projection=None, skip=0, limit=0, no_cursor_timeout=False, cursor_type=CursorType.NON_TAILABLE, sort=None, allow_partial_results=False, oplog_replay=False, modifiers=None, manipulate=True) '''# 查询出来的是一个列表集合documents = db.coll_name.find()for document in documents: print(document)# 查询出来的是一个数据# find_one(filter_or_id=None, *args, **kwargs)document = db.coll_name.find_one() # 通过id来查询, 需要引入bson库中的ObjectIdfrom bson.objectid import ObjectIdresult = collection.find_one(&#123;'_id': ObjectId('593278c115c2602667ec6bae')&#125;)# 查询最外层数据db.student.find(&#123;'name':'lisa'&#125;)# 查询内层嵌套的数据db.student.find(&#123;'scores.subject': 'chinese'&#125;)# 操作符查询# 若是有满足条件就能查到, 如下面四个都能查到# gt大于 gte大于等于db.student.find(&#123;'scores.grade':&#123;'$gt':85&#125;&#125;)# lt小于 lte小于等于db.student.find(&#123;'scores.grade':&#123;'$lt':85&#125;&#125;)# in在范围里db.student.find(&#123;'scores.grade':&#123;'$lt':[80, 85]&#125;&#125;)# nin不再范围里db.student.find(&#123;'scores.grade':&#123;'$lt':[80, 85]&#125;&#125;)# 正则表达式, db.student.find(&#123;'name':&#123;'$regex':'^l.*'&#125;&#125;)# 其他符号查询# name属性存在db.student.find(&#123;'name':&#123;'$exists':True&#125;&#125;)# age的类型为intdb.student.find(&#123;'age':&#123;'$type':'int'&#125;&#125;)# age模4余1db.student.find(&#123;'age':&#123;'$mod':[4, 1]&#125;&#125;)# text类型的属性中包含he字符串db.student.find(&#123;'$text':&#123;'$search':'he'&#125;&#125;)# 计数count = db.student.find().count()# 排序# 传入排序的字段升序排列, 降序为DESCENDING, 升序ASCENDING, 得到的results是列表results = db.student.find().sort('name', pymango.ASCENDING)# 偏移2, 即忽略两个元素results = db.student.find().sort('name', pymango.ASCENDING).skip(2)# 忽略2个元素后再限制得到3个元素results = db.student.find().sort('name', pymango.ASCENDING).skip(2).limit(3) :point_right:4 .更新数据 12345678910111213# 方式一, 修改其字段, 再更新(原条件, 修改后的数据)condition = &#123;&apos;name&apos;: &apos;lisa&apos;&#125;stu = db.student.find_one(condition)stu[&apos;age&apos;] = 25result = db.student.update(condition, stu)#注意, 不能直接更新它的某个字段, 它不直接使数据只有这一个更新后的字段, 其他字段就没了哦# 上述的内容， 也可以使用update_one条件更苛刻result = db.student.update_one(condition, &#123;&apos;$set&apos;: stu&#125;)# update_many更新多条(对年龄大于10的数据, 修改其年龄为30)condition = &#123;&apos;age&apos;: &#123;&apos;$gt&apos;: 10&#125;&#125;result = db.student.update_many(condition, &#123;&apos;$inc&apos;: &#123;&apos;age&apos;:30&#125;&#125;) :point_right:5 .删除数据 12345678# remove()删除指定的条件result = db.student.remove(&#123;&apos;name&apos;:&apos;lisa&apos;&#125;)# delete_one()删除一个数据result = db.student.delete_one(&#123;&apos;name&apos;:&apos;lisa&apos;&#125;)# delete_many()删除多条数据result = db.student.delete_many(&#123;&apos;age&apos;:&#123;&apos;$gt&apos;:10&#125;&#125;) :point_right:6 .组合方法 1find_one_and_delete()、find_one_and_replace()、find_one_and_update() 各版本数据库端口:point_right:1 .关系型数据库：Oracle数据库默认状态下：端口号为，1521MySQL数据库默认状态下：端口号为，3306SQLServer数据库默认状态下：端口号为，1433 :point_right:2 .NOSQL数据库：MongoDB默认状态下的端口号为：27017Redis默认状态下的端口号为：6379memcached默认状态下的端口号为：11211]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[restful风格]]></title>
    <url>%2F2018%2F12%2F03%2Frestful%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[RESTrest, 即为Representational State Transfer的缩写-表现层状态转换。若一个架构满足REST原则, 就成为RESTFUL架构。 资源资源resource, 是指’’资源’’的’’表现层状态转换’’ 资源是网络中的一个实体, 是具体的数据(文本, 图片,网页等)，我们可以通过URI(统一资源标识符)来找到它, 每个资源指向一个URI。因此,，要获取一个资源可以通过访问它的URI。 大家熟知的URL(统一资源定位符), 常用于浏览器中网址,，它是URI的子集 表现层表现层representational，指将资源的具体呈现出来的形式。 URI只代表资源的实体，不代表它的具体表现形式。具体表现形式是有HTTP请求的头信息中用Accept和Content-Type指定。这两个字段才是对表现层的描述。 状态转化状态转化state transfer，它指客户端和服务器的互动工程。 HTTP协议是一个无状态协议，它意味着所有的状态需要保存在服务端，客户端想要操作服务端，就需要通过某种手段发生’’状态转换’’的操作。具体到HTTP协议里面，操作方式为GET获取资源 POST新增资源 PUT修改资源 DELETE删除资源 PATCH修改资源部分内容 ​:point_right: 总结 1. 每个URI代表一种资源 2. 客户端和服务器之间， 传递资源的某种表现层 3. 客户端可以通过HTTP的传值方式，对服务器端资源进行操作， 实现表现层状态化 RESTFUL动宾结构RESTFUL的核心思想是让客户端的数据操作指令是动词+宾语的结构。如GET /articles，也就是前面的操作是动词(大写)，后面的路由应该是名词。 HTTP5种常见操作 12345GET 读取POST 新建PUT 修改PATCH 修改(部分修改)DELETE 删除 动词覆盖如django框架中只有GET和POST两种HTTP请求方式，服务器需要用POST去模拟另外的三种方法，此时，客户端发出的请求，要加上X-HTTP-Method-Override，他能够告诉服务器使用哪一种操作去覆盖POST方法。 ###宾语为名词 宾语是API的URL, 它被使用为名词，并且通常它都是一个集合，应该使用名词的复数。 1GET /articles ###避免多级URL 资源在出现多级分类的情况下，容易写出多级的URL。但是它是不利于拓展的，除了第一级，我们更多的应该使用参数(查询表达式) 1GET /articles?page=1&amp;per_size=8 状态码案例成功情况 123456789101112131415161718192021222324&#123; &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;javascript&quot;, &quot;useto&quot;: &quot;web development&quot; &#125;, &#123; &quot;name&quot;: &quot;python&quot;, &quot;useto&quot;: &quot;do anything&quot; &#125;, &#123; &quot;name&quot;: &quot;php&quot;, &quot;useto&quot;: &quot;web development&quot; &#125;, &#123; &quot;name&quot;: &quot;c++&quot;, &quot;useto&quot;: &quot;web server&quot; &#125; ], &quot;status&quot;: &#123; &quot;code&quot;: 200, &quot;message&quot;: &quot;OK all right.&quot; &#125;&#125; 失败情况 123456&#123; &quot;status&quot;: &#123; &quot;code&quot;: 404, &quot;message&quot;: &quot;No result matched.&quot; &#125;&#125; json响应 123456789101112131415161718#-*- coding: UTF-8 -*-from flask import jsonify# define statu_dics hereR200_OK = &#123;&apos;code&apos;: 200, &apos;message&apos;: &apos;OK all right.&apos;&#125;R201_CREATED = &#123;&apos;code&apos;: 201, &apos;message&apos;: &apos;All created.&apos;&#125;R204_NOCONTENT = &#123;&apos;code&apos;: 204, &apos;message&apos;: &apos;All deleted.&apos;&#125;R400_BADREQUEST = &#123;&apos;code&apos;: 400, &apos;message&apos;: &apos;Bad request.&apos;&#125;R403_FORBIDDEN = &#123;&apos;code&apos;: 403, &apos;message&apos;: &apos;You can not do this.&apos;&#125;R404_NOTFOUND = &#123;&apos;code&apos;: 404, &apos;message&apos;: &apos;No result matched.&apos;&#125;def fullResponse(statu_dic, data): return jsonify(&#123;&apos;status&apos;: statu_dic, &apos;data&apos;: data&#125;)def statusResponse(statu_dic): return jsonify(&#123;&apos;status&apos;: statu_dic&#125;) api接口 1... 参考于 1.基于flask的restful 2.restful风格介绍]]></content>
      <categories>
        <category>Python</category>
        <category>Restful</category>
      </categories>
      <tags>
        <tag>Api接口设计规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spider基础之requests]]></title>
    <url>%2F2018%2F11%2F26%2Fspider%2F</url>
    <content type="text"><![CDATA[urllib库request处理客户端的请求 response处理服务器的响应 parse去解析URL robots.txt文件用于识别网站, 告诉访问者哪些数据可以爬取哪些不可以, 但是没有实际的规则 12345678910111213141516from urllib import request, parseurl = "http://2018.sina.com.cn/"# 设置请求头headers = &#123;"User-Agent": "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)","Host": "2018.sina.com.cn",&#125;dict = &#123;"name": "Question"&#125;# 将数据转换成二进制数据data = bytes(parse.urlencode(dict), encoding="utf8")req = request.Request(url=url, data=data, headers=headers, method="GET")# 客户端发出请求,设置超时时间response = request.urlopen(req, timeout=1)print(response.read().decode("utf-8")) 在网页中爬取数据并整理成json格式, 保存到本地的json文件中; 将图片保存到本地 安装requests包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from json import dumpsfrom requests import getimport redef get_image(url): headers = &#123; "User-Agent": "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)", &#125; response = get(url, headers=headers) # 对于二进制文件使用content, 对于文本文件使用text if response.status_code == 200: return response.content return Nonedef get_page(url): headers = &#123; "User-Agent": "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)", &#125; response = get(url, headers=headers) if response.status_code == 200: return response.text return Nonedef get_all_page(): all_page_list = [] for i in range(10): offset = i * 10 url = 'http://maoyan.com/board/4?offset=' + str(offset) html = get_page(url) result_list = parse_one_page(html) all_page_list += result_list return all_page_listdef parse_one_page(html): # 获取电影名 pattern = re.compile(r'movieId.*?&gt;.*?&lt;img src.*?&gt;.*?&lt;img.*?alt="(.*?)" class.*?', re.S) movie_names = re.findall(pattern, html) # 获取主演 pattern = re.compile(r'&lt;p class="star"&gt;(.*?)&lt;/p&gt;', re.S) movie_actors = re.findall(pattern, html) # 上映时间 pattern = re.compile(r'&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;', re.S) movie_releases = re.findall(pattern, html) # 排名 pattern = re.compile(r'&lt;i class.*?board-index-.*?"&gt;(.*?)&lt;/i&gt;', re.S) movie_indexes = re.findall(pattern, html) # 分数 pattern = re.compile(r'integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;', re.S) movie_scores = re.findall(pattern, html) # 电影图片 pattern = re.compile(r'movieId.*?&lt;img.*?&lt;img data-src="(.*?)"', re.S) movie_pics = re.findall(pattern, html) result_list = [] for i in range(len(movie_actors)): result_dict = &#123;&#125; result_dict['name'] = movie_names[i] result_dict['actor'] = movie_actors[i].strip() result_dict['release'] = movie_releases[i] result_dict['index'] = movie_indexes[i] result_dict['score'] = movie_scores[i][0]+movie_scores[i][1] result_dict['pic'] = movie_pics[i] result_list.append(result_dict) return result_listdef write_image_files(result_list): # 将图片保存到本地 for item in result_list: pic_name = item['pic'].split('/')[-1].split('@')[0] # print(pic_name) content = get_image(item['pic'].split('@')[0]) with open('./images/%s' % pic_name, 'wb') as f: f.write(content)def write_json(result_list): # 将文本文件转换为json格式, 并且格式不使用ascii码格式 json_list = dumps(result_list, ensure_ascii=False) with open('./files/maoyan_top100.json', 'w', encoding='utf-8') as f: f.write(json_list)def main(): # html = get_page('http://maoyan.com/board/4') # result = parse_one_page(html) # print(result) result = get_all_page() # 将图片保存到本地 write_image_files(result) # 将内容保存到本地的json文件 write_json(result)if __name__ == '__main__': main() 返回响应, 对于二进制文件使用reponse.content, 对于文本文件使用reponse.text lxml使用pip install lxml进行安装包, 然后就能使用关键的方法etree 匹配所有节点 123# 注: html是在requests相关方法返回的text或contentetree_html = etree.HTML(html)result = etree_html.xpath(&apos;//*&apos;) 匹配所有子节点 1result = etree_html.xpath(&apos;//span/text()&apos;) 查找元素子节点 1result = etree_html.xpath(&apos;//div/p/text()&apos;) 查找元素所有子孙节点 1result = etree_html.xpath(&apos;//div[@class=&quot;channel-item&quot;] | //span[@class=&quot;pubtime&quot;]/../span/a/text()&apos;) 父节点 1result = etree_html.xpath(&apos;//span[@class=&quot;pubtime&quot;]/../span/a/text()&apos;) 属性匹配 1[@class=&quot;xxx&quot;] 文本匹配 1234# 获取对应标签下的文本 /text()# 获取所有文本 //text()result = etree_html.xpath(&apos;//div[@class=&quot;article&quot;]//text()&apos;) 属性获取 12result = etree_html.xpath(&apos;//div[@class=&quot;article&quot;]/div/div/@class&apos;)[0]result = etree_html.xpath(&apos;//div[@class=&quot;bd&quot;]/h3/a/@href&apos;) 属性多值匹配 123# or, and, mod, //book | //cd, + - * div = != &lt; &gt; &lt;= &gt;=# div就是除result = etree_html.xpath(&apos;//span[@class=&quot;pubtime&quot; and contains(text(), &quot;11:&quot;)]/text()&apos;) 按序选择 12# 拿取第一个对象 拿最后一个 位置在1,2的 倒数第三个[1] [last()] [poistion() &lt; 3] [last() -2] 节点轴 1234567//li/ancestor::* 所有祖先节点//li/ancestor::div div这个祖先节点//li/attribute::* attribute轴，获取li节点所有属性值//li/child::a[@href=&quot;link1.html&quot;] child轴，获取直接子节点//li/descendant::span 获取所有span类型的子孙节点 //li/following::* 选取文档中当前节点的结束标记之后的所有节点//li/following-sibling::* 选取当前节点之后的所用同级节点 beautifulsouppip install beautifulsoup4 虽然使用时from bs4 import BeautifulSoup 但安装的是beautifulsoup4 解析器 1234Python 标准库 BeautifulSoup(html, “html.parser”) 速度一般，容错能力好lxml HTML解析器 BeautifulSoup(html, “lxml”) 速度快，容错好lxml xml解析器 BeautifulSoup(markup, “xml”) 速度快，唯一支持xmlhtml5lib BeautifulSoup(markup, “html5lib”) 容错性高，速度慢 获取beautifulsoup对象 12# 第一个参数是返回的网页内容 , 第二个参数是解析器soup = BeautifulSoup(html, &apos;lxml&apos;) 对网页进行缩进保持显示 1soup.prettify() head标签里面的title的文字内容 1soup.title.string 获取第一个p标签和p标签的名字 1soup.p soup.p.name 获取第一张图片的src属性 1234# 方法1soup.img.attrs[&quot;src&quot;]# 方法2soup.img[&apos;src&apos;] 嵌套选择 123&lt;head&gt;&lt;title&gt;this is title&lt;/title&gt;&lt;/head&gt; 如上拿取title标签中的内容, 使用soup.head.title.string , soup的节点都为bs4.element.Tag类型 关联选择 对部分元素没有特征定位, 使用找到最近的能定位的元素, 再进行相对定位 123456789print(soup.p.contents) # 取p节点下⾯面所有⼦子节点列列表print(soup.p.descendants) #取p节点所有⼦子孙节点print(soup.a.parent) # 取⽗父节点print(soup.a.parents) # 取所有祖先节点print(soup.a.next_sibling) # 同级下⼀一节点print(soup.a.previous_sibling) # 同级上⼀一节点print(soup.a.next_siblings) # 同级所有后⾯面节点print(soup.a.previous_siblings) # 同级所有前⾯面节点print(list(soup.a.parents)[0].attrs['class']) css选择器 beautifulsoup提供的最好使用查找元素或属性的方法, 通过一层一层的查找, ​:six_pointed_star: 如果是嵌套的选择器, 两种标签间需要使用空格来隔开, 类选择前加上. ,id选择器前加上# soup.select(‘#top-local .top-sidebar ul li a’) ​:six_pointed_star: 如果对一个标签中有两个类选择器, 如class=”middle-local middle-local-color”, 使用时他们之间不能使用空格, soup.select(‘.middle-local.middle-local-color’) json与python格式转换 123456写入json数据到文件 json.dump(data, f) f是文件对象读取json文件 json.load(f)json数据转python数据 json.loads(json_data)python数据转json数据 json.dumps(str_data, ensure_ascii=False) Ajax类型数据抓取对于直接在网页中显示的文本,图片或其他信息可以直接使用上述的方式进行抓取, 但是对于通过ajax即时刷新的数据, 我要通过查找数据接口, 通过测试是否能得到数据, 反复调试的方式去解决 ​:bust_in_silhouette:​ 通过测试拿到的Api, 并将数据进行分析, 比如分页其是否有page字段, 然后进行改变page值或取出变量的值, 观察其是否能拿到数据. 对拿到的数据进行分析, 再去取需要的字段。 script加载的数据对于script加载出的数据, 因为requests返回的网页是在script加载前获取的网页, 因此我们要拿到这些数据需要通过查看 network –&gt; response, 再去看script中的数据, 去拿到关键的字段 ​:zoom: 例如 1234567891011121314151617181920212223242526272829303132import refrom requests import getdef get_page(url): headers = &#123; "User-Agent": "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)", &#125; response = get(url, headers=headers) if response.status_code == 200: return response.text return Nonedef parse_one_page(html): # 获取路径, 通过正则表达式去拿到关键的部分 pattern = re.compile(r'downurls=.*?集\$(.*?)";', re.S) movie_url = re.findall(pattern, html) return movie_urldef main(): url = 'https://www.mkv99.com/vod-detail-id-9462.html' html = get_page(url) urls = parse_one_page(html) print(urls)if __name__ == '__main__': main() # ['ed2k://|file|夜魔侠.Marvels.Daredevil.S01E01.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|527863576|2d1c82c2c008e2ee1530e8414907a914|h=yrfispeakmuri5f22rxgzpkfcbk24qvm|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E02.中英字幕.WEB-HR.AAC.1024X576.x264.V2.mp4|524859002|a83cc090336953ee56f879f619bc56c9|h=53dvm77bdjbc7kllnfjt7yrdzeajr66i|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E03.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|518647797|9c9709e370cd0c5a38ec4f7e9ce0384f|h=5pxbvbdvrem2lpyjbl2njsvotepadyul|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E04.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|521235766|47bc6aa802b7a5512e2638dd4af40e78|h=e5ixi47l7lfv774bbuy532vagw2eqclt|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E05.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|555440046|f7652568822929a14be2d453c1459c6a|h=4uu22psmdjrchkqooqr5w6ieccxjw5u5|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E06.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|480630134|53dc20e942f84ee94fd48349b01af6e0|h=ki4lptq3wd37nzt2vn4ap3snu76wc4xo|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E07.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|500199767|77eb276a1b00bf691ee4c8b563a4ac80|h=amssg44wp464tzrxmhc3ux5hkpg2nq57|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E08.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|518658368|dbe5bdd03ecd9b57aa859c170fa1abc0|h=qbembxlyrohqh7gfbcwint2smm7b3lxb|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E09.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|571996837|1dade15505d478124f1f5a5ee17fb5c1|h=zsqhucbfikp4kaf2c3xls3eokcv45rms|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E10.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|561720273|1cebc714cf8c2b4831f5575801e14685|h=y5vkgxwv74eb6ugagurplsmf2ub24tr7|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E11.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|583884398|ea8ec771a1137ca9b555452d00318722|h=xkqfzn456ic7m4glpx2frebdcddk4x7g|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E12.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|593112458|a908a3ca23161d816c31a3821ad2def1|h=bt2kqwyolsx3fscyzkqmd7vuw2djnnli|/#', 'ed2k://|file|夜魔侠.Marvels.Daredevil.S01E13.End.中英字幕.WEB-HR.AAC.1024X576.x264.mp4|554521285|9ea56d4b04de5ad4bf6b7ade7394dc24|h=4wv4kcu6hibta7pgzw7zgyckrpp2h4yf|/#']# 如上述的内容，放在迅雷或电驴中进行解析就可以下载]]></content>
      <categories>
        <category>Python</category>
        <category>Spider</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Web框架之Flask]]></title>
    <url>%2F2018%2F11%2F12%2FFlask%2F</url>
    <content type="text"><![CDATA[Flask简介Flask安装 安装虚拟环境 virtualenv --no-site-packages -p &lt;python.exe位置&gt; env_name, 其中-p参数是在有个python版本时指定自己想要的版本, –no-site-packages指定干净安装 使用时需要安装pip install flask Flask最小的应用代码需要先进行安装flask和flask_script,当有多个安装的库(模块)时, 可以将需要的库名逐行写入到一个txt文件(req.txt), 在使用pip install -r req.txt进行逐行安装 12345678910111213141516from flask import Flaskfrom flask_script import Managerapp = Flask(__name__)# 使用manager管理app对象manager = Manager(app)@app.route('/app')def hello_world(): return 'hello world'if __name__ == '__main__': app.run(host='0.0.0.0', port=8081, debug=True) # 使用manager管理, 运行方式python xxx.py runserver # 运行可选参数-p post -h host -d # manager.run()# 运行 python xxx.py 当使用Manager管理app对象时, 运行方式为python xxx.py runserver -p port -h host -d (-p端口号, -h主机号, -d调试模式) 路由匹配规则123456789101112131415161718192021222324252627282930# &lt;converter: variable_name&gt;&lt;选择器: 参数名&gt;# &lt;int: id&gt; @app.route('/int/&lt;int:id&gt;/')def mg(id): return f'大屌萌哥&#123;id&#125;号' # &lt;name&gt; 接受id参数器类型为str, 它等价于&lt;string: name&gt;@app.route('/str/&lt;name&gt;/')def mg3(name): return f'星星还是那个星星&#123;name&#125;' # &lt;float: num&gt; 接受num参数类型是float(也接受int类型)@app.route('/float/&lt;float:num&gt;/')def mg2(num): return f'float类型&#123;num&#125;咋了'# &lt;path: name&gt; 接受name参数, 其作用是将&lt;app:name&gt;路由信息全部打出来(可以后续接任意路由, 能读取/符号),例如: 运行127.0.0.1:8080/path/123/123/d2/, 就返回 大屌萌哥天下第一123/123/d2@app.route('/path/&lt;path:name&gt;/')def mg4(name): return f'大屌萌哥天下第一&#123;name&#125;'# &lt;uuid: uid&gt; 接受uid参数, 得到hash运算后的32位(uuid运算), 需要引入uuid@app.route('/get_uuid/')def mg5(): uid = uuid.uuid4() return str(uid)@app.route('/uuid/&lt;uuid:name&gt;/')def uuid_name(name): return f'uuid&#123;name&#125;' 蓝图管理虽然在初始的py文件可以放置所有网站内容, 但是这样显得很怪异并且不方便管理, 为了达到分离视图层, 业务逻辑, 可以使用蓝图blueprint来管理路由, 达到模块化管理应用的目的. Blueprint 第一步, 安装库文件 pip install flask-blueprint 第二步, 获取蓝图对象 12from flask import Blueprintapp_blueprint = Blueprint('app', __name__) 第三步, 注册蓝图 123# app是建立的一个模块(准确的用包来说明更合适), url_prefix指路由的前缀, 相当于django中的namespacefrom app.views import app_blueprintapp.register_blueprint(blueprint=app_blueprint, url_prefix='/flask/') request请求在pycharm中, 使用debug+postman使用添加request字段进行调试 get请求 request.getrequest.getlist post请求 request.form 上传文件 request.files 获取路径 request.path 请求方式 request.methods 在flask中可以指定请求方式, 通过methods来指定 1234567891011@app_blueprint.route('/re/', methods=['GET', 'POST', 'PATCH'])def hello_world(): if request.method == 'GET': # 获取get方式提交的数据: request.args # request.args[key]或request.args[key] # request.args.getlist() return '大屌萌哥' if request.method == 'POST': # TODO: 获取POST提交的参数 # request.form() return '星星还是那个星星' 重定向在django中使用: HttpResponseRedirect(reverse(‘namespace:name’)) 在flask中使用 视图函数有参数的情况下 redirect(url_for(‘蓝图别名.路由下的执行函数’), name=’123’) 视图函数没有参数 redirect(url_for(‘蓝图别名.路由下的执行函数’)) 响应创建响应 make_response(响应内容, 响应状态码) 响应绑定cookie set_cookie / delete_cookie 1234@app_blueprint.route('/make_response/', methods=['GET'])def make_my_response(): res = make_response('&lt;h1&gt;大屌萌哥&lt;/&gt;') return res 异常通过about (number)来抛出异常, 使用errorhandler(number)来处理, 具体如下: 123456789101112131415@app_blueprint.route('/foo/', methods=['POST'])def foo(): try: a = int(request.form.get('a')) b = int(request.form.get('b')) return f'&#123;a&#125;/&#123;b&#125;=&#123;a/b&#125;' except Exception as e: # 抛出异常 abort(500)@app_blueprint.errorhandler(500)def error_handler(error): # TODO: 返回错误界面 return f'Exception is: &#123;error&#125;' Session和Cookie第一种: session数据存储在客户端: Flask采用’secure cookie’方式保存session，即session数据是使用base64编码后保存在客户端的cookie中。也就是说无须依赖第三方数据库保存session数据。 第二种: session数据存储在服务端，分为以下三步骤: 步骤1: 当客户端发送请求到服务端的时候，服务端会校验请求中cookie参数中的sessionid值，如果cookie中不存在sessionid则认为客户端访问服务端时，是发起了一个新的会话。 步骤2: 如果是新的会话，则服务端会传递给客户端一个cookie，并在cookie中存储一个新的sessionid值，并将相关数据保存在session中。 步骤3: 客户端下次再发送请求的时候，请求上下文对象会携带cookie，通过校验cookie中的sessionid值，即可判断是否是同一会话。 步骤4: 如果校验会话是同一会话，则可以从session中获取到之前保存的数据。 访问者的标识问题服务器需要识别来自同一访问者的请求。这主要是通过浏览器的cookie实现的。 访问者在第一次访问服务器时，服务器在其cookie中设置一个唯一的ID号——会话ID(session)。 这样，访问者后续对服务器的访问头中将自动包含该信息，服务器通过这个ID号，即可区 隔不同的访问者。 Cookie 概念 1234567# 1.数据存在于客户端(即浏览器中)# 2.是以键值对进行存储的# # 特点:# 1.支持过期时间# 2.默认自动携带网站的cookie# 3.不能跨越名和跨浏览器 创建 set_cookie(key, value, max_ages, expires) max_ages为超时时间, 以秒计时, expires也是超时时间, 以分计时 删除 123# 1.直接删除浏览器的cookie缓存# 2.delete_cookie(key)# 3.set_cookie(key, expires=0) 获取 request.cookies.get(‘field’) 将Session数据存于数据库中下面所述选用redis数据库, flask-session是flask框架的session组件 安装redis,flask-session pip install redis,flask-session 配置session存储redis数据库 12app.config['SESSION_TYPE'] = 'redis'app.config['SESSION_REDIS'] = redis.Redis(host='127.0.0.1', port=6379) 数据 123456789# 1.添加session['key'] = value# 2.读取result = session['key'] #内容不存在, 将会报异常result = session.get('key') #内容不存在, 将返回None(很多时候没有判断session['key']中是否有值, 返回NoneType错误)# 3.删除session.pop('key')# 4.清空session.clear() 使用 1234567891011121314# 引入redis -- import redis# 1.初始化Flask对象app = Flask(__name__)# 2.注册蓝图app.register_blueprint(blueprint=app_blueprint, url_prefix=&apos;/app/&apos;)# 3.配置密钥, 密钥的字符串应该是随机的,非固定的app.secret_key = &apos;daihiodhoahwoi&apos;# 4.配置session存储数据库(如上)# 5.初始化flask对象app# 5.1 方法1Session(app)# 5.2 方法2session = Session()session.init_app(app) 安装redis数据库 开启redis服务, 然后执行flask项目。此时分为两种情况 第一种, 没有登录的情况, 客户端中没有服务器发给他的sessionid， 因此此时相当于开启一次新的会话 第二种, 在已经登录的情况下, 客户端(浏览器)与服务器通过比较sessionid来匹配是否是同一个用户。此时登录完成后,在浏览器中以sessionid为key, 会自动将sessionid的值前加上”session:”作为key, 其值是一串加密的字符串, 传到redis数据库中。 模板​ 在flask中的配置, 都是在实例化Flask对象的py文件中操作的, 我们需要对实例化的对象(如:app=Flask(__name__)) 通过修改app的属性已达到配置的目的。 ​ flask对象的初始化中, 已经帮我们完成static和templates的配置, 能找到文件的路径。 ​ 继承flask中的继承语法和django几乎是一样的, 通过使用挖坑, 填坑达到目的 标签 模块 1&#123;% block xxx %&#125; &#123;% endblock %&#125; for/if 1234# for&#123;% for i in xxx %&#125; &#123;% endfor %&#125;# if&#123;% if xxx %&#125; &#123;% else %&#125; &#123;% endif %&#125; 声明函数 12345# 声明的函数可以有参数&#123;% macro say(name) %&#125;&lt;p&gt;你好,&#123;&#123;name&#125;&#125;&lt;/p&gt;&#123;% endmacro %&#125;注: 若将函数写在当前要使用的页面时, 函数中可以使用js, 否则不能使用 导入函数 当需要从别的页面导入函数时, 我们可以新建一个functions.html的文件, 在其中只存放各种函数声明。 12# 从functions.html中导入函数的语法, foo是函数名&#123;&#123; from 'functions.html' import foo &#125;&#125; 引入静态文件的方法 1234# 方式1:&lt;link type="text/css" rel="stylesheet" href="/static/css/style.css"&gt;# 方式2:&lt;link rel="stylesheet" href="&#123;&#123; url_for('static', filename='css/style.css') &#125;&#125;"&gt; 变量在模板中可以使用从后端传过来的变量 后端传变量的方式是通过render_template返回渲染页面, 并将上下文一并返回(context): 1234@app_blueprint.route('/temp/')def temp(): content = ['英雄联盟', '地下城与勇士', '绝地求生', '剑灵'] return render_template('temp.html', title='此地无银三百两', content=content) 1234# 对于循环for中&#123;&#123; loop.first &#125;&#125; 判断第一个&#123;&#123;loop.last&#125;&#125; 判断最后一个&#123;&#123;loop.index&#125;&#125;得到第几个 过滤器过滤器使用方法和内容与django中几乎一样, 如使用对于后端传过来来由样式,标签或js的内容,使用safe阻止转义等 数据库flask没有自带支持数据库的部分, 需要引入第三方库sqlalchemy, 要使用mysql需要引入pymysql 安装 pip install sqlalchemy, pymysql 创建模型参考django内容,在app下新建一个models.py作为模型文件 12345678910111213from flask_sqlalchemy import SQLAlchemy# 实例化一个SQLAlchemy对象db = SQLAlchemy()# 第一步: 声明模型class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(10), unique=True, nullable=False) password = db.Column(db.String(100), nullable=True) __tablename__ = 'day02_user' 关键配置12345678# 引入db对象from app.models import db# 数据库配置# dialect+driver://username:password@host:port/databaseapp.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;mysql+pymysql://root:123456@127.0.0.1:3307/flask6&apos;app.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = False# 初始化app和dbdb.init_app(app) 数据库采用mysql数据库 增加123456# 创建一个Student对象, 进行添加， 最后提交事务stu = Student()stu.name = 'xxx'stu.gender = 0db.session.add(self)db.session.commit() flask中没有save()方法, 但是我可以自定一个save()方法在models.py的Student类中,如下: 12345def save(self): db.session.add(self) db.session.commit()# views.py中使用 stu.save() 一次添加多个 12345678grade_name = ['物理151', '物理152', '大气151', '大气152']grade_list = []for g in grade_name: grade = Grade() grade.g_name = g grade_list.append(grade)db.session.add_all(grade_list)db.session.commit() 修改第一种: 通过先找到对应的数据, 修改其字段, 再进行保存 123stu = Student.query.filter(Student.name == &apos;云澈&apos;).first()stu.name = &apos;沐玄音&apos;stu.save() 第二种: 通过update进行修改, 再使用commit提交事务 12Student.query.filter(Student.name == &apos;沐玄音&apos;).update(&#123;&apos;name&apos;: &apos;茉莉&apos;&#125;)db.session.commit() 删除通过delete方法进行删除 1234567stu = Student.query.filter(Student.name == '云澈').first()stu.del_stu()# del_stu()def del_stu(self): db.session.delete(self) db.session.commit() 查询filter_by 12# filter_by(字段名=值)Student.query.filter_by(name=&apos;茉莉&apos;).first() filter 12# filter(模型名.字段名 == 值) ,返回一个basequery对象Student.query.filter(Student.name == &apos;云澈&apos;).first() get 123# get(ident), ident是主键id, 获取不到就返回空Student.query.get(ident=2)Student.query.get(2) all 12# 获取所有的结果, 返回的是一个包含查询结果对象的列表Student.query.filter_by(xxx).all() first 12# 返回的是一个查询结果的第一个对象, 但是不能使用all.first()Student.query.filter_by(name=&apos;茉莉&apos;).first() order_by 123456# 升序Student.query.order_by(&apos;id&apos;)Student.query.order_by(&apos;id asc&apos;)# 降序Student.query.order_by(&apos;-id&apos;)Student.query.order_by(&apos;id desc&apos;) 模糊查询 contains 等价于 like(‘%x%’) 12# 查找student表中name字段包含 沐 的所有记录, 返回的是listStudent.query.filter(Student.name.contains('沐')).all() startswith等价于like(‘x%’) | endswith等价于like(‘%x’) 1234# 查找student表中name字段以 沐 开头的所有记录Student.query.filter(Student.name.startswith('沐')).all()# 查找student表中name字段以 月 结束的所有记录Student.query.filter(Student.name.endswith('月')).all() like 分为_ 和 % 12# 查找student表中name字段包含 月 的所有记录Student.query.filter(Student.name.like('%月%')).all() in_ 12# 查找student表中id字段在1-4之间的的所有记录Student.query.filter(Student.id.in_(range(1,5))).all() __gt__ 和 &gt;(大于) __ge__(大于等于) | __lt__和&lt; (小于) __le__(小于等于) 123# 两个等价Student.query.filter(Student.id.__ge__(5)).all()stu = Student.query.filter(Student.id&gt;5).all() 分页 views.py中显示函数 123456# 获取page的值page = request.args.get(&apos;page&apos;, 1)# 获取分页对象(page值, 每页包含的记录数目)paginate = Student.query.paginate(int(page), 3)# 得到集体的数据, 列表stus = paginate.items 网页中, 路径中反向解析是蓝图名.执行函数名 1234567891011121314当前共有&#123;&#123;paginate.pages&#125;&#125;页|第&#123;&#123;paginate.page&#125;&#125;页|&#123;%if paginate.has_prev %&#125;&lt;a href="&#123;&#123; url_for('app.sel_stu') &#125;&#125;?page=&#123;&#123;paginate.prev_num&#125;&#125;"&gt;上一页| &lt;/a&gt;&#123;% endif %&#125;&#123;%for i in paginate.iter_pages()%&#125;&lt;a href="&#123;&#123; url_for('app.sel_stu') &#125;&#125;?page=&#123;&#123;i&#125;&#125;"&gt; &#123;&#123;i&#125;&#125; &lt;/a&gt;&#123;% endfor %&#125;&#123;% if paginate.has_next %&#125;&lt;a href="&#123;&#123; url_for('app.sel_stu')&#125;&#125;?page=&#123;&#123;paginate.next_num&#125;&#125;"&gt;下一页&lt;/a&gt;&#123;% endif %&#125; and_ or_ not_ 123456789101112from sqlalchemy import and_, or_, not_# 功能和and_一样, 且的功能 Student.query.filter(Student.name.like('%月%'), Student.gender == 0).all()# and_ 且的功能Student.query.filter(and_(Student.name.contains('月'), Student.gender == 0)).all()# or_ 并的功能Student.query.filter(or_(Student.name.contains('月'), Student.name.like('沐%'))).all()# not_ 非的功能stus = Student.query.filter(not_(Student.gender == 1)).all() 关联关系一对多 一 : 123456class Grade(db.Model): # flask不提供主键, 需要自己指定 id = db.Column(db.Integer, primary_key=True, autoincrement=True) g_name = db.Column(db.String(10), nullable=False, unique=True) # relationship中Student对应多的表的模型名 student = db.relationship('Student', backref='grade') 多 : 123456class Student(db.Model): id = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column(db.String(10), unique=True, nullable=False) gender = db.Column(db.Boolean, default=1) # grade_id 指定的外键的字段, 迁移到数据库后就是这个名称, ForeignKey对应的外键的字段来源(来自grade表的id字段: grade.id) grade_id = db.Column(db.Integer, db.ForeignKey('grade.id')) 正向查询(通过1查询多, grade–student) 123grade = Grade.query.get(6)student_obj = grade.student# 多的对象 = 1的对象.多的模型名的小写 反向查询(通过多查询1, student–grade) 123stu = student.query.filter_by(name=&apos;茉莉&apos;)grade_obj = stu.grade# 1的对象 = 多的对象.1的对象中backref字段的值(若得到多个就返回对象的列表, 若得到一个就返回这个对象) 多对多 多 12345# 学生表class Student(db.Model): id = db.Column(db.Integer, primary_key=True, autoincrement=True) name = db.Column(db.String(10), unique=True, nullable=False) gender = db.Column(db.Boolean, default=1) 多 123456# 课程表class Course(db.Model): id = db.Column(db.Integer, primary_key=True, autoincrement=True) c_name = db.Column(db.String(20), nullable=False, unique=True) # 指定关系 senodary指定中间表的名字 student = db.relationship('Student', secondary=stu_cou, backref='course') 中间表 1234# 指定外键stu_cou = db.Table('stu_cou', db.Column('s_id', db.Integer, db.ForeignKey('student.id')), db.Column('c_id', db.Integer, db.ForeignKey('course.id'))) 多对多的关系与一对多关系中正向查询/反向查询使用方式相同, 官方文档 带参数路由访问带参数路由如@app_blueprints.route(&#39;/stu_cous/&lt;int:id&gt;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) 这样的一个路由信息, 如果要通过get方式访问网页, 其反向解析的路径为 1&lt;a href=&quot;&#123;&#123; url_for(&apos;app.cous&apos;, id=stu.id) &#125;&#125;&quot;&gt;&lt;/a&gt; 它需要自己指定字段=值 添加和删除1234567891011121314151617181920# views.py中@app_blueprints.route('/cous/&lt;int:id&gt;/', methods=['GET', 'POST'])def cous(id): if request.method == 'GET': cous = Course.query.all() return render_template('cous.html', cous=cous) # 给指定id的学生添加课程 if request.method == 'POST': add_cou = request.form.get('add_cou') couse_id = request.form.get('cou_id') student_id = id stu = Student.query.get(student_id) cou = Course.query.get(couse_id) # 正向添加 # cou.student.append(stu) # 反向添加 if add_cou == '提交': stu.course.append(cou) db.session.commit() return redirect(url_for('app.all_stu')) 在flask中使用method, 已经不局限于get和post两种方式, 同可以定义指定更多的如PATCH修改部分 DELETE删除 PUT修改全部等常见的传值方式. 删除 : 拿到student和course的对象, 就能使用remove方法,进行正向或反向删除 123456# 正向删除 # cou.student.remove(stu) # 反向删除 if del_cou == &apos;删除&apos;: stu.course.remove(cou) db.session.commit() 使用ajax删除后台删除表中数据的当时与上述的方式无异, 前端使用ajax方式进行局部的操作 123456789101112131415161718192021&#123;% block js %&#125;&lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; function del_cou(c_id, s_id)&#123; $.ajax(&#123; url: '/app/del_stu_cou/' + s_id +'/', type: 'DELETE', dataType: 'json', data: &#123;'c_id': c_id, 's_id': s_id&#125;, success: function(data)&#123; console.log(data); location.href='/app/all_stu/'; &#125;, error: function(data)&#123; alert('删除失败') &#125; &#125;) &#125;&lt;/script&gt;&#123;% endblock %&#125; 将删除的链接上, 添加del_cou()的点击事件, 进行这个链接即执行对应ajax函数, AJAX通过指定url属性表示传递数据的路由, type表示传递数据的方式, 上述使用DELETE用于删除数据，一目了然, dataType表示数据格式,都是json， data是出传递数据的内容, 当ajax执行将数据传到后端, 后端的执行函数处理完成, 又会返回到ajax中对应函数中, 处理成功, 就执行success属性下的函数, 否则执行error属性下的函数 location.href=&#39;/app/all_stu/&#39;即执行后台中这个路由下的函数 钩子在flask中没有中间件的概念, 代替的是钩子的出现 在django中, 其中间件类里precess_request对应flask中的**@app.before_request ,它是在处理函数前执行的;process_response对应flask中@app.after_request, 是在函数处理完成后执行的, 同时还有一个@app.teardown_request**是在函数处理完成后最后执行的, 它典型的使用就是创建数据库的连接后, 最后在这个函数中关闭连接 12345678910111213141516171819202122232425262728import pymysqlfrom flask import Flask, g@app.route('/hello/')def hello(): # 获取学生表信息 sql = 'select * from student;' result = g.cursor.execute(sql) data = g.cursor.fetchall() return str(data)@app.before_requestdef before_request(): # TODO: connect database by pymysql # 获取pymysql对象 conn = pymysql.Connection(host='127.0.0.1', port=3307, user='root', password='123456', database='flask6') # 获取游标 cursor = conn.cursor() g.cursor = cursor g.conn = conn print('在请求之间执行, 相当于django中的process_request')@app.teardown_requestdef teardown_request(exception): # 关闭数据库的连接 其中g对象是一个全局对象, 是专门用来保护用户的数据的, g对象在一次请求中request所有的代码的地方, 都是可以使用的 对比session也是全局对象, 但是它对于不同的请求request也能使用]]></content>
      <categories>
        <category>Python</category>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用CentOS进行Django项目部署]]></title>
    <url>%2F2018%2F11%2F09%2FDjango-%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[使用centos部署Django项目安装MariaDB 简述mariadb MariaDB Server是世界上最受欢迎的数据库服务器之一。它由MySQL的原始开发人员制作，并保证保持开源。着名的用户包括维基百科，WordPress.com和谷歌。 MariaDB将数据转换为各种应用程序中的结构化信息，包括银行业务和网站。它是MySQL的增强型替代品。MariaDB的使用是因为它快速，可扩展且强大，具有丰富的存储引擎生态系统，插件和许多其他工具，使其适用于各种用例。 MariaDB是作为开源软件开发的，作为关系数据库，它提供了一个用于访问数据的SQL接口。MariaDB的最新版本还包括GIS和JSON功能。 MariaDB的API和协议兼容MySQL，另外又添加了一些功能，以支持本地的非阻塞操作和进度报告。这意味着，所有使用MySQL的连接器、库和应用程序也将会在MariaDB下工作。 ​ 安装mariadb-server yum -y install mariadb mariadb-server 启动和自启 1234# 启动systemctl start mariadb# 自启systemctl enable mariadb Mysql mysql安装(注意云服务器开启3306端口) 1234567891011121314151617181920# 1.执行命令mysql_secure_installation# 2.为root输入密码Enter current password for root: enter# 3.是否设置root用户密码Set root password? [Y/n] y或enter# 4.设置密码和确认密码New password:Re-enter new password:# 5.是否删除匿名用户Remove anonymous users? [Y/n] enter# 6.是否禁止root远程登录Disallow root login remotely? [Y/n] enter# 7.是否删除test数据库Remove test database and access to it? [Y/n] enter# 8.是否重新加载权限表Reload privilege tables now? [Y/n] enter# 9.登录mysql -u root -p输入密码... 开启远程连接 1234567891011121314151617181920212223242526# 1.创建用户# 使用数据库(;不可省略)use mysql;# 针对ipcreate user &apos;root&apos;@&apos;&lt;ip&gt;&apos; identified by &apos;&lt;password&gt;&apos;;#全部 create user &apos;root&apos;@&apos;%&apos; identified by &apos;&lt;password&gt;&apos;;#&lt;ip&gt; 为ip地址, &lt;password&gt;为密码, 必填# 2.授权# 给用户最大权限grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;# 给部分权限(test 数据库)grant all privileges on test.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option;# 刷新权限表flush privileges;# 查看show grants for &apos;root&apos;@&apos;localhost&apos;; 安装python查看这儿 安装环境 安装virtualenv yum install python-virtualenv 创建虚拟环境 1234567virtualenv --no-site-packages -p &lt;python3地址&gt; &lt;env_name&gt;激活环境cd &lt;env_name&gt;source bin/activete退出环境cd &lt;env_name&gt;source bin/deactivete 安装Django项目对应虚拟环境下所需要的包 1234567django==1.11pymysqlPillow# 安装方式# 进入虚拟环境,直接安装 例如: pip3 install &lt;package_name1&gt; &lt;package_name2&gt; ...# 进入虚拟环境,将需要的包名存放在文件中, 在对文件中的所有内容进行安装 例如: install.txt 中存放上述的包名, 使用 pip3 install -r &lt;filename&gt;# 进入虚拟环境的操作进行pip3的安装, 也可以由 /home/env/testenv/bin/pip3 代替 部署文档所述是CentOS 7.3的linux系统进行部署 做部署的操作,在Django的工程目录下, 修改DEBUG=False, 项目的生产阶段使用DEBUG=True Django框架仅在开发模式下提供静态文件服务, 当开启DEBUG=False时,其不再提供静态文件服务, 主要是针对static和media。 当然如果想让它仍然支持静态文件服务, 也是有方法的, 下述会讲到。 测试环境进行部署在测试环境下一般直接使用python manage.py runserver的方式, 因为足够使用并且容易。 修改urls.py 123456789101112# 1.修改settings.py文件配置中DEBUG=False, 修改ALLOWED_HOST=[&apos;*&apos;]# 2.修改工程目录下的urls.py文件from django.views.static import servefrom &lt;工程文件同名目录文件&gt; import settingsurlpatterns = [ # 增加以下的url路由 url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.STATICFILES_DIRS[0]&#125;), url(r&apos;^media/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.MEDIA_ROOT&#125;), # 修改首页, 使用户在输入网站的域名或者ip地址(没有附加的路由)时直接访问首页 url(r&apos;/&apos;, views.index), ] 修改中间件,添加一个空的路由地址 123456789no_checks = [&apos;/user/login/&apos;, &apos;/user/register/&apos;, &apos;/goods/index/&apos;, &apos;/goods/detail/(.*)/&apos;, &apos;/media/(.*)/&apos;, &apos;/static/(.*)/&apos;, &apos;/cart/add_cart/&apos;, &apos;/cart/cart/&apos;, &apos;/&apos;] path = request.path for not_path in no_checks: if re.match(not_path, path): # 匹配当前路径是否为不需要登录的路径 return None 运行项目 1234# 创建一个fresh_shop.sh文件, 里面内容/home/env/testenv/bin/python3 /home/src/fresh_shop/manage.py runserver 0.0.0.0:80# 在执行时使用 ./fresh_shop# 若想后台执行使用 nohup ./start_fresh.sh ​ 正式环境部署正式环境部署采用nginx+uwsgi的方式部署项目 nginx 添加nginx存储库 yum install epel-release 安装nginx yum install nginx 运行nginx systemctl start nginx 查看nginx状态, 通过看状态能看到是否错误和错误信息 systemctl status nginx uwsgi 安装uwsgi, 在虚拟环境下安装uwsgi, 假设虚拟环境安装在/home/env/testenv/中 /home/env/testenv/bin/python3 install uwsgi 项目基本文件 将项目的配置文件, 日志文件, 项目文件, 虚拟环境分别放置, 便于管理，大概如下: conf是配置文件, 用于存放nginx.conf文件, uwsgi.ini文件 env是存放虚拟环境 logs存放日志的文件, 含nginx启动成功或失败的日志文件, uwsgi的运行日志文件 src是项目文件, 含项目所有代码 配置nginx.conf (freshnginx.conf) 在conf目录下, 创建一个与项目相关的配置文件如: freshnginx.conf文件 123456789101112131415161718192021server&#123;# 端口号 服务器名(可以是域名和ip地址) listen 80; server_name 39.108.229.154 localhost;# nginx开启成功或失败的日志文件 access_log /home/logs/access.log; error_log /home/logs/error.log;# 指定ip地址对应的网关, 端口号(固定写法) location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8989; &#125; # 配置静态文件, 指定静态文件地址便于服务器进行解析(这样就不用上述测试环境中的添加url) location /static/ &#123; alias /home/src/fresh_shop/static/; &#125;# 配置media文件 location /media/ &#123; alias /home/src/media/; &#125; &#125; 将自定义的nginx.conf文件添加的nginx的主配置文件中 重启nginx 配置uwsgi.ini文件, (freshuwsgi.ini) 12345678910111213141516[uwsgi]# 守护京城master = true# 进程数量processes = 4# 项目文件chdir = /home/src/fresh_shop# 指定虚拟环境python地址pythonpath = /home/env/testenv/bin/python3# 指定wsgi文件module = fresh_shop.wsgi# nginx通信地址:端口socket = 127.0.0.1:8989# 日志文件地址logto = /home/logs/freshuwsgi.log 运行项目 /home/env/freshenv/bin/uwsgi –ini freshuwsgi.ini 其他netstat -lntp 查看当前被监听(LISTEN)的进程 tail -f filename 显示文件最后一次被更新的内容]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django权限]]></title>
    <url>%2F2018%2F10%2F31%2FDjango%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[RBAC 基于角色的访问控制Roles-Based Access Control 角色访问控制（RBAC）引入了Role的概念,目的是为了隔离User(即动作主体，Subject)与Privilege(权限，表示对Resource的一个操作，即Operation+Resource)。 Role作为一个用户(User)与权限(Privilege)的代理层，解耦了权限和用户的关系，所有的授权应该给予Role而不是直接给User或 Group。Privilege是权限颗粒，由Operation和Resource组成，表示对Resource的一个Operation。例如，对于新闻的删除操作。Role-Privilege是many-to-many的关系，这就是权限的核心。 完善的RBAC模型 对于大多数情况下, 我们说的RBAC模型, 就是这样子的, 分为用户、角色、权限三部分 通过给角色添加权限(多对多关系), 再给用户添加角色(多对多关系). 此时用户对权限的访问, 就过渡到给用户指定带有权限的角色. 模型 Django中对应权限控制的用户表，权限表和角色表，同时还设有三种表之间的多对多关系中间表 注: auth_user用户表 auth_group角色表(组表) auth_permissions权限表 auth_user_groups 用户-角色表 auth_group_permissions角色-权限表 auth_user_user_permissions用户-权限表 这些表都是Django帮我们写好的模型, 在我们执行迁移时, 自动给我们生成。当然，我们也可以依托于models完全重写用户表模型，或者依托于AbstractUser类进行重写用户表的模型(即扩展auth_user表，这样他就能使用Django内置的很多权限操作相关函数) 1234567891011from django.contrib.auth.models import AbstractUser class MyUser(AbstractUser): class Meta: # Django默认给每个模型初始化3个默认权限(change, delete, add) permissions = ( ('add_my_user', '新增用户权限'), ('change_my_user_username', '修改用户名权限'), ('change_my_user_password', '修改用户密码权限'), ('all_my_user', '查看所有用户权限'), )# permissions 参数内放置权限的元组(??????) 注意: 要想让Django知道,将User模型修改为自定义的User模型, 需要修改settings.py文件. 格式为:AUTH_USER_MODEL = &#39;app_name.ModelName&#39; 思想 在Django 中，我们对权限控制的理解: 1先创建角色,2 对角色分配权限, 3再为用户指定角色;4 但在特殊的情况下,又直接为用户分配权限。 三种表之间的访问控制 三种表的关系均为多对多的关系, 我们可以查看 AbstractUser –&gt; PermissionsMixin 和Group的定义, 然后我们知道三种表之间的多对多定义字段, 如下: User表 123groups = models.ManyToManyField(Group)user_permissions = models.ManyToManyField(Permission) Group表 1permissions = models.ManyToManyField(Permission) 添加和删除 我们通过一种模型对象去修改另一个模型的对象, 这个过程我们不用去关注两种表的中间表(多对多关系), Django已经为我们处理好了(类似级联删除和更新) 通过用户表去添加权限表中的数据 12# user是用户模型对象, permission是将被添加的权限模型对象user.user_permissions.add(permission) 通过用户表去删除权限表的数据 12# user是用户模型对象, del_permission是将被删除的权限模型对象user.user_permissions.remove(del_permission) ​ 查询 用户自定义查询 通过用户直接查询权限 123456# 得到指定user对象的所有权限对象, 返回的是一个QuerySet对象, 它的内部是由所有权限模型对象 组成的user.user_permissions.all()# 通过过滤得到指定user对象的权限对象, 返回的是一个QuerySet对象user.user_permission.filter(xxx)# 直接得到确定的指定user对象的一个权限对象, 返回的是一个权限模型对象user.user_permission.get(name=&apos;xxx&apos;) 通过用户查询角色再查询权限 12# 返回的一个QuerySet对象user.groups.all()[0].permissions.all() 注: 删除的两种查询方式所得结果就是user的全部权限 Django自带的查询 用户获取组权限 12# 返回的是组(角色)权限的字典(codename字段)user.get_group_permissions() 用户获取所有权限 12# 返回的是用户所有权限的字典(codename字段)user.get_all_permissions() 在前端也能使用这些对象 请注意对象,属性,索引在Django模板标签中使用方式(使用 . ,属性不加括号) 权限认证 权限认证的部分通过装饰器来实现, 判断是否有权限 12# 判断user对象是否有permission_name权限user.has_perm(app_name.permission_name) 自定义装饰器实现权限认证 1234567891011121314151617181920# 举例针对test2用户， 必须拥有all_my_user权限才能访问# 视图函数@index_requireddef index(request): # test2用户有查看所有用户权限, 才能访问如下视图函数(装饰器) if request.method == 'GET': return render(request, 'index.html') # 装饰器def index_required(func): def inner(request): user = MyUser.objects.filter(username='test2').first() if not user: return HttpResponse('没有该用户') per = user.user_permissions.filter(codename='all_my_user').first() if not per: return HttpResponse('没有all_my_user权限') else: return func(request) return inner Django提供的权限认证装饰器 123456789# 装饰器中的参数是 app_name.permission_name@permission_required('rbac.ll_my_user')def foo(request): if request.method == 'GET': # 同时需要在配置文件setting.py中加入以下:# 登录权限验证不通过, 跳转的地址(通常为登录地址的全路由)LOGIN_URL = '/rbac/login/' ​]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PEP8]]></title>
    <url>%2F2018%2F10%2F26%2FPEP8%2F</url>
    <content type="text"><![CDATA[概观 PEP8 PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中,采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发⼀一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的PEP 8链接中找到该文档，下面我们对该文档的关键部分做一个简单的总结。 内容 缩进 123456789101112131415161718192021222324252627282930311.每一级缩进4个空格(在pycahrm或其他IDE中, 所使用的tab, 系统会自动给转换成4个空格)2.python3不允许空格与制表符混用3.python是优先考虑4个空格# 与左括号对齐foo = long_function_name(var_one, var_two, var_three, var_four)# 用更多的缩进来与其他行区分def long_function_name( var_one, var_two, var_three, var_four): print(var_one)# 悬挂缩进应该再换一行foo = long_function_name( var_one, var_two, var_three, var_four) # 对于数组或元组字典, 考虑使用悬挂缩进my_list = [ 1, 2, 3, 4, 5, 6, ] # 或者my_list = [ 1, 2, 3, 4, 5, 6,] ​ 单行最大行宽限制79个字符, 文档和注释限制72个字符 1234# 换行处理,以下两个方面。# 使用小括号/中括号/大括号会隐式换行(元组/列表/字典)# 使用反斜杠 \ 进行换行 二元运算符在前或在后换行不做约束, 但是在运算符前换行更容易被理解 空行 123# 顶层函数和类的定义，前后用两个空行隔开。 # 类里的方法定义用一个空行隔开。 # Python接受control-L（即^L）换页符作为空格；许多工具把这些字符当作页面分隔符，所以你可以在文件中使用它们来分隔相关段落。请注意，一些编辑器和基于Web的代码阅读器可能无法识别control-L为换页，将在其位置显示另一个字形。 源文件编码 1234# Python核心发布版本中的代码总是以UTF-8格式编码（或者在Python2中用ASCII编码）。 # 使用ASCII（在Python2中）或UTF-8（在Python3中）编码的文件不应具有编码声明。 # 对于Python 3和更高版本，标准库规定了以下策略（参见 PEP 3131）：Python标准库中的所有标识符必须使用ASCII标识符，并在可行的情况下使用英语单词（在许多情况下，缩写和技术术语是非英语的）。此外，字符串文字和注释也必须是ASCII。唯一的例外是（a）测试非ASCII特征的测试用例，以及（b）作者的名称。作者的名字如果不使用拉丁字母拼写，必须提供一个拉丁字母的音译。 鼓励具有全球受众的开放源码项目采取类似的政策。 导入import 12345678# 导入分组顺序# 1. python标准库# 2. 相关第三方库导入# 3. 本地库/应用导入# 在每组的导入间使用换行# 推荐使用绝对路径进行导入, 因为它更容易理解, 报错时也更容易查出 模块级’呆’名 1234567891011# 像__all__ , __author__ , __version__ 等这样的模块级“呆名“（也就是名字里有两个前缀下划线和两个后缀下划线），应该放在文档字符串的后面，以及除from __future__ 之外的import表达式前面。Python要求将来在模块中的导入，必须出现在除文档字符串之外的其他代码之前。 # 例如:from __future__ import barry_as_FLUFL__all__ = ['a', 'b', 'c']__version__ = '0.1'__author__ = 'Cardinal Biggles'import osimport sys 字符串引号 123# 单引号和双引号作用一致, 但是对于一个文件应该使用相同的字符引号# 对于三引号字符串, 推荐使用双引号字符 空格的使用 12345678910111213141516171819202122232425262728# 小括号、中括号、大括号后不要使用空格# 逗号,冒号,分号之前不使用空格(之后通常使用空格, 避免字符与空格混淆,不易发觉)# 对于冒号# 左右应该使用相同的空格, 下列为推荐的格式ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]ham[lower:upper], ham[lower:upper:], ham[lower::step]ham[lower+offset : upper+offset]ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]ham[lower + offset : upper + offset]# 二元操作符左右使用空格, 但是对于优先级差异的运算, 应该对低优先的二元运算符使用空格, 例如:i = i + 1submitted += 1x = x*2 - 1hypot2 = x*x + y*yc = (a+b) * (a-b)# 对于关键字参数或默认值参数, 不要使用空格def complex(real, imag=0.0): return magic(r=real, i=imag)# 对于功能型注释, -&gt; 左右给空格def munge() -&gt; AnyStr: ... # 有类型备注的参数赋值, 在=符号左右给空格def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ... 其他 1234567# 同一行不要有多条语句# 对于if/ while/else 类的若其后的代码块只有1句, 也最好换行if foo == 'blah': do_blah_thing()else: do_non_blah_thing() 注释 1234567# 行内注释# 有节制地使用行内注释。 # 行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始。# 块注释# 块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 # 块注释内部的段落通过只有一个#的空行分隔。 文档说明 123# 要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。# 多行文档说明使用的结尾三引号应该自成一行# 对于单行的文档说明，尾部的三引号应该和文档在同一行。 命令风格 12345678910# b（单个小写字母）# B（单个大写字母）# lowercase 小写字母# lower_case_with_underscores 使用下划线分隔的小写字母# UPPERCASE 大写字母# UPPER_CASE_WITH_UNDERSCORES 使用下划线分隔的大写字母# CapitalizedWords（或者叫 CapWords，或者叫CamelCase 驼峰命名法 —— 这么命名是因为字母看上去有起伏的外观5）。有时候也被称为StudlyCaps。 # 注意：当在首字母大写的风格中用到缩写时，所有缩写的字母用大写，因此，HTTPServerError 比 HttpServerError 好。# mixedCase（不同于首字母大写，第一个单词的首字母小写）# Capitalized_Words_With_Underscores（丑陋！） 命令约定 123456789101112131415161718192021222324252627282930# 规避的名字#永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。 #在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。# 模块# 模块应该用简短全小写的名字，如果为了提升可读性，下划线也是可以用的。# 当使用C或者C++编写了一个依赖于提供高级（更面向对象）接口的Python模块的扩展模块，这个C/C++模块需要一个下划线前缀（例如：_socket）# 例如: datetime# 包名# Python包名也应该使用简短全小写的名字，但不建议用下划线。 # 例如: static# 类名# 类名首字母大写的单词串 # 例如: MyClass# 函数# 通常使用小写, 为了提高可读性可以用下划线分隔。# 例如: my_first_day# 函数或方法参数# self 始终作为实例方法的第一个参数# cls 始终作为类方法的第一个参数# 若函数的参数名与已有的关键词冲突, 在参数名后加一个下划线比乱起名字打的好# 例如: class_ 比 clss 好# 常量# 通常使用下划线分割的全大写组成# 例如: MAX_DOODS_LENGTH 或 TOTAL 编程建议 12345678# 使用 is not 运算符，而不是 not … is 。虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑。 ( 直接not不好吗? :( )# 例如： if b is None: 或者 if b is not None# 当使用富比较（rich comparisons，一种复杂的对象间比较的新机制，允许返回值不为-1,0,1）实现排序操作的时候，最好实现全部的六个操作符（__eq__, __ne__, __lt__, __gt__, __ge__）而不是依靠其他的代码去实现特定的比较。 # 和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符。 # 始终使用def表达式，而不是通过赋值语句将lambda表达式绑定到一个变量上。(不好说) ​]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PEP8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django基础]]></title>
    <url>%2F2018%2F10%2F22%2FDjango%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[简介Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型model，视图(view)和控制器(controller)。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。 MVC和MVTMVC框架模式MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。核心思想是解耦合。 model 指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 view 指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。 controller 是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 MVC的优缺点: 12优点: 耦合性低, 重用性高, 部署快, 生命周期成本低, 可维护性高缺点: 不易完全理解, 调试很麻烦, 不适合中小规模的应用程序, 系统结构和实现变复杂 MVT框架模式Django采用框架模式就是由MVC演变成的MVT结构 model 与MVC中的M功能相同，负责和数据库交互，进行数据处理。 view 与MVC中的C功能相同，接收请求，进行业务处理，返回应答。 template 与MVC中的V功能相同，负责封装构造要返回的html。 虚拟环境相关操作安装virtualenv pip install virtualenv 安装虚拟环境 virtualenv --no-site-packages -p d:\python\python.exe &lt;venv-name&gt; pythone3.x版本支持python -m venv &lt;venv-name&gt; 参数说明: -p 指定版本 –no-site-packages 指定纯净模式下安装 进出虚拟环境 在../&lt;venv-name&gt;/script下, 执行activate 就会进入虚拟环境, 使用deactivate退出虚拟环境 查看帮助 pip -h 查看安装的包 pip list 安装与删除 pip install/uninstall &lt;package-name&gt; 查看版本 12345pip freeze# 将已安装的包版本信息重定向到文件中pip freeze &gt; requirements.txt# 逐行安装文件的包pip install -r requirements.txt 升级pip命令 python -m pip install --upgrade pip 注: 默认下安装的是最新版本的包, 当直到包名不知道版本, 使用pip install xx==99.99包管理器会给我们返回正确的包版本信息, 三方库官网pypi.org 镜像配置通常我们下载包时是通过访问pypi,下载比较慢,可以使用国内的镜像速度能明显提升, 具体如下: 123456注：可以直接使用 pip install 模块名 -i http://pypi.doubanio.com/simple# 1.在用户主目录 c:\user\administrator 下创建pip目录# 2.在pip目录中创建pip的文件, 修改器后缀名 ini , 注意要将文件的隐藏后缀.txt 去掉(工具-文件夹选项-查看-去除 隐藏已知文件的扩展名)# 3.在pip.ini的文件中,写入:[global]index-url=https://pypi.doubanio.com/simple 安装Django进入对应的虚拟环境下进行安装 pip install django==1.11 创建项目django-admin startproject &lt;project-name&gt; 项目文件说明 manage.py 工具集管理文件 settings.py 项目配置文件 urls.py 资源定位文件 wsgi.py 即Python Web Server Gateway Interface python关于web服务器网关接口, 是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标 __init__.py 文件 运行服务 方式1–通过终端terminal python manage.py runserver 运行服务 python manage.py runserver 0.0.0.0:8080 指定可访问的站点和端口号运行服务, 0.0.0.0 表示所有人都能访问, 也可以由python manage.py 0:8080简写 123错误:1.Error: [WinError 10013] 以一种访问权限不允许的方式做了一个访问套接字的尝试。通常是端口已经被占用, 可以在terminal中使用 netstat -ano|findstr &lt;port&gt; 查看段口是否被占用, 解决方式: 换个端口 方式2–修改配置edit configurations Script path选择项目的manage.py文件, Parameters写入runserver [port](默认8000) 创建Appdjango-admin startapp &lt;app-name&gt; / python manage.py startapp &lt;app-name&gt; 在控制台创建app的命令 ORM对象关系映射ORM 即object relational mapping对象关系映射 ORM应用流程建立模型 在当前的app中models.py 文件中创建一个学生类模型 数据库迁移 python manage.py makemigrations生成迁移文件 python manage.py sqlmigrate &lt;app-label&gt; &lt;migration-file-name&gt; &gt; temp.sql 将对应app中的迁移文件中的数据生成SQL语句并保存到temp.sql文件中 python manage.py migrate进行信息迁移(映射模型到数据库中), 在修改好数据库配置信息后, 会自动在指定的数据库生成一系列的表(如果不想要生成这些表, 你可以生成的SQL文件直接生成数据库) 12345auth_group/auth_group_permissions/auth_permission/auth_user/auth_user_groups/auth_user_user_permissions #6个关于用户、用户组及其权限相关的表django_admin_log # 用户日志表django_content_type # 内容类型表django_migrations # 信息迁移表django_session # session表 python manage.py createsuperuser 创建超级管理员 , 然后可以通过http://127.0.0.1:8000/admin访问 视图函数 在当前的app中views.py 定义一个自己需要的功能的方法, 这个方法可将将上述的类进行关联, 能使用ORM 形式访问和修改数据库. 123456def create_student(request): stu = Stduents() stu.s_name = 'lee' stu.s_age = 20 stu.save() return HttpResponse('create student success') 上述添加信息与Students.objects.create(s_name=&#39;大荒&#39;)等价 123# 若使用对应的模块需要引入from django.http import HttpResponse # 引入http模块中HttpResponse响应方法from app.models import Students # 在app.models模块中引入需要使用的Sudents类 添加路由 在项目同名文件中urls文件中, 添加需要url, 如: 12345urlpatterns = [ url(r'^hello_world/$', views.hello, name='hello'), url(r'^students/$', views.create_student, name='create_student'), url('^districts/(?P&lt;distid&gt;[1-9]\d&#123;5&#125;)/$', views.cities, name='cities'),] 在项目同名文件中setting.py文件中, 修改INSTALLED_APP中添加当前的app 配置迁移文件python manage.py makemigrations 进行迁移文件到数据库 python manage.py migrate 对于Django2.1版本, 创建的路由信息大概如下: 123456# 此处使用的path # 并且与django1.11相比, 不需要使用功能正则符号^ $, 并且支持&lt;type:name&gt;格式指定路由urlpatterns = [ path('districts/', views.provinces, name='provinces'), path('districts/&lt;int:distid&gt;/', views.cities, name='cities'), ] 关联关系一对一对两张表中的任意一张表, 使用OneToOneFiled , 指定一对一的关联 12345678910111213141516171819class User(models.Model): userid = models.AutoField(primary_key=True) username = models.CharField(unique=True, max_length=20) password = models.CharField(max_length=32) class Meta: managed = False db_table = 'tb_user' class UserToken(models.Model): tokenid = models.AutoField(primary_key=True) token = models.CharField(max_length=32) user = models.OneToOneField(to=User, on_delete=models.PROTECT, db_column='userid') class Meta: managed = False db_table = 'tb_user_token'# UserToken Object(token) / User Object(user)#正向: UserToken--&gt; User -- token.user#反向: User--&gt;UserToken -- user.usertoken db_column指定表中的字段名 一对多对两张表中选择 “多” 的表, 使用ForeignKey , 指定一对多的关联. (TempleA 属于”多”的表) 12345678910111213141516class User(models.Model): userid = models.AutoField(primary_key=True) name = models.CharField(max_length=255) tel = models.CharField(max_length=20) class BankCard: id = models.AutoField(primary_key=True) bcid = models.CharField(max_length=50) user = ForeignKey(to=User, on_delete=models.PROTECT, db_column='userid')# BackCard Object(card) User Object(user)# 正向查询(多查一): BackCard--&gt;User -- card.user# 反向查询(一查多): User--&gt;BackCard -- user.backcard_set.all() # 上述建立在拿到对象的情况，根据id可以使用(等价于user.backcard_set.all() -- user为id为1的对象)BankCard.objects.filter(user__userid=1)# 添加直接使用 create()方法 多对多对两张表中任意选择一张表, 使用ManyToManyField , 指定多对多的关联。 当我们对两张表进行数据库迁移的时候, django为我们会自动生成了两张表之间的关系表。 1234567891011121314class Goods(models.Model): goodsid = models.AutoField(primary_key=True) name = models.CharField(max_length=150) tags = ManyToManyField(to='Tag', through='GoodsTag') class Tag(models.Model): tagid = models.AutoField(primary_key=True) content = models.CharField(max_length=20) goods = ManyToManyField(to=Goods, through='GoodsTag')class GoodsTag(models.Model): goods_tag_id = models.AutoField(primary_key=True) goods = ForeignKey(to=Goods,on_delete=models.PROTECT , db_column='goodsid') tag = ForeignKey(to=Tag, on_delete=models.PROTECT, db_column='tagid') 多对多的添加: 12tag.goods.add()goods.tag.add() 多对多的删除 12tag.goods.remove()goods.tag.remove() 查询 all() 查询所有对象信息 filter() 过滤查询 1234567891011# 过滤查询stus = Students.objects.filter(s_name = '小明') #返回的是一个QuerySet对象# 注意: 若上述的过滤查询没有结果, 返回的是QuerySet为空. 因此, 与get()相比, filter() 方法更适用.# first和last方法被all和filter支持first() #获取第一个last() #获取最后一个# 可以同时使用多次过滤或者一次过滤多个条件stus = Students.objects.filter(s_age=20, s_gender=1)stus = Students.objects.filter(s_age=20).filter(s_gender=1) get() 获取确定的唯一一个结果 12stus2 = Students.objects.get(s_age = 20) #返回的是一个Students对象# 注意：若上述的查询没有结果或查询的结果有多个, 就会返回错误 模糊查询 sql中使用like &#39;%xxx%&#39; 包含x的情况 1stus = Students.objects.filter(s_name__contains='武') &#39;_xxx&#39; 以_开头 1stus = Students.objects.filter(s_name__startswith='武') xxx_ 以_结束 1stus = Students.objects.filter(s_name__endswith='武') 大于/大于等于 gt/gte 小于/小于等于lt/lte 12stus = Students.objects.filter(s_age__gt=18)stus = Students.objects.filter(s_age__gte=20) 排序 order_by() 12345# 升序stus = Students.objects.order_by('id')# 降序stus = Students.objects.order_by('-s_name') 查询不满足条件的数据 exclude() 12# 查询不满足id小于等于10的数据stus = Students.objects.exclude(id__lte=10) 统计查询的结果数 count()或len() 12stus_count = stus.count()stus_count = len(stus) 取值可带参数 values() 12stus = Students.objects.values()stus = Students.objects.values('s_name') 主键的字段名和pk等价 12stus = Students.objects.filter(id=10)stus = Students.objects.filter(pk=10) Q() 方法: 用于对一条记录的多个字段进行操作 12345678# 或条件 Q()|Q()stus = Students.objects.filter(Q(s_age = 15) | Q(s_gender = 0))# 且条件 Q()&amp;Q()stus = Students.objects.filter(Q(s_age = 15) &amp; Q(s_gender = 0))# 非条件 ~Q()stus = Students.objects.filter(~Q(s_age = 20)) F() 方法: 用于对多条记录的一个字段进行操作 12# 查询语文成绩比数学成绩大10分 的学生信息stus = Students.objects.filter(chinese__gt=F('mathematics') + 10) annotate / aggregate 聚合函数 创建修改写修改的相关方法, 具体的修改语句为 &lt;object&gt;.objects.filter(field=xxx...).update(field=xxx...) 删除写删除的相关方法, 具体删除语句为&lt;object&gt;.objects.filter(field=xxx...).delete() 数据库配置Django支持多种数据库, 如MySQL, PostgreSQL和Oracle , 我们可以必须指定默认数据库, 还可以指定任意数量的附加数据库，官方文档能帮助我们更快的认识数据库。 MySQL在settings中配置 12345678910111213# 此处使用的是mysql数据库DATABASES = &#123; # 配置默认数据库 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库引擎名 'NAME': 'django', # 数据库名 'USER': 'root', # 用户名 'PASSWORD': '123456', # 密码 'HOST': '127.0.0.1', # 主机, 这里表示本地 'PORT': '3306', # 通常是3306, windows下可以通过--&gt; 运行--&gt; services.msc查看对应的mysql服务的端口, linux下terminal --&gt; netstat -lntp|grep mysql 'TIME_ZONE': 'Asia/Chongqing', # 时区 &#125;&#125; pip install pymysql 安装需要的包 在__init__.py文件中配置, 进行初始化数据库的驱动 (因为python3不提供MYSQLdb 这个驱动, 必须导入) 12import mysql pymysql.install_as_MySQLdb() TIME_ZONE 上面必须配置时区字段，主要要和setting--&gt;TIME_ZONE的值一致，否则可能导致数据库操作加入的时间有误 模型层(M)Django提供了一个抽象层（“模型”），用于构建和操作Web应用程序的数据。官方文档点击 字段类型常见字段 Field 字段名 说明 AutoField 自增字段 自增字段, 用于主键 IntegerField 整数字段 CharField 字符字段 BooleanField 布尔字段 DateTimeField 日期时间字段 DecimalField 小数字段 TextField 文本字段 OneToOneField 一对一字段 用于一对一关系 ForeignKey 外键 用于一对多关系 ManyToManyField 多对多字段 用于多对多关系 字段参数文档 primary key 主键 null 123与数据库相关null=True允许在数据库中存储空数据, 所谓空数据值空字符串和null默认情况下,null=False 此时只允许存储空字符串 blank 允许表单验证输入空值 auto_now / auto_now_add 12用于DatetimeField字段创建数据时建立时间 / 更新数据时修改时间 choices 12345678用于可迭代的数据, 多为元组第一个值为将存储到数据库中, 第二个值表单小部件显示的数据LANGUAGES = ( ('zh-hans', '简体中文'), ('en', '英语'), ('ja', '日语'))language = models.CharField(max_length=10, choices=LANGUAGE) db_column / db_index 指定字段对应数据库中字段名 / 指定字段的索引 default 默认值 error_messages 指定错误信息, 主要用于表单验证 unique 指定字段是唯一值, 相当于创建了唯一索引 verbose_name 该字段的可读名称。如果未给出详细名称，Django将使用字段的属性名称自动创建它，将下划线转换为空格。 validators 验证器 on_delete / self/ db_contraint / related_name/limit_choices_to 1234567891011# on_delete可用于表与表一对一和一对多关系: - 'CASCADE',级联 'DO_NOTHING',不处理 - 'PROTECT'保护(禁止直接删除数据) - 'SET_NULL', 当将外键字段删除数据时置值为null,前提是字段null=True成立 - 'SET_DEFAULT' 当将外键字段删除数据时将值改成默认值,前提是设置了默认值# 修改当前执行反向查询的字段名related_name # 指定自关联(也可以是当前的模型类名)'self' through / db_contraint / limit_choices_to / related_name 123456789101112## 用于多对多关系### 告诉Django不用建立中间表, 我们已经自己建好了through # 不再使用外键约束, 但是保留跨表查询的便利(通过对象查询)db_contraint=False # 限制关联字段的对象范围limit_choices_to # 修改当前执行反向查询的字段名related_name Metaapp_label 在当前app之外定义模型, 声明它属于哪个应用 db_table 指定创建模型的表名 managed 12默认下, managed=True, 此时告诉Django这个模型可以生成迁移文件并迁移反向工程处理时, managed=False, 此时它不再执行迁移操作 ordering 12查询对象时的默认顺序ordering = [&apos;-score&apos;, &apos;name&apos;] unique_together 12指定一起使用的字段名称集必须是唯一的unique_together = ((&apos;student_id&apos;, &apos;name&apos;), ) 视图层(V)返回值辨析HttpResponse /HttpResponse/render 导包 12from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import render render 1234567891011121314151617181920212223render(request, template_name, context=None, content_type=None, status=None, using=None)# 对指定模板template与给定的上下文context结合, 并返回HttpResponse具有该呈现文本的对象。(下述有例子)# 1. 必须参数# request:用于生成此响应的请求对象# template_name:要使用的模板的全名或模板名称的序列。如果给出序列，则将使用存在的第一个模板。# 2. 可选参数# context:要添加到模板上下文的值的字典。# content_type:用于生成的文档的MIME类型。默认为DEFAULT_CONTENT_TYPE设置的值。# status:响应的状态代码, 默认200# using:该NAME模板引擎的使用加载的模板。def my_view(request): # View code here... return render(request, 'myapp/index.html', &#123; 'foo': 'bar', &#125;, content_type='application/xhtml+xml')# 相当于:def my_view(request): # View code here... t = loader.get_template('myapp/index.html') c = &#123;'foo': 'bar'&#125; return HttpResponse(t.render(c, request), content_type='application/xhtml+xml') HttpResponse 12return HttpResponse(&apos;msg&apos;)# 在网页做出处理后返回响应信息 HttpResponseRedirect 123return HttpResponseRedirect('/source/')# 它是HttpResponse()的子类# 对指定的路由(source)进行重定向处理, http状态码302(找到重定向) 重定向到指定路径第一种, 地址直接给硬编码 1return HttpResponseRedirect('/app/index/') 第二种, 使用反向解析 12345# reverse('namespace:name')return HttpResponseRedirect(reverse('rzlong:all_stu'))# 注: from django.urls import reverse# reverse('namespace:name') namespace就是工程下urls中include这个app的url指定的别名; name就是app下url的别名 在网页文件中的使用 12345678# urls.py配置(django1.11)url(r'^edit_stu/$', views.edit_stu, name='edit_stu')url(r'^edit_stu/(\d+)/$', views.edit_stu, name='edit_stu')# 地址硬编码# &lt;a href="/app/edit_stu/?stu_id=&#123;&#123;stu.id&#125;&#125;"&gt; 带参数# &lt;a href="/app/edit_stu/&#123;&#123; stu.id &#125;&#125;/"&gt; 不带参数# 反向解析# &lt;a href=" &#123;% url 'rzlong:edit_stu' stu.id %&#125;"&gt; 不带参数 路由管理最新django2.1路由配置文档 12345678910from django.urls import path, re_pathfrom . import views# path是django2.x以上的用法, 若是django1.11使用url# 如果要使用正则表达式的写法, 使用re_path# 在Python正则表达式中，命名正则表达式组的语法是(?P&lt;name&gt;pattern)，组name的名称，并且 pattern是要匹配的模式urlpatterns = [ path('articles/&lt;int:page&gt;/', views.special_case_2003, name='articles'), re_path(r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$', views.year_archive), re_path(r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$', views.month_archive),] 模板层使用(T)注释 &lt;!--xx--&gt; html中提供的注释方法, 但是注释内容会在网页中显示. Django中对网页内容的单行注释, 注释内容网页中不显示. Django中对网页内容的多行注释, 注释内容在网页中不显示. 12&#123;% comment %&#125; &#123;% endcomment %&#125;# 注: django中标签语法&#123;% xxx %&#125;与hexo转换md文件使用到nunjucks语法冲突,错误如下图. 解决方法(将这部分放在md格式下的多行注释部分即可) 继承 通常我们对于一系列具有相同内容的网页, 通常使用模板的方式让子网页去继承模板网页中base.html的内容. 在模板网页内容中, 尽量不去放置标签/css/js, 可以再创建一个base_main.html 让它继承base.html , 然后其他子页面再去继承base_main.html 父模板base.html, 在父模板中定义block的位置(挖坑) 1&#123;% block xxx %&#125; &#123;% endblock %&#125; 子模板index.html , 在子模板中填写block(填坑) 12&#123;% extends &apos;base.html&apos; %&#125;&#123;% block xxx %&#125; contents &#123;% endblock %&#125; 标签1&#123;% tag %&#125; &#123;% endtag %&#125; for 使用方法 123&#123;% for stu in students %&#125; &lt;p&gt;姓名: &#123;&#123;stu.s_name&#125;&#125;, 年龄: &#123;&#123;stu.s_age&#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; safe 12# 阻止转义, 即是阻止django将html语言的关键字过滤掉&#123;% var|safe %&#125; ifequal 1234# 如果变量var的值等于value&#123;% ifequal var value %&#125; &#123;% else %&#125; &#123;% endifequal %&#125; extends 12# 继承某个页面(html)&#123;% extends &apos;base.html&apos; %&#125; 更多标签从这儿寻找 变量变量从context中输出一个值, 它是一个类似于dict的对象, 将键映射到值 通过字典查找, 属性查找, 列表索引查找 使用点表示法实现 123456# 字典查找&#123;&#123; my_dict.key &#125;&#125;# 属性查找&#123;&#123; my_object.atrribute &#125;&#125;# 列表索引查找&#123;&#123; my_list.0 &#125;&#125; 对于context中输出的值, 也可以通过其一对一,一对多,多对多的特性得到其他的对象 12# 在views.py中返回context中含stu对象, 通过反向查询得到stu.studentinfo对象,获取其phone属性&#123;&#123;stu.studentinfo.phone&#125;&#125; forloop 使用方法 1234forloop.counter - 排序,依次递增序号,1开始forloop.counter0 - 排序,依次递增序号,0开始forloop.revcounter0 - 逆序,依次递减序号,0结束forloop.revcounter0 - 逆序,依次递减序号,1结束 block super 1234# 引用上级代码块, 并且能在其后作出修改(若不修改, 直接使用继承的block就好)&#123;% block js %&#125; &#123;&#123; block.super &#125;&#125;&#123;% endblock %&#125; 过滤器通过管道进行数据的过滤或转换 123456注:使用过滤器达到整除的目的&#123;% if forloop.counter|divisibleby:&quot;2&quot;%&#125; xxx&#123;% else %&#125; xxx&#123;% endif %&#125; 详情请见官方文档… 配置templates配置 在项目主目录下, 新建一个名为templates 的目录, 其中放置html文件 此时为了使templates生效, 需要在settings.py文件进行配置TEMPLATES项 12345注:# os.path.abspath(__file__) 当前文件的绝对路径# os.path.dirname(os.path.abspath(__file__)) 当前文件的绝对路径的上一级路径# BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# os.path.join(a, b) 是将b拼接在a后面 static静态文件配置配置 1234567#静态文件配置 html/css/jsSTATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'), # 其他位置的静态文件 # '/var/www/static/',] 使用 方式一: 1234&#123;% block css %&#125; &#123;% load static %&#125; &lt;link href="&#123;% static 'css/index.css' %&#125;" rel="stylesheet"&gt;&#123;% endblock %&#125; 方式二: 直接使用绝对路径 1&lt;link href="/static/css/index.css" rel="stylesheet"&gt; media媒体文件配置1234MEDIA_URL = &apos;/media/&apos; # 媒体文件别名(相对路径) 和 绝对路径MEDIA_ROOT = ( os.path.join(BASE_DIR, &apos;media&apos;)) 模型中使用方法 123class UserInfo(models.Model): username = models.CharField(verbose_name='用户名', max_length=32) avatar = models.FileField(verbose_name='头像', upload_to='upload/avatar/') 最终, 图片将存储到项目文件下media/upload/avatar/xxx.png 中间件解决CSRF跨站请求伪造（Cross-site request forgery） django中使用了一个名为CsrfViewMiddleware的中间件，它的主要作用就是验证跨域访问。什么跨域呢？就是跨域名、跨端口、跨协议 对每一个发出非GET方式的请求进行CSRF验证（就是通过验证一串随机数是否相同） 123456789101112131415161718192021222324252627282930# 配置允许跨域访问接口数据CORS_ORIGIN_ALLOW_ALL = True# 跨域访问允许的请求头CORS_ALLOW_HEADERS = ( 'accept', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with', 'token',)# 跨域访问支持的HTTP请求方法CORS_ALLOW_METHODS = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT',)MIDDLEWARE = [ 'corsheaders.middleware.CorsMiddleware',] 附录文档django1.11官方文档… django2.1官方文档… pycharm快捷键 123ctrl d 复制光标所在行(选中多行后, 复制多行)ctrl y 删除alt enter 快速导入 Debug 通过dubug (step into my code)--&gt; console --&gt; show the prompt, 然后可以访问查看各种数据。]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis first time]]></title>
    <url>%2F2018%2F10%2F18%2Fredis-first-time%2F</url>
    <content type="text"><![CDATA[简述redis redis 即remote dictionary server, 主要用于高速缓存, 去优化系统的的性能. redis通常放置体量小的热点数据, 体量大的数据放置在MySQL/ MangoDB 更合适. 安装redis 1.在redis.cn中可以找到下载源文件链接wget &lt;download site&gt; 2.对下载的文件解压缩 gunzip &lt;file&gt; 3.对解压缩的文件进行解归档 tar &lt;file&gt; 4.进入解归档的文件, 发现它已经有了makefile 的文件, 就不用进行进行配置, 直接构建安装 make &amp;&amp; make install 启动redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647方式一:修改默认配置文件redis.conf后再运行#1 ifconfig -- 私网172.18.170.112(在文件中修改bind字段的ip地址)#2 redis端口(merz) 6379(port)#3 (/requirepass) --修改 requirepass 口令#4 (/appendonly ) --修改 appendonly yes ,它会在创建服务器的时候, 生成appendonly.aof的文件, 存储的是每次执行的命令, 当你退出后在进入的时候, 若没有dump.rdb文件就执行所有的命令, 以达成数据持久化.注: rdbcompression yes 默认设置yes, dbfilename dump.rdb 就是默认存储所处理的数据的文件, 能达到数据持久化.foo bar配置哨兵(当主服务器崩掉, 利用哨兵选取新的主服务器)sentinel.confcp redis / sentinel.conf .配置: sentinel monitor mymaster &lt;masterip&gt; &lt;masterport&gt; &lt;int(哨兵数量投票数量)&gt;sentinel down-ater-milliseconds mymaster 10000 主机mymaster挂掉10秒就重新选主服务器sentinel failover-timeout mymaster 180000 故障恢复时间内, 若前服务器重连就使他加入努力， 否则删除主从服务群启动哨兵模式redis-server sentinel.conf --sentinel slaveof no one摆脱奴隶info replication120.77.222.217awk 文字处理grep -v op 不要带op的一一行xargs kill 将前面的输出作为kill的参数传入redis-server 虽然可以直接启动,但是使用的是默认的配置redis-server redis.conf &amp; 后台运行redis服务器redis-server redis.conf &gt; redis.log &amp; 后台启动服务器并输出重定向redis.log文件redis-cli -h ip(对自己用私网id, 对别人用公网ip)方式二:直接在redis-server后接参数启动redis-server --port 6379 --requirepass 123123 --appendonly yes &gt; redis.log &amp;flushall 删除当前库所有数据flushdb 删除所有库所有数据select 1 切换数据库(redis默认启动了16个库)save 同步保存bgsave 异步保存测试吞吐量redis-benchmark -h 公网ip -a passwd 关闭redis服务器 1234关闭redis服务1. ps -ef | grep redis 然后再kill psid2.将后台进程转到前台 -- fg %编号 再使用ctrl c关闭3.在客户端使用shutdown string字符串 12345678910111213set key value -&gt; 设置键值对set key value ex 1000 设置键值对存活(exists) 1000s- ttl key 查看对应键超时时间(time to live) -1为永不超时 -2已经超时- expire key time 指定超时时间get key 查看对应键的值exists key 查看键是否存在del key key可以是多个keys * 查看多有键setnx key value 若key不存在就添加键值对(set not exists)setex key ttl value 设置键值对的时候必须指定超时时间mset key1 value1 key2 value2... 可以同时指定多条数据mget key1 key2... 可以同时获取多条数据若key对应的value是数值时,可以使用incr key增加 decr key减少 hash哈希表 12345678910hset key field value 添加hash对象hget key filed 获取hash对象指定的字段hgetall key 获取hash对象所有键值对hvals key 获取hash对象的所有valuehmset key filed1 value1 filed2 value2...同时指定hash对象的多个字段hdel key filed 删除hash对象指定的字段hexists key filed 检查hash对象有没有指定的字段hkeys key 显示hash对象有哪些键hlen key 显示hash对象有几个键值对hscan key cursor遍历hash对象键值对, 若(1)中为0, 表示已经没有可遍历的对象, 若(1)中大于0, 表示还有可遍历的hash对象 list列表 123456lpush key value [value...] 从list对象的左边放入rpush key value [value...] 从list对象的右边放入lpop key 从list对象的左边取出一个值rpop key 从list对象的右边取出一个值lrange key start end 从左边找到list[start, end]rpoplpush key1 key2 从key1的右边取值再放到key2的左边 set集合 12345678910sadd key value [values...] 往集合中加入元素scard key 查看集合中有几个元素(有自动去重)sinter key1 key2 求集合key1和集合key2的交集sunion key1 key2 求集合key1和集合key2的并集sdiff key1 key2 求集合key1和集合key2的差集sismember key value 判断集合key中有没有valuesmembers key 查看集合key中所有元素srandmember key 从集合key中随机取一个元素spop key 从集合key中随机删除一个元素srem key value 从集合key中指定的删除一个元素 SortedSet有序集合 12zadd key score number [socre number...] 添加有序集合zrange key start stop 查看key[start, stop] 之间所有number 主从复制 123456修改redis.conf文件slaveof &lt;master_ip&gt; &lt;master_port&gt;masterauth &lt;passwd&gt;redis-cli 连接自己的redis服务器info replication 查看主从状态信息 参考文档 123redis.io resis官网resis.cn resis中文版redisdoc.com 提供redis参考文档]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql&python]]></title>
    <url>%2F2018%2F10%2F17%2Fpython%E8%B0%83%E7%94%A8mysql%2F</url>
    <content type="text"><![CDATA[PyMySQL一种用于连接mysql的三方库，其github地址在这，官方文档在这 要求CPython &gt;= 2.7 OR &gt;= 3.5 或者 PyPy最新版 mysql &gt;= 5.5 OR Mariadb &gt;= 5.5 使用 conn = pymysql.connect() 建立连接 123456789options:host=&apos;localhost&apos;port=3306db=&apos;db_hrs&apos;user=&apos;root&apos;passwd=&apos;123456&apos;charset=&apos;utf8&apos; 字符集设置autocommit=&apos;true&apos; 自动提交事务cursorclass=pymysql.cursors.DictCursor cursor = conn.cursor() 创建游标 cursor.execute(sql) 执行sql语句, 它返回的是影响后的行数 cursor.fetchone() 获取查询到下一条记录 cursor.fetchall() 获取查询到的全部结果行 cursor.fetchmany(size) 获得查询到的size条记录 conn.commit() 提交事务(若没有设置自动提交事务, 则需手动添加该语句) conn.rollback() 事务回滚 conn.close() 关闭连接 例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import pymysqlclass Dept(): def __init__(self, no, name, loc): self.no = no self.name = name self.loc = locdef main(): # 1.create db connection conn = pymysql.connect(host=&apos;localhost&apos;, port=3307, db=&apos;hrs&apos;, user=&apos;root&apos;, passwd=&apos;123456&apos;, charset=&apos;utf8&apos;, autocommit=&apos;true&apos;, cursorclass=pymysql.cursors.DictCursor) try: # 2. 获得游标对象 with conn.cursor() as cursor: # 3.向数据库服务器发出sql # result = cursor.execute(&apos;update tbdept set dname=%s, dloc=%s where dno=%s&apos;,(name, addr, no)) cursor.execute(&apos;&apos;&apos;select dno as no, dname as name, dloc as loc from tbdept&apos;&apos;&apos;) datas = cursor.fetchall() # 查3条记录 # datas = cursor.fetchmany(3) print(datas) # 方法 1 # for data in datas: # print(f&apos;部门编号:&#123;data[0]&#125;\n部门名称:&#123;data[1]&#125;\n部门地址:&#123;data[2]&#125;\n&apos;) # 方法 2 # for data in datas: # print(f&apos;部门编号:&#123;data[&quot;no&quot;]&#125;&apos;) # print(f&apos;部门名称:&#123;data[&quot;name&quot;]&#125;&apos;) # print(f&apos;部门地址:&#123;data[&quot;loc&quot;]&#125;&apos;) # print(&apos;-&apos;.ljust(30,&apos;-&apos;)) # 方法 3 for data in datas: dept = Dept(**data) print(dept.no, end=&apos; &apos;) print(dept.name, end=&apos; &apos;) print(dept.loc, end=&apos; &apos;) print() conn.commit() except pymysql.MySQLError: print(&apos;error&apos;) conn.rollback() finally: conn.close()if __name__ == &apos;__main__&apos;: main() SQLAlchemySQLAlchemy是Python SQL工具箱和对象关系映射器，为应用程序开发人员提供了SQL的全部功能和灵活性。 SQLAlchemy最著名的是对象关系映射器（ORM），它是提供数据映射器模式的可选组件，在该模式下，可以以开放式，多种方式将类映射到数据库，从而可以在数据库中开发对象模型和数据库模式。 使用sqlalchemy.create_engine(“mysql+pymysql://{A}:{B}@{C}:{D}/{E}?charset={F}”) A用户名 B密码 C地址 D端口号 E数据库 F字符集(utf8) 案例将大容量文件通过pandas快速读出来并转存到数据库中，注意需要安装库(sqlalchemy, pymysql,pandas) 12345678910111213141516from sqlalchemy import create_engineimport pandas as pdmnames = ['movieid', 'title', 'genres']unames = ['userid', 'gender', 'age', 'occup_id', 'zip_code']rnames = ['userid', 'movieid', 'rating', 'rtimestamp']movies = pd.read_table(r'D:\anaconda\datasets\movielens\movies.dat', sep='::', header=None, names=mnames, engine='python')users = pd.read_table(r'D:\anaconda\datasets\movielens\users.dat', sep='::', header=None, names=unames, engine='python')ratings = pd.read_table(r'D:\anaconda\datasets\movielens\ratings.dat', sep='::', header=None, names=rnames, engine='python')eg = create_engine("mysql+pymysql://root:123456@127.0.0.1:3306/dataset?charset=utf8")con = eg.connect()# movies.to_sql(name='tb_movies', con=con, if_exists='append', index=False)# users.to_sql(name='tb_users', con=con, if_exists='append', index=False)ratings.to_sql(name='tb_ratings', con=con, if_exists='append', index=False)]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用命令]]></title>
    <url>%2F2018%2F10%2F16%2Fwindows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[基础命令 cmd 命令提示符(command) mspaint 画图 osk 打开屏幕键盘(open screen keyboard) calc 打开计算器 (calculator) taskmgr打开任务管理器（task manager）与ctrl+windows delete相同 msconfig 打开系统配置 control 打开控制面板 explorer 打开文件资源管理器 相当于windows+E ver 显示Windows的版本号 services.msc 查看服务 Win命令 windows+d 最小桌面化 windows+e 打开资源管理器(我的电脑) windows+l 锁屏 windows+++++++ 放大镜(windows + ----还原) windows+x windows移动中心 windows+p 投影 windows+上下左右 分别实现窗口最大化/窗口最小化/窗口左布局/窗口右布局(窗口排版) windows+tab3D文件切换(win10中是虚拟桌面) windows+home 除当前窗口的其他所有窗口最小化 shift+windows+1~9 按编号启动底部工具栏(同时使用多次会出现窗口分身) windows+g 屏幕录制(win10有效) Dos命令文件命令 dir 列出当前目录下的文件夹 md 创建目录(make directory) rd 删除目录(remove directory) cd 改变目录(change directory) cd ..退后一级 cd \ 到根目录 d: 切换盘符 del 删除文件 type file 显示文件内容 exit 退出Dos命令 cls 清屏(clear screen) doskey /history 查看历史命令 参数命令 &lt;command&gt; /?或 help &lt;command&gt; 查看帮助 cmd /c 其他 直接运行命令后关闭cmd窗口 cmd /k 其他 直接运行命令后保留cmd窗口 参数命令的路径使用反斜杠\ ,同时若路径中出现空格, 要引起来,如del &quot;d:\program files\files\test.txt&quot; tree 目录 显示对应的目录的目录结构 chcp 改变代码页(默认936简体中文gbk编码) 12使用chcp 65001 可以将显示的编码转换为utf-8, 可以解决乱码问题chcp 437是美国英语编码 net start 查看有那些服务 1234net start 服务名 -- 开启服务net stop 服务名 -- 关闭服务net pasuse 服务名 -- 暂停服务net password 新密码 更改系统登录 ​ netstat -ano | findstr 8080 查看端口状态, 并且是和8080端口相关的内容(管道 findstr与linux中的grep功能一致)]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js之-Browser]]></title>
    <url>%2F2018%2F10%2F15%2Fjs%E4%B9%8B-Browser%2F</url>
    <content type="text"><![CDATA[DOM 节点DOM 为Document Object Model , 在html的DOM中, 每一个元素都是节点.文档是一个文档节点, 所有的HTML元素都是元素节点, 所有的HTML属性都是属性节点, 文本插入到HTML元素是文本节点, 注释是注释节点. 当浏览器载入HTML文档时, 它就会称为Document对象, Document对象是HTML文档的根节点.More请浏览菜鸟… Document对象改变HTML document.write 写HTML内容 获取元素对象 document.getElementById() 通过标签ID选择器获取标签 document.getElementsByTagName() 通过标签标签名列表获取标签 document.getElementsByClassName() 通过类选择器列表获取标签 document.querySelector() 通过选择器获取标签(可以是类,id等) document.querySelectorAll() 通过全部选择器的列表获取标签(可以是类,id等) 改变CSS通过获取的元素对象的style属性, 如elm.style.width=90px 改变元素属性通过获取的元素对象的某属性, 如elm.disabled=true , 表示elm元素节点不可用 事件 事件监听器 1document.getElementById(&quot;myBtn&quot;).onclick=function()&#123;displayDate()&#125;; 但是当多个div或者元素在同一个坐标重合出现, 就会出现事件冒泡现象.(它的意思是事件在子元素节点上触发后, 会在其父节点上触发, 由内向外的触发; 相对的还有事件捕获, 它是一种事件由外向内触发的机制) ​ 为了解决事件冒泡, 我们可以使用阻止事件来解决, 比如: 12evt.stopPropagation()阻止事件冒泡(子节点向父节点传播的现象)evt.cancelBubble = true;阻止事件传播(解决的ie的兼容性) 但是有更好的解决方式, 就是添加事件监听器elm.addEventListener(evt,func) , 它能帮助我们处理事件冒泡的现象. 注意: 在循环中, 对于多个标签, 不同通过下标取值, 而是通过evt.target获取触发当前事件的节点 计时器 通过计时器有效的控制事件发生的频次和时间.JavaScript中提供了两种计时器, 分别是setTimeout 和 setInterval 12myval = setTimeout(func(), time) time毫秒后发生myval = setInterval(func(),time) 每time毫秒发生 对应的有删除计时器的函数 12clearTimeout(myval)clearInterval(myval) 当我们使用匿名函数, 可以使用arguements.callee 它指向当前的函数, 就能实现递归. 节点 12345子节点children 父节点parentNode 兄弟节点previousSibling(前一个)/nextSibling(后一个) firstChild第一个子节点lastChild最后一个节点 增加节点 增加节点可以使用elm = document.createElement()创造标签(节点), 当有了elm节点后, 有两种方式可以将它插入document中 第一种, 使用elm.parentNode.appendChild(insert_elm)在某个节点之后插入节点 第二种, 使用elm.parentNode.insertBefore(insert_elm, target_elm) 在目标节点前插入节点 删除节点 删除节点请食用 elm.parentNode.removeChild(elm) 通过子节点的父节点删除子节点 修改节点 修改在内容属性 innerHTML – 获取html的标签和内容textContent – 获取文本内容(标签也会以文本获取)input标签的内容是value字段 修改节点的style属性 elm.style.width 大概就是这个形式, 注意它不能读只能写, 因此使用window.alert(elm.style.width) 是不能得到它的宽度. 要想读样式中的数据, 要通过document.defaultView.getComputedStyle(elm) 修改节点的其他属性 elm.&lt;property&gt; 直接通过得到的节点对象修改其属性 查看节点 直接通过elm.&lt;property&gt;进行读的操作 Jsonjson , 即JavaScript Object Notation, 是一种轻量级的数据交换格式。它现在被广泛用于数据的存储和传输. 原型对象func_name.prototype.&lt;property&gt; 能够通过实例化的对象去访问该属性 123456789实例:function Student(name,age)&#123; this.name = name; this.age = age;&#125;Student.prototype.study = function(courseName)&#123; alert(this.name + &quot;正在学习&quot; + courseName); &#125;var obj = new Student(&quot;1000phone&quot;,10); #实例化的对象 可以访问原型定义的属性 obj.study(&quot;PYTHON&quot;) JQuery介绍jQuery是一个 JavaScript 库。它帮助我们解决浏览器版本和浏览器种类带来的兼容性问题, 极大地简化了 JavaScript 编程。它的关键用法就是$的使用, 它就代表着jquery $四种用法 $函数的参数是个函数 1$(function()&#123;&#125;) 传入函数是页面加载完成之后要执行的函数(回调函数) $函数的参数是个选择器字符串 1$(&apos;#move&apos;) 获取页面上的标签并且将它转换成jQuery对象 $函数的参数是个标签 1$(&lt;li&gt;) -- 创建标签并且返回对应的jQuery对象 $函数的参数是原生JS对象 12 $(evt.target) -- 将原生js对象转换成jQuery对象-如果bar是一个jQuery对象可以通过bar[0] / bar.get(0) 在循环中可以通过下标去得到 相关属性和方法12345678910-绑定/反绑定事件: on() / off() / one()-获取/修改标签内容: text() / html() 不传参就是获取，传参就是提供内容-获取/修改标签属性: attr(name, value)-获取input标签的内容: val()-添加子节点: append() / prepend() -删除/清空节点: remove() / empty()-修改样式表: css(&apos;color&apos;)读样式 css(&#123;&apos;color&apos;:&apos;red&apos;,&apos;font-size&apos;:&apos;18px&apos;&#125;)修改多个样式-获取父节点: parent()-获取子节点: children()-获取兄弟节点: prev() / next() 下一个/上一个 AJAX介绍Ajax 即 Asynchronous Javascript And XML（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术. 它能够在无需重新加载整个网页的情况下，更新部分网页. getJSON方式1$.getJSON(api_url, function(jsonobj)&#123;&#125;) ajax方式123456789101112131415161718$.ajax(&#123; &quot;url&quot;:url, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&#123; &quot;key&quot;:&quot;bilibili&quot;, &quot;word&quot;:str &#125;, &quot;datatype&quot;:&quot;json&quot;, &quot;success&quot;:function(jsonobj)&#123; if(jsonObj.code == 200)&#123; //http状态码 200成功 250成功但是没有查到数据 $(&quot;#content&quot;).text(jsonObj.newslist[0].result) &#125;else&#123; $(&quot;#content&quot;).text(jsonObj.msg) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js&#39;s DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2F2018%2F10%2F15%2FMysql%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[数据库 数据库, 即DATABASE, 通过数据库我们可以实现数据的持久化 当我们左数据持久化操作是不仅仅是希望能够把数据长久的保存起来, 更重要的是便利的管理数据—方便的存取。 1970s IBM - 关系型数据库 12345理论基础: 关系代数和集合论具体表象: 用二维表来组织数据二维表: - 行, 即记录- 列, 即字段 SQL(Structure Query Language)结构化查询语言 12345678SQL对大小写不敏感SQL分为6个部分，分别为:- DQL数据查询语言(即数据检索select下的WHERE、order by、group by、having)，- DML数据操作语言(即INSERT、update、DELETE)，- TPL事务处理语言(即begin transaction开始事务,commit提交,rollback回滚)，- DCL数据控制语言(即grant授予，revoke撤销，确定对单个用户和用户组对数据库对象的访问)，- DDL数据定义语言(即CREATE创建表,DROP删除表和alter修改表,为表加入索引，保留字)，- CCL指针控制语言(即)。 SQL相关组成 1234DB - DATABASE 数据库DBMS - DATABASE Management System 数据库管理系统DBA - DATABASE Administrator 数据库管理员DBS - DATABASE System 数据库系统 图形化MySQL客户端工具 123- Navicat - 支持SQL- Toad - Oracle开发 DDL(define)数据库12345678910-- CREATE DATABASECREATE DATABASE IF NOT EXISTS db_student DEFAULT CHARSET utf8;-- DROP DATABASEDROP DATABASE IF EXISTS db_student;-- ALTER DATABASEALTER DATABASE db_student DEFAULT CHARACTER SET = utf8 DEFAULT COLLATE = utf8_general_ci; 数据表MySQL 5.5以上的版本，默认的数据库引擎为InnoDB，之前默认为MyISAM； 创建最好判断表不存在再创建表，使用IF NOT EXISTS 指定自动增加AUTO_INCREMENT的列，它必须是被索引的，通常就是主键 可省略部分:指定数据库引擎（默认为InnoDB），指定自增距离（默认1），字符集（默认latin1，不支持汉字）和排序规则（默认latin1_swedish_ci，不支持汉字），通常将字符集设置成utf8，其对应的排序规则就是utf8_general_ci(忽略大小写) 12345678CREATE TABLE IF NOT EXISTS tb_worker( w_id int(10) NOT NULL AUTO_INCREMENT, name varchar(10) NOT NULL, age int(4) NULL, gender varchar(6) DEFAULT &apos;MALE&apos;, PRIMARY KEY(w_id), CONSTRAINT fk_worker_detail FOREIGN KEY (w_id) REFERENCES tb_detail(d_id)) ENGINE=InnoDB AUTO_INCREMENT=2 CHARSET=utf8 COLLATE=utf8_general_ci; 更新123456-- 添加ALTER TABLE tb_worker ADD COLUMN tel char(11) NOT NULL;-- 删除ALTER TABLE tb_worker DROP COLUMN tel;-- 修改ALTER TABLE tb_worker MODIFY gender varchar(6) DEFAULT &apos;FEMALE&apos;; 删除 1234-- 删除表结构和数据DROP TABLE IF EXISTS tb_worker-- 只删除表数据，AUTO_INCREMENT计数归0truncate table tb_name; 重命名12345RENAME TABLE tb_worker TO tb_boss;-- 对多个表重命名RENAME TABLE tb_worker TO worker, tb_student TO student; TRUNCATE、DROP、DELETE123456-- 辨析DROP DELETE TRUNCATE区别-- TRUNCATE和DELETE只删除表数据不删除表结构，而DROP会删除表的数据和结构(约束、触发器、索引)-- TRUNCATE后自增字段计算归0，DELETE不会修改计算-- DELETE属于DML，删除后没提交事务可以回滚；TRUNCATE和DROP属于DDL，操作完即可生效-- 若要整理表内部的碎片，可以使用TRUNCATE+RESCUE STORAGE，再插入或导入数据-- 执行速度 DROP &gt; TRUNCATE &gt; DELETE DML(manlipulation)插入单条记录 1234567-- 插入完整的行INSERT INTO tb_student VALUES(2018001, &apos;王晗旭&apos;, 1, &apos;1995-10-10&apos;, &apos;中国大陆&apos;);-- 指定列进行插入INSERT INTO tb_student (stuid, stuname, gender) VALUES(2018002, &apos;卢姥爷&apos;, 1); 多条记录 1234INSERT INTO tb_student (stuid, stuname, gender) VALUES (2018003, &apos;卢姥爷&apos;, 1), (2018004, &apos;蛇姥爷&apos;, 1), (2018005, &apos;老姥爷&apos;, 1); 插入检索的数据 将一张表查询的结果作为插入数据，即INSERT SELECT 123INSERT INTO tb_student (stuid, stuname, gender)SELECT stuid, stuname, genderFROM tb_student2 更新使用更新一定不要忘记WHERE条件，否则会更新表中所有数据 123update tb_student set addr=&apos;Sichuan,China&apos;, gender=0 where stuid in (2018002, 2018003); 删除使用删除一定不要忘记WHERE条件，否则会删除表数据 1234567-- 删除一条记录delete FROM tb_student where stuid = 2018005;-- 删除多条记录delete from tb_student where stuid in (2018005, 2018006, 2018007); DQL(query)简单查询查询所有查询tb_name中的全部内容 SELECT* FROM tb_name; 别名别名式查询, 其中的as可以省略 123SELECT stuname AS 姓名, gender AS 性别 FROM tb_student;SELECT stuname AS 姓名, IF (gender, &apos;男&apos;, &apos;女&apos;) AS 性别 FROM tb_student;SELECT stuname AS 姓名, CASE gender WHEN 1 THEN &apos;男&apos; ELSE &apos;女&apos; END AS 性别 FROM tb_student; WHERE对表中的某列或某些列做处理或给定筛选条件, 再查询 注: &lt;&gt; 和 != 都是不等于 范围检查 1SELECT * FROM tb_student WHERE stuid between 2018001 and 2018010; 查询2018001和2018010之间的所有记录 空值检查 12SELECT * FROM tb_student WHERE ADDr is NULL; -- 查询ADDr为空的所有记录SELECT * FROM tb_student WHERE ADDr is NOT NULL; -- 查询ADDr不为空的所有记录 匹配检查和不匹配检查 123SELECT * FROM tb_student WHERE stuid &gt; 2018001 and gender = 0; -- 查询满足所有条件的记录SELECT * FROM tb_student WHERE stuid &gt; 2018001 or gender = 0; -- 查询满足至少一个条件的所有记录SELECT * FROM tb_student WHERE stuid &lt;&gt; 2018001; LIKE模糊查询 1234-- 使用%时，只有放在最后才能命中索引SELECT * FROM tb_student WHERE stuname like &apos;%姥爷%&apos;; -- %表示0个或多个字符, 查询字段中有&apos;姥爷&apos;的所有记录SELECT * FROM tb_student WHERE stuname like &apos;_姥爷&apos;; -- _表示一个字符, 查询所有一个字符后&apos;姥爷&apos;的所有记录 ORDER BY排序123456SELECT * FROM tb_student order by stuid; -- 升序查询所有记录SELECT * FROM tb_student order by stuid desc; -- 降序查询所有记录SELECT * FROM tb_student order by gender, stuid desc; -- 先按gender升序排, 对相同的记录再按stuid降序排列所有记录SELECT * FROM tb_student WHERE gender = 0 order by stuid; -- 先筛选再排序, 列出所有记录 LIMIT OFFSET分页limit限制查询结果的数量 123SELECT * FROM tb_student limut 3; 查询3条记录SELECT * FROM tb_student limit 3 offset 6; 跳过6条记录在查询3条记录等价于 SELECT FROM tb_student limit 6, 3; 跳过6条记录在查询3条记录(从第7条开始) null查询空内容的记录 123# 同时判断条件 null 和 &apos;&apos;# 注意null和空字符串的区别，前者不占空间后者占有空间，即一个真空的杯子和一个装满空气的杯子SELECT sname &apos;学生姓名&apos; FROM tb_student WHERE ADDr is null or ADDr = &apos;&apos;; DISTINCT去重123456789SELECT distinct seldate as &apos;去重后日期&apos; FROM tb_score;对比:-- 去重运算(distinct)和集合运算(in/NOT in) 效率很低-- 通常建议使用EXISTS或NOT EXISTS替代# distinctSELECT ename, job FROM tbemp WHERE eno in (SELECT distinct mgr FROM tbemp WHERE mgr is NOT null);# WHERE EXISTSSELECT ename, job FROM tbemp t1 WHERE EXISTS (SELECT &apos;f&apos; FROM tbemp t2 WHERE t1.eno=t2.mgr); 聚合函数利用标准的算术操作符，所有聚集函数都可用来执行多个列上的计算。 12345678910AVG() 返回某列的平均值 -- AVG()函数忽略列值为NULL的行。COUNT() 返回某列的行数-- count(*)对所有行进行技术 count(column)对特定行计数并且会忽略NULL值MAX() 返回某列的最大值-- 虽然通常都查找最大的数值和时间，但是也可以用于比较字符(注意字符的比较方式是按位进行utf8编码的比较)，MAX()函数忽略列值为NULL的行。MIN() 返回某列的最小值-- 与MAX一样，它也会按位比较，同时忽略值为NULL的行SUM() 返回某列值之和-- SUM()函数忽略列值为NULL的行。 GROUP BY分组通常聚合函数和分组group by是联合使用 其置于WHERE之后，ORDER_BY之前 1SELECT sid as &apos;学号&apos;, avg(mark) as &apos;平均成绩&apos; FROM tb_score group by sid; HAVING集合通常若使用having的字段必须在出现在前面的查询的字段中, 而WHERE不能解决对表筛选后再次筛选的目的。（WHERE用于过滤字段，而HAVING用于过滤分组） 12345# WHERE 在group by(或order by)前查询# having在group by(或order by)后查询SELECT sid FROM tb_score group by sid having count(sid)&gt;2- 在tb_score表中,根据学生id(sid)进行分组查询学生id(sid).再进行sid出现次数大于2的记录SELECT ename, sal FROM TbEmp WHERE sal&gt;(SELECT avg(sal) FROM TbEmp) ; CONCAT拼接把多个串连接起来形成一个较长的串 1SELECT concat(stuname,&apos;: &apos; , ADDr) as 信息 FROM tb_student WHERE gender = 0; -- 将stuname和ADDr字段连接起来再查询 子查询所谓子查询就是将一条查询语句的结果用于另一条查询语句的WHERE子句 子查询可以无限嵌套，其查询顺序是由内向外的；但是过多的嵌套会严重影响查询性能，以此并不推荐 查询结果作为计算字段123456SELECT sname as &apos;姓名&apos;, (SELECT sid FROM tb_score group by sid having count(sid)&gt;2) as &apos;new_id&apos;FROM tb_student 查询结果作为WHERE子句 12345678910# 筛选的字段也是通过查询获取的# 字段=值SELECT sname FROM tb_student WHERE birth=(SELECT min(birth) FROM tb_student);# 字段 in TABLESELECT sname as &apos;姓名&apos; FROM tb_student WHERE stuid in (SELECT sid FROM tb_score group by sid having count(sid)&gt;2); 连接查询INNER JOIN ON 内连接1234SELECT sname, cname, mark FROM tb_student inner join tb_score on stuid=sid inner join tb_course on cid=couid WHERE mark is NOT null; # 等价于SELECT sname, cname, mark FROM tb_student, tb_course, tb_score WHERE stuid=sid and couid=cid and mark is NOT null; -- 将两张表均满足条件的筛选出来 LEFT/RIGHT JOIN ON左外连接/右外连接(mysql不支持全外连接) 123456SELECT sname, num FROM tb_student as tb1 inner join (SELECT sid, count(cid) as num FROM tb_score group by sid) as tb2 on tb1.stuid = tb2.sid;SELECT sname, num FROM tb_student as tb1 left join (SELECT sid, count(cid) as num FROM tb_score group by sid) as tb2 on tb1.stuid = tb2.sid;-- 左外连接 把右表(写在前面的表)不满足连接条件的记录在对应位置记录补上NULL(即含有左表全部记录)-- 右外连接 把左表(写在前面的表)不满足连接条件的记录在对应位置记录补上NULL(含有右表全部记录)-- 全连接, 两边均进行匹配, 互相没有匹配到的项用NULL代替 组合查询所谓组合查询即将两个或多个查询语句组合在一起，且只返回他们的并集（组合查询要求必须相同的列、条件表达式或聚集函数） UNION组合查询，对于组合后的记录会自动删除重复的记录；UNION能做的事情，其实使用WHERE条件也能做到 123456-- (对于一张表的组合查询完全可以使用union代替，意义不大)select * from tb_student where score &gt; 50 union select * from tb_student where subject=&apos;math&apos;select * from tb_student where score &gt; 50 or subject=&apos;math&apos;-- 有意义的场景，对于装有海量的数据的两张字段相近（union要求列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型，如不同的日期类型）的表进行合并组合查询select * from product_a where time &gt; &apos;2013-01-12&apos; union select * from product_b where date &gt; &apos;2013-01-12&apos; 组合查询UNION使用ORDER BY，只能使用一次排序，并且只能对最后一个SELECT语句使用 UNION ALL组合查询，对于组合后的记录会保存重复的记录，这是WHERE子句做不到 数据处理函数聚合函数也属于这部分内容，上面可见 文本处理1234567891011121314-- Left() 返回串左边的字符-- Length() 返回串的长度-- Locate() 找出串的一个子串-- Lower() 将串转换为小写-- Upper() 将串转换为大写-- LTrim() 去掉串左边的空格-- RTrim() 去掉串右边的空格-- Right() 返回串右边的字符-- Soundex() 返回串的SOUNDEX值 匹配与str发音相似的记录SELECT * FROM tb_moviesWHERE SOUNDEX(title) = SOUNDEX(&apos;Balto&apos;);-- 结果返回 Balto 和 Blade 两个结果-- SubString() 返回子串的字符 时间日期Mysql提供的日期处理格式为yyyy-mm-dd 1234567891011121314151617AddDate() 增加一个日期（天、周等）AddTime() 增加一个时间（时、分等）CurDate() 返回当前日期CurTime() 返回当前时间Date() 返回日期时间的日期部分DateDiff() 计算两个日期之差Date_Add() 高度灵活的日期运算函数Date_Format() 返回一个格式化的日期或时间串Day() 返回一个日期的天数部分DayOfWeek() 对于一个日期，返回对应的星期几Hour() 返回一个时间的小时部分Minute() 返回一个时间的分钟部分Month() 返回一个日期的月份部分Now() 返回当前日期和时间Second() 返回一个时间的秒部分Time() 返回一个日期时间的时间部分Year() 返回一个日期的年份部分 数值计算123456789Abs() 返回一个数的绝对值Cos() 返回一个角度的余弦Exp() 返回一个数的指数值Mod() 返回除操作的余数Pi() 返回圆周率Rand() 返回一个随机数Sin() 返回一个角度的正弦Sqrt() 返回一个数的平方根Tan() 返回一个角度的正切 约束(constraint)外键即foreign key 123456789# 创建外键前要在表中加入外键对应的字段# alter TABLE tb_name ADD column tb_field;alter TABLE tb_student ADD column clg_id int;# 创建外键约束alter TABLE tb_student ADD constraint fk_clg2stu foreign key(clg_id) references tb_college(clg_id); # 删除外键约束alter TABLE tb_student DROP foreign key fk_clg2stu; 唯一约束(unique)1234# 创建唯一约束alter TABLE tb_college ADD constraint unique_clg_site unique(clg_site);# 删除唯一约束alter TABLE tb_college DROP index unique_clg_site; 非空约束(NOT null)12345# 修改成非空约束alter TABLE tb_name modIFy col_name col_type NOT null;# 删除也是通过修改alter TABLE tb_name modIFy col_name col_type; 默认值约束(default)12345# 修改成默认值约束alter TABLE tb_name modIFy col_name col_type default df_value;# 删除也是通过修改alter TABLE tb_name modIFy col_name col_type; 主键约束(primary key)1234567# 添加主键约束alter TABLE tb_name ADD primary key(col_name);# 删除主键约束## 若有自动增长类型, 要先去除, 再删除主键;若没有, 直接删除主键(因为自动增长是依托于主键的)alter TABLE tb_name modIFy col_name int;alter TABLE tb_name DROP primary key 数据完整性(data integrity)实体完整性(entity)每一条记录都是独一无二的,没有冗余 – 依托于主键PRIMARY KEY/唯一约束UNIQUE 参照完整性(referential)B表参照A表, A表没有的数据B表绝对不能出现 – 依托于外键FOREIGN KEY 域完整性(domain)录入的数据都是有效的 – 依托于数据类型 / 非空约束NOT NULL/ 默认值约束DEFAULT/ 检查约束(可以写入, 但是在mysql`中不生效) 数据一致性(data consistency)事务12345678910111213141516171819数据库在出现并发事务访问数据时, 数据库底层有锁机制来保护数据;但是通常我们书写SQL的时候不会显示锁, 数据库会根据我们设定的事务隔离级别自动加锁。事务隔离级别(由低到高)Read Uncommited 读未提交的数据Read Commited 读提交的数据RepeaTABLE Read 可重复读Serializable 串行化修改事务隔离级别:set session/global transaction isolation level 级别字段;查询事务隔离级别:SELECT @@tx_isolation;并发数据访问可能出现的问题:第1类丢失更新第2类丢失更新脏读 -- 一个事务读取到另外一个事务尚未提交的数据不可重复读 -- 一个事务正在查询的时候发现其他事务更新了数据导致无法查询幻读 -- 一个是事务在执行查询的时候被其他事务提交了新的数据 DCL(control)用户管理查询用户MySQL数据库将用户数据存储到mysql库下的user表中，可以查询到所有用户(root用户才能查询) 12USE mysql;SELECT user FROM user; 创建用户虽然也可以直接使用UPDATE和INSERT语句对user表进行操作，直接更新和插入，但是为了安全性，不建议这样使用。 123456CREATE USER username IDENTIFIED BY &apos;password&apos;;-- %表示任意地址, 也可以直接指定地址, 本地地址可以是localhost或128.0.0.1CREATE USER &apos;cuser&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;; -- 重命名一个用户账号RENAME USER username TO another_username; 删除用户1DROP USER username; 更改口令SET PASSWORD更新用户口令，新口令必须传递到Password函数进行加密 12345-- 修改username用户的口令SET PASSWORD FOR username=Password(&apos;new_password&apos;);-- 修改自身的口令SET PASSWORD=Password(&apos;new_passwd&apos;) 授权(grant)123456789101112-- src为数据库名，第一个*的位置表示库名，第二个表示表名-- 若为*.* 即是所有数据库中所有资料-- 授予特定的权限GRANT SELECT ON srs.* TO &apos;cuser&apos;@&apos;%&apos;;GRANT INSERT, DELETE ON srs.* TO &apos;cuser&apos;@&apos;%&apos;;GRANT CREATE, DROP, alter ON srs.* TO &apos;cuser&apos;@&apos;%&apos;;-- 授予cuser关于srs数据库的所有权限GRANT ALL PRIVILEGES ON srs.* TO &apos;cuser&apos;@&apos;%&apos;;-- 授予cuser关于srs数据库的所有权限且还能授权给他人GRANT ALL PRIVILEGES ON srs.* TO &apos;cuser&apos;@&apos;%&apos; WITH GRANT OPTION; 召回(revoke)12-- 召回所有权限REVOKE ALL PRIVILEGES ON srs.* FROM &apos;cuser&apos;@&apos;%&apos;; TPL(transaction processing)事务控制 begin | start transaction 开启事务 commit 事务提交, 要全部任务成功执行则提交 rollback 事务回滚, 只要存在任务失败则回滚 事务的ACID的特性1234Atomicity原子性 全做或全不做Consistency 一致性 事务前后数据状态一致Isolation 隔离性 并发的事务互不干扰Duration 持久性 事务完成后数据要持久化(一旦提交永久保存) 使用123456789-- 事务开启begin;# or start transactionupdate tb_score set mark=mark+2 WHERE sid=1001;update tb_score set mark=mark+2 WHERE sid=1002;-- 事务提交commit;-- 事务回滚rollback; 视图(view)概念123456789-- 视图是虚拟表，本身不存储数据，而是按照指定的方式进行查询。也可以说视图是查询的快照。(视图虚拟表)-- 权限控制时将用户对表的访问权限,限制到对指定列的访问。可以通过给定查询视图的权限,而不给查询表的权限来实现。(保护数据)-- 对创建好的视图, 可以通过查询语句直接使用视图-- 视图能够简化复杂的SQL操作，但是它本身不会提高查询速度（不提高查询速度）-- 视图可以嵌套，可以和普通表一起使用，但是不能使用索引；其可以使用ORDER BY，但若SELECT中也含有ORDER BY，视图中的会被覆盖 使用12345# CREATE view view_name as SELECT ...CREATE view view_tbemp as SELECT * FROM tbempSELECT * FROM vw_tbemp; 索引概念1234567891011-- 索引相当于图书的目录-- 为表创建索引而达到加速查询就是典型的(牺牲空间换取时间)-- 索引会使增删改变慢, 不能滥用, 其原因是增删改操作可能导致所以索引的更新-- 通常将索引建在经常被查询的字段上-- 主键默认唯一索引-- 使用EXPLAIN命令可以查询索引命中情况 使用1234567891011121314151617-- 对于模糊索引, 若它以%开头,索引失效; 若它不以%开头,索引有效(下划线_有效)-- 创建索引CREATE INDEX ix_emp_name ON tb_emp(name);-- 创建唯一索引CREATE UNIQUE INDEX ux_emp_name ON tb_emp(name);-- 添加索引ALTER TABLE tb_name ADD INDEX ix_emp_name(name);-- 添加关键字索引(即主键)ALTER TABLE tb_name ADD PRIMARY KEY(id);-- 添加唯一索引ALTER TABLE tb_name ADD UNIQUE ux_emp_name(name);-- 添加全文索引ALTER TABLE tb_name ADD FULLTEXT ft_name(name);-- 删除索引ALTER TABLE tb_name DROP INDEX ux_emp_name; 存储过程介绍MYSQL 5.0版本开始支持存储过程 存储过程(stored procedure)是将特定功能的SQL语句集，经过编译保存在数据库中，可以说是一种建立在数据库服务器上的程序 调用方式与普通SQL语句大不相同 优缺点优点 可通过封装，隐藏复杂的商业逻辑 可以传参和回传值 可以用在数据检验，强制实行商业逻辑 缺点 定制化于数据库，受限于数据库语言类型 性能调试受限于数据库系统 使用 存储过程中传参可以使用INT输入参数 OUT输出参数 INOUT输入输出参数 1234567891011121314-- 改变语句的结束符号为$$ $$可以自定义delimiter $$CREATE PROCEDURE proc_delete_stu(IN @in_stuid INT)BEGIN DELETE FROM tb_student WHERE stuid = in_stuidEND $$-- 恢复语句的结束符号(即;)delimiter;-- 使用(删除stuid为20的学生记录)call proc_delete_stu(20); 全文本搜索(全文索引)理解在使用全文本搜索时，MySQL不需要分别查看行，它会在指定列的每个词创建一个索引，并且随着数据的更新(增删改)，MySQL会自动更新索引。 全文本搜索功能与数据库引擎相关，MyISAM支持，而InnoDB在MySQL5.6以下不支持。 全文本搜索对指定列的索引进行搜索后，对查询到的结果会按照相应的优先级排序列出，这也是它由于LIKE或者正则表达式的一个方面。 全文本搜索时基于英文的空格和标点区分每个词汇，它不能处理中文。 由于全文本搜索是基于索引的，因此它通常搜索速度较快 查询在创建表时指定全文本搜索功能，使用FULLTEXT关键字 1234567891011-- 搜索引擎为MyISAMCREATE TABLE tb_stu( id int(10) NOT NULL AUTO_INCREMENT, name varchar(10) NOT NULL, desc_text text, FULLTEXT(desc_text), PRIMARY KEY(id))ENGINE=MyISAM;-- 添加全文索引ALTER TABLE tb_stu ADD FULLTEXT ft_desc_text(desc_text); 查询支持全文本搜索功能的表，使用Match和Against函数 123SELECT name desc_text FROM tb_stu WHERE Match(desc_text) Against(&apos;wonderful&apos;); 如果需要查询指定列去查询优先级(通常匹配词越靠前的列其优先级高，当然也与匹配词数量、列长度等有关) 123-- priority 会以浮点数显示，比较大小就知道优先级SELECT desc_text, (Match(desc_text) Against(desc_text)) AS priorityFROM tb_stu; 除此，全文本搜索也可以指定多个列(通常匹配词越多优先级越高) 查询扩展查询扩展会设法放宽返回的全文本搜索结果的范围，除开全文本搜索匹配词查询结果，它还会返回认为有用的词。 它对数据和索引进行两遍扫描进行搜索: 123- 进行基本的全文本搜索，找出与搜索条件匹配的所有行- MySQL检查匹配行并选择认为有用的词- 再次进行全文本搜索，根据搜索条件和有用的词为条件 使用 WITH QUERY EXPANSION 123SELECT name desc_text FROM tb_stu WHERE Match(desc_text) Against(&apos;wonderful&apos; WITH QUERY EXPANSION); 查询扩展会极大增加返回的结果，但是可能它并不是想要的结果。 布尔文本搜索用户管理数据库引擎InnoDB和MyISAM比较InnoDB和MyISAM 前者支持事务，后者不支持(mysql5.5后默认为InnoDB) MyISAM的读性能比InnoDB好，而InnoDB更善于写操作 MyISAM支持全文本搜索，InnoDB不支持(MySQL5.6以后支持) 创建和修改12345678-- 创建CREATE TABLE tb_stu( id int(10) NOT NULL, name varchar(10))ENGINE=MyISAM;-- 修改ALTER TABLE tb_stu ENGINE=InnoDB; 其他数据闪回 美团提供]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之-Window]]></title>
    <url>%2F2018%2F10%2F13%2FJS%E4%B9%8B-Window%2F</url>
    <content type="text"><![CDATA[navigator对象 属性 1.appCodeName -- 返回浏览器的代码名 Mozilla 2.appName -- 返回浏览器的名称 Netscape 3.appVersion -- 返回浏览器的平台和版本消息 4.cookieEnabled -- 启用cookie 5.platform -- 硬件平台 win32 6.userAgent --用户代理 7.systemLanguage -- 用户代理语言 浏览器版本黑历史:) 12345678910111213141516 Mosaic(马赛克)，最早的浏览器 Mozilla(魔斯拉)(意为Mosaic杀手) -- 后改名为Netscape Mozilla/1.0(Win3.1)，由于网景支持框架，而框架被大众喜爱，网站管理员探测userAgent时对Mozilla浏览器发送有框架的页面，对非Mozilla的浏览器发送没有框架的页面。网景拿微软寻开心，称微软是&quot;没有调试过的硬件驱动程序&quot;，微软很生气，开发了自己的浏览器。 微软 IE(Internet Explorer)--IE也支持框架，但它不是Mozilla，总是收不到含有框架的网页， 又等不及所有的网站管理员去了解IE，就宣布IE是兼容Mozilla的，并模仿Netscape，自称Mozilla/1.22(compatible; MSIE 2.0; Windows 95)，于是IE就能接受所有的含有框架的网页，微软开心了，网站管理员崩溃了。微软和Netscape的大战，由于微软的捆绑销售等原因，Netscape退出历史舞台。 FireFox火狐--Netscape以MOzilla的名义，开发了Gecko，它的渲染引擎很出色，Gecko变得出色，其他浏览器使用它的代码，并伪装成Mozilla，但是却使用Gecko。userAgent的探测规则偏向Gecko Linux下的conqueror -- 引擎是KHTML，但因为不是Gecko得不到好的页面，将自己伪装成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko) Opera欧朋 -- 跳出来说应该让用户决定想让我们伪装成什么浏览器。给定三个选项，“Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51”==IE或者“Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51”==火狐， 或者“Opera/9.51 (Windows NT 5.1; U; en)==欧朋 Safari苹果 -- 使用KHTML作为渲染引擎，后来基于KHTML另开辟分支WebKit，又不想抛弃哪些KHTML的页面，就自称Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5 chorme谷歌 --使用Webkit作为渲染引擎，它想要哪些Safari的页面，于是它伪装成Safari.Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36 于是Chrome使用WebKit，并将自己伪装成Safari，WebKit伪装成KHTML，KHTML伪装成Gecko，最后所有的浏览器都伪装成了Mozilla，这就是为什么所有的浏览器User-Agent里都有Mozilla。 Screen对象 123width/height --屏幕宽度/高度availWidth/availheight 可用宽度/高度 (如屏幕底部的状态栏就不含在可用高度内)colorDepth/pixelDepth -- 颜色深度/颜色分辨率 ，其实是一个意思，但是主流服浏览器多用前者 History 对象 属性 length 返回历史记录的地址数 方法 123back()加载history列表中的前一个url 》》 加载时只能加载当前标签对应的history列表，而不是整个历史记录forward() 加载history列表中的后一个urlgo(num) 加载到history列表中的第num个页面(以当前来看) -- go(0)就是刷新页面 Location对象 URL Uniform Resource Locator, 即统一资源定位符 属性 12345678hash -- 返回一个url的锚部分 -- 即是url中#后的部分。通常用于&lt;a name=&quot;location&quot;&gt;&lt;/a&gt;标记去向的位置；使用&lt;a href=&quot;#location&quot;&gt;&lt;/a&gt;可以直接转到指定的位置 。并且#后数据用于位置标识，在服务端没有作用。 但是改变#后值会增加增加一条历史记录到列表中，可以使用history加载)search -- 返回url的查询部分 即是?号之后的部分host -- 返回对应url的主机名和端口号（若端口号是80http 、443https，不会返回端口号）hostname -- 返回对应的url的主机名href -- 返回对应url的完整URLpathname -- 返回url路径名 即主机名之后的部分port -- 返回url的端口号 (若是80端口返回空串)protocol -- 返回url的协议(http/https/ftp ...) 关于hash部分的锚点, 详细请看锚点讲解 方法 123assign -- 加载一个文档 location.assign(url)reload -- 重新加载当前的文档，绕过缓存，重新在服务器上加载数据 与ctrl shift R相同 (若有post提交数据，也会重新提交)replace --替换到一个新文档中 location.replace(url) (网上说replace后的新页面会取代原网页的窗口，不能返回到上一个记录，但是好像可以。。。好像和assign功能上没什么不一样) 注: 以上实验在chorme上进行的. 弹窗 alert() 警告框, 可以提示内容 confirm() 确认框, 有确认和取消按钮 prompt() 提示框, 通常提示用户输入怎样的值 close() 关闭窗口 获取标签 document.getElementById() 通过标签ID选择器获取标签 document.getElementsByTagName() 通过标签标签名列表获取标签 document.getElementsByClassName() 通过类选择器列表获取标签 document.querySelector() 通过选择器获取标签(可以是类,id) document.querySelectorAll() 通过全部选择器的列表获取标签(可以是类,id) instances: 12345var h1 = document.getElementById(&quot;message&quot;); var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]var h1 = document.getElementsByClassName(&quot;msg&quot;)[0]var h1 = document.querySelector(&quot;#message&quot;)var h1 = document.querySelectorAll(&quot;#message&quot;)[0] 计时器 setInterval 设置计时器 setinterval(function, interval_time) 设置一个计时器, 它每隔interval_time的时间执行一次function函数, interval_time的时间单位是毫秒 删除计时器 在设置计时器的时候, 将计时器函数赋给一个变量, 如 var myVar =setInterval(func,1000), 当需要解除计时器的时候, 使用clearInterval(myVar) 即可. setTimeout 设置计时器setTimeout(function, timeout_time) 设置一个计时器, 它在timeout_time时间结束后执行function函数, timeout_time的时间单位是毫秒 删除计时器 在设置计时器的时候, 将计时器函数赋给一个变量, 如 var myVar =setTimeout(func,1000), 当需要解除计时器的时候, 使用clearTimeout(myVar) 即可.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js&#39;s BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识JS]]></title>
    <url>%2F2018%2F10%2F13%2F%E5%88%9D%E8%AF%86JS%2F</url>
    <content type="text"><![CDATA[js概要 JavaScript与java 123456JavaScript 与 Java 是两种完全不同的语言，无论在概念上还是设计上。Java（由 Sun 发明）是更复杂的编程语言。ECMA-262 是 JavaScript 标准的官方名称。JavaScript 由 Brendan Eich 发明。它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ECMA（一个标准协会）采纳。 JavaScript 是互联网上最流行的脚本语言, 对于网页来说, 它负责事件和渲染部分。因此通常我们将它放在网页的最后部分。 JS由ECMAScript + BOM + DOM 三部分组成 ECMAScript ,ECMA(European Computer Manufactures Association 欧洲电脑制造商协会)。它定义了JavaScript的标准, 现在我们大都使用ECMAScript 5.1，在ECMAScript 6以后添加了类和模块 BOM 是浏览器对象模型 对应window对象 DOM 是 文件对象模型 对应document对象 js基础 注释 单行注释使用// 多行注释使用/* */ 标识符 12341.要求是由数字、字母、下划线和$组成 2.对大小写敏感3.使用驼峰式命名, 不能是js中的关键字, 见名知意instance: var abc , var $12c 基本数据类型 123456789Number 数字类型(包含所有数字, 不支持复数) +12.2 10e2Boolean 布尔类型 true falseString 字符串 &apos;如果有来生&apos; &quot;apple&quot; 单双引号皆可Array 数组 [1,&apos;abc&apos;,true]Object 对象 &#123;a:100, name:&apos;张德帅&apos;,age:20&#125;特殊类型:NaN 不存在的数字null 空,一般用来清空变量的内容 underfined 变量没有赋值或没有结果时 js语句 12#1.一条语句结束后可以写分号，也可以不写,但是提倡写,便于js的压缩。如果一行有多条语句，必须写分号#2.js没有缩进语法的要求，需要使用代码块的时候使用大括号 变量 1231.变量声明: var 变量名 或 var 变量名 = 初值2.初值可有可无3.变量要声明再使用 运算符 123456数学运算符 + - * / % （**,js7）++ --比较运算符 &gt; &lt; = == != &gt;= &lt;= ===(完全相等) !== &gt;== &lt;==- ==只判断值相等 2 == &apos;2&apos; //true- ===类型和值都要相等逻辑运算符 &amp;&amp;与 ||或 !非三目运算符 表达式1？值1:值2 判断表达式，如果为真返回值1，否则返回值2 分支结构 1234567891011#if语句- if- if-else- if-else if-else#switch语句switch(表达式)&#123; case 值1: 代码段 break case 值2: 代码段 break ... default:代码段&#125; 循环结构 12345678910111213#for-in循环for(var 变量 in 序列)&#123;循环体&#125;#for循环for(表达式1:表达式2:表达式3)&#123;循环体&#125;#while循环while(条件语句)&#123;循环体&#125;#do-while循环do&#123;循环体&#125;while(条件语句) 函数 123456789function 函数名(参数列表)&#123; 函数体&#125;注:function:js中声明函数的关键字;函数名:标识符，不能是关键字,见名知意参数列表:形参js不能同时返回多个值js中函数能够作为变量 instance： var fn = function(参数列表) &#123;函数体&#125;js中函数能够作为参数或者返回值 ##]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷酷的aview]]></title>
    <url>%2F2018%2F10%2F12%2F%E9%85%B7%E9%85%B7%E7%9A%84aview%2F</url>
    <content type="text"><![CDATA[安装AAlibAA(Ascii Art),AAlib是一个便携式ascii艺术GFX库(GFX lib是一个小型的C库，用于开发针对伟大的MSX计算机的图形应用程序) aalib-1.2的最新版本是1.4, 但是后续安装bb是基于1.2的, 因此要先安装1.2的版本. 安装AAlib之前需要安装gcc和libtool,可以通过yum install xx直接安装. aalib-1.2默认安装在/usr/local下面 1234567891011121314#1 下载aalib-1.2wget http://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz#2 解压缩gunzip aalib-1.2.tar.gz#3 解归档tar -xvf aalib-1.2.tar#4 对安装的软件进行配置,检查依赖关系./configure#5 编译安装make &amp;&amp; make install (先执行make, 在执行make install) 出现的问题: 12345678ltconfig: you must specify a host type if you use `--no-verify&apos;Try `ltconfig --help&apos; for more information.configure: error: libtool configure failed出现这样的问题,其实是配置时不能识别系统类型,需要自己指定主机类型.解决方法是将下述的两个文件覆盖带/aalib-1.2/下面. (下述 . 指当前文件夹下)cp /usr/share/libtool/config/config.guess .cp /usr/share/libtool/config/config.sub . 安装bbbb是一种图形演示程序,它需要AAlib库 12345678910111213141516171819#1 下载bb源文件wget http://prdownloads.sourceforge.net/aa-project/bb-1.2.tar.gz#2 解压缩gunzip bb-1.2.tar.gz #3 解归档tar -xvf bb-1.2.tar #4 配置环境变量,使bb能找到AAlibexport CFLAGS=-I/usr/local/include#5 配置cd bb-1.2./configure注: 配置会出错,因为textform.c文件中很多位置缺少结束字符&quot; ,只要将报错的地方全部使用 &quot;&quot; 将之引起来就好了。(仿照正确的地方的格式)#6 编译生成可执行文件bbmake 安装aviewaview是一款高质量的图像(pnm)浏览器和动画(fli/flc)播放器，以ASCII-art方式输出。它是使用AA-lib实现的。 它提供了一个asciiview的脚本，利用convert转换图片格式，然后再传递给aview. aview是依赖aalib-1.4，因此需要先安装aalib-1.4, 安装方式与aalib-1.2相同, 链接https://downloads.sourceforge.net/aa-project/aalib-1.4rc5.tar.gz 123456789101112131415#1 安装aviewwget http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gz#2 解压缩gunzip aview-1.3.0rc1.tar.gz #3 解归档tar -xvf aview-1.3.0rc1.tar #4 配置cd aview-1.3.0./configure#5 编译安装make &amp;&amp; make install 安装ImageMagickImageMagick介绍在此http://www.imagemagick.org/script/index.php 它可以直接通过yum安装 try在此,应该是将所有软件安装完毕, 随便在浏览器上扣一张图,使用命令acsiiview 图片路径效果如下: 原图 ascii图 注: 上述使用linux的发行版本为CentOS 6.x。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>aview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2018%2F10%2F11%2Flinux%2F</url>
    <content type="text"><![CDATA[下述所有内容是以linux发行版本是CentOS7.3下的 命令基础命令最重要的命令：查看命令手册 man 命令 查看指定命令的手册(manual手册) info 命令 查看命令的手册(以coder的角度) 命令 --help 查看指定命令的help 查找相关命令(whereis、which、find、locate、type) whereis [options] file搜索二进制文件(-b)、源代码文件(-s)、说明文件(-m)。若省略参数返回所有信息 which [options] COMMAND 在环境变量PATH指定的路径中搜索指定的系统命令的位置(例如: which python3找到该命令的位置) find 文本管理文件管理权限管理压缩解压磁盘管理系统状态 who 显示当前连接服务器的所有用户信息 who am i 显示当前连接服务器用户的详细信息 whoami 显示当前用户名 ps 显示所有进程 1ps -ef 查看进程 kill pid 杀死指定id的进程 1kill -9 pid 强行杀死指定id的进程 用户管理 adduser username 添加新的用户 passwd username 为指定的用户建立密码(若是root用户, 可以修改任何用户的密码 userdel username 删除用户 userdel -r username 删除用户及其用户主目录(recursive递归的) userdel -f username 强制删除用户(force强制) su username 切换用户(switch user) tab制表键 自动补全 pwd 查看工作目录(print work directory) cd 或 cd~ 返回到当前目录的主目录 cd /directory 绝对路径的方式改变当前目录 cd directory 相对路径的方式改变当前目录 wget 联网下载 cat filename 连接多个文件并查看文件内容(concatenates) history 查看历史命令 history -c 清除历史命令 ! historyid 执行历史命令编号的命令 pwd 打印当前工作目录(print name of work directory) ls 列出文件 123-a 显示隐藏文件-l 长格式显示文件-R 递归显示文件 alias newname = &quot;命令&quot; 将一个命令起一个别名 12alias rmd = &quot;rm -rf&quot; 使rmd称为直接强制删除的命令别名unalias rmd 取消所起的别名 rmdir 移除空目录(remove directory) mkdir 创建目录 (make directory) cp 拷贝文件 mv 剪切文件或文件夹 12mv index.html new.html 更改文件index.html为new.htmlmv index.html /abc/rz 剪切index.html到/abc/rz的目录下 rm 删除文件或目录 1234rm -f 直接删除指定的文件或目录rm -r 递归式的删除rm -i 交互式删除注:参数可以放在一起或分开 -r -f 等价于 -rf #表示root用户 $表示普通用户 echo 输出内容 1234echo &quot;print &apos;hello world!&apos;&quot; 在控制台打印字符串echo &quot;print &apos;hello world!&apos;&quot; &gt; hello.py 输出(覆盖)内容到hello.py文件中echo &quot;print &apos;hello world!&apos;&quot; &gt;&gt; hello.py 追加内容到hello.py文件中2&gt; 错误输出重定向 cal 查看日历 123cal 2018 查看2018整年的日历cal 2018 &gt; date.txt 将日历信息重定向到date.txt文件中cal 12 2018 查看2018年12月的日历 date 查看日期 bc 计算器 1scale = number number指小数点后几位的num shutdown / init 0 关机, 前者有1m的等待时间，后者直接关机 reboot / init 6 重启 head -n file 查看文件的前n行 tail -n file 查看文件最后n行 less/more file 分页查看文件 | 管道，用于进程间通信。把前一个进程的输出用于后一个进程的输入。 wc 用于统计(print newline, word, and byte counts for each file) 123-l 统计行数-c 统计字节数-m 统计单词个数 uniq 去重的作用(仅去重相邻的重复项) 1sort test.txt | uniq 先排序test.txt文件再去重 vim -d file1 file2比较2个文件的不同(通过创建2个子窗口) chmod 修改权限 chown 修改文件所有者 write 用户名 发送消息给用户,ctrl d结束 wall 发送消息给所有用户 !v 使用vim打开最近一次使用vim的文件 top 查看任务管理器 ls || cal 按顺序执行，若有一个命令执行成功，后续不执行 ls &amp;&amp; cal 按顺序执行，上一个命令执行成功，再执行后一个命令。若遇到执行不成功的,后续也不执行 ls; cal 按顺序执行命令(先ls 再cal) #Linux用户管理 用户添加 12345678910useradd [option] username -- 添加用户option:-c --&gt; 指定一段注释性描述-d --&gt; 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录-g --&gt; 指定用户所属的用户组-s --&gt; 指定用户登录的shell-u --&gt; 指定用户的用户号instance:# useradd -d /usr/mary -m Mary -- 创建名为Mary的用户,并指定其主目录为mary,若没有mary目录就创建一个目录# 默认下新建用户均会在/usr/目录下创建一个和用户名相同的用户主目录 删除账号 123userdel [option] username -- 删除用户option:-r --&gt; 删除用户的同时会删除用户的主目录和用户相关的记录 修改用户 12usermod [option] username -- 修改用户的信息option: 与添加用户部分的参数相同 口令管理(密码管理) 123456789passwd [option] [username]option:-l --&gt; 锁定口令,禁用账号-u --&gt; 解除锁定口令-d --&gt; 使账号无口令-f --&gt; 强迫用户下次登录时修改口令username:- 当没有指定username时, 修改当前用户的口令- 若当前用户是普通用户时, 修改口令需要指定旧口令; 若当前用户为root用户, 可以直接指定新的口令, 不需要旧口令。 Linux安装软件使用包管理工具yum/rpm123456yum search &lt;name&gt; -- 搜索相关包yum - y install &lt;name1&gt; &lt;name2&gt; -- -y参数是默认所有选项为yes，后可以接多个包进行安装yum -y remove &lt;name1&gt; &lt;name&gt; -- 卸载,也可以多个yum info &lt;name&gt; -- 查看软件的信息yum update &lt;name&gt; -- 更新指定的包,若没有指定name,则更新全部包yum list installed -- 将已经安装的包列出来 源代码构建安装 1gcc -- 通常linux系统自带 压缩文件 12gz --- 压缩gzip(解压缩gunzip)xz --- 压缩xzip(解压缩xz -d) 归档文件 12WinRAR --- 归档与解归档tar --- 归档文件(linux下) centos安装python3.x.x 12345678910111213141516171819201.下载源代码 -- wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz2.解压缩 -- gunzip Python-3.6.5.tgz 3.解归档 -- tar -xvf Python-3.6.5.tar (x抽离 v归档显示 f文件)4.安装Python依赖库 -- yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel5.安装前配置 -- 进入Python3.x.x文件，使用./configure --prefix=/usr/local/python36 --enable-optimizations (启用优化, 会大幅度增加安装时间, 至少多20分钟, 所谓的优化就是检测每一个功能是否正常)6.源代码构建安装make &amp;&amp; make install(&amp;&amp;表示如果make成功马上执行make install)7.配置PATH环境变量export PATH=$PATH:/usr/local/python36/bin8.注册一个软链接(符号链接) --- 非必要注:软链接 -- 相当于文件的快捷方式，文件删除则链接失效硬链接 -- 文件的引用。只要引用数不为0，文件就会一直存在ln -s 带完整路径的文件名 链接文件名(不带s为硬链接，带s为软链接)对于一个可执行的文件: ./可执行文件配置永久环境变量ls -al | grep .bash_profilevim .bash_profilei修改第10行(:set nu) -- PATH=$PATH:/usr/local/python36/bin修改第11行 -- export PATH Linux目录介绍/bin 1bin是Binary的缩写, 这个目录存放着最经常使用的命令, 如cat cp ls等(通常为普通用户和root用户必备的命令) /sbin 1sbin是Superuser Binary, 这个用户存放系统管理的命令(也称程序) 如reboot shutdown init ifconfig等 /boot 1存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /dev 1device，存放linux的外部设备文件(在linux中访问设备和访问文件的方式相同) /etc 1234存放所有的系统管理所需要的配置文件/etc/profile /etc/csh.login /etc/csh.cshrc 启动shell执行的文件。修改此文件,能够在登录用户后给提示信息./etc/passwd 用户数据库, 其中给出了用户名, 家目录, 命令目录/etc/shells 列出所有可以使用的shell /usr 12345678/usr/bin -- usr下的bin目录放置可执行程序/usr/local -- 手动安装软件的默认目录/usr/share -- 放置共享数据,帮助手册(/usr/share/man)/usr/lib -- 程序和子系统的库文件/usr/include -- c语言编程中的头文件/usr/bin -- 通常放置应用软件工具的必备命令 如gcc zip man等/usr/sbin -- 通常放置放置网路管理的必备程序, 如httpd dhcpd sendmail等/usr/src -- 内核源代码默认的放置目录 /home 1用户的主目录, 里面放置所有用户的主目录文件 /lib 1放置最基本的动态链接共享库, 类似window下的dll文件, 几乎所有程序都需要用到这些共享库 /proc 1process - 放置进程文件,它是系统内存的映射, 是一个虚拟目录 /var 1234存放系统运行时要改变的数据/var/lib -- 存放系统正常运行要改变的文件/var/local -- 存放/usr/local中安装的程序的可变数据/var/log -- 存放各种程序的日志文件 /root 1作为系统管理员的主目录 vim文本编辑器命令模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344按 i 可切换到 编辑模式h/left -- 光标左移1j/down -- 光标下移1k/top -- 光标上移1l/right -- 光标右移1同时可以 10right/10l 的组合键向右移动10个字符0或home 移动到一行的首字符$或end 移动到一行的末字符H 光标移动到屏幕的第一行首字符M 光标移动弄到屏幕的中间行首字符L 光标移动到屏幕最后一行的首字符w 光标移动一个单词G 光标移动到文件的最后一行gg 光标移动到文件的第一行(相当于1G)nG 光标移动到第n行(20G -- 第20行) -- 配合set nu使用n&lt;Enter&gt; 光标向下移动n行/word 向光标之下寻找名称为word的字符串n/N 对应/word使用,前者为下一个,后者为上一个:n1,n2s/word1/word2/g 在n1到n2行之间,将word1字符串替换成word2:1,$s/word1/word2/g 在第一行到最后一行间,将word1字符串替换成word2:1,$s/word1/word2/gice c是confirm确认,i是ignore忽略大小写,g是global全局模式,e是error忽略错误?正则表达式 反向搜索(与/相反)ctrl f 屏幕向下移动1页(page down)ctrl b 屏幕向上移动1页(page up)ctrl e 向下翻1行ctrl y 向上翻1行x 向后删除一个字符 X 向前删除一个字符dd 删除光标所在一整行ndd 删除含光标所有n行yy 复制光标所在一行nyy 复制含光标所在n行p 将复制的数据在光标下一行贴上 P将复制的数据在上一行贴上u 复原前一个动作ctrl r 重做上一个动作 . 重做上一个动作ctrl x + ctrl o 代码提示r/R 进入取代模式(replace) r会取代光标所在的字符一次, R会一直取代ZZ --- 没改动则直接离开，若改动则保存退出 编辑模式 1234567enter 换行backspace 删除光标前一个字符delete 删除光标后一个字符home/end 移动光标到行首/行尾pg up/pg dn 上/下翻页insert 切换光标为输入/替换模式(replace)esc 切换到命令模式 底线命令模式 123456789101112131415在命令模式下,按下:冒号进入底线命令模式:systax off/on --- 关闭/打开高亮语法:set nu/nonu --- 设置行号/关闭行号:wq --- 保存退出:ls 查看打开的文件:b &lt;编号&gt; 查看指定编号文件(可实现vim同时打开多个文件):vs 垂直拆分窗口:sp 水平拆分ctrl w + ctrl w 切换窗口:qa 退出全部:wqa 全部保存退出:qa! 全部强制退出:map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行:inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 .vimrc(vim配置文件) 12345678syntax on/off 高亮语法打开/关闭set number 设置行号set tabstop=4 设置tab缩进为4 set ruler 显示标尺set nohls 搜索时去除高亮set autoindent 设置换行时自动缩进map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 linux锁屏与解锁 12ctrl s 会将终端terminal锁屏,造成假死的现象ctrl q 进行解除锁屏 ssh远程登录 1远程登录命令 ssh &lt;user&gt;@公网ip password ssh远程传输 12345scp &lt;local file&gt; &lt;user&gt;@公网ip:/传输的路径 passwd(注意用户的级别与所放置文件的目录访问权限有关) --- 将本地文件发送给别的用户的某个路径下例如:scp sohu2.html rzlong@120.77.178.218:/home/rzlongscp &lt;user&gt;@公网ip:/传输的路径 &lt;user&gt;@公网ip:/传输的路径 passwd1 passwd2 将用户1的某个文件发给用户2,如果要发送文件可以加上 -r 参数例如:scp rzlong@120.77.178.218:/home/rzlong/sohu2.html lnx@47.93.248.0:/home/lnx sftp安全文件传输 12345678910111213sftp &lt;user&gt;@公网ip passwd 进入sftp模式help可以查看相关命令相关命令:get [-Ppr] remote [local] Download filereget remote [local] Resume download fileput [-Ppr] local [remote] Upload filels [-1afhlnrSt] [path] Display remote directory listingmkdir path Create remote directoryrename oldpath newpath Rename remote filerm path Delete remote filermdir path Remove remote directorypwd Display remote working directory此时要在sftp模式中操纵本地 在以上命名前加上l(local),如lcd, lls, lpwd DoS和DDoS 12 查看端口情况 123netstat -anp | grep 80 查看所有占用80端口的情况 n数值型ip a是all p是进程netstat -lntp 显示当前被监听的端口例如:tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2033/sshd 进程id为2033, ip为0.0.0.0，端口号22, 传输协议为tcp, sshd是secure shell deamon安全外壳守护进程(后台程序) 服务相关 1234567891011121314151617centos 6.xservice &lt;name&gt; startservice &lt;name&gt; stopcentos 7.xsystemctl start &lt;name&gt; - 启动服务systemctl stop &lt;name&gt; - 停止服务systemctl restart &lt;name&gt; - 重启服务systemctl status &lt;name&gt; - 服务状态syatemctl enable &lt;name&gt; - 设置服务开机自启systemctl disable &lt;name&gt; - 设置服务不启动安装Appache服务器yum -y install httpdps -ef | grep nginx 进程后台运行 12345678910111213141516171819top -- 查看任务管理器jobs -- 查看后台运行的进程ctrl c -- 结束进程ctrl z -- 进程暂停置于后台ctrl d -- 停止输入bg %编号 -- 让暂停的进程继续在后台运行 backgroundfg %编号 -- 让后台的进程在前台(terminal)运行 foreground./hello.py &amp; -- 将一个程序置于后台运行说明:Key FunctionCtrl-c Kill foreground process Ctrl-z Suspend foreground processCtrl-d Terminate input, or exit shellCtrl-s Suspend output 暂停输出Ctrl-q Resume output 回复输出Ctrl-o Discard output 抛弃输出Ctrl-l Clear screen 清屏 计算机网络分层架构模型 1234567TCP/IP 协议族TCP -- Transfer Control Protocol 传输控制协议UDP -- User DataGram Protocol 用户数据报协议IP -- Internet Protocol 网际协议应用层(定义应用级协议)- HTTP / SMTP / POP3 / FTP / SSH / linux下防火墙firewall 123456789systemctl start firewalld -- 开启防火墙 firewall-cmd -- 配置防火墙 firewall-cmd --help 查看相关命令firewall-cmd --permanent --add-port=80/tcp 配置永久开启80端口firewall-cmd --remove-port=80/tcp 删除80端口firewall-cmd --query-port-80/tcp 查看端口是否开启firewall-cmd --query-service=ssh 查看ssh服务是否开启注:当修改了端口(打开或关闭),需要重启防火墙才能生效。 iptables Linux中好玩的命令pv 通过yum install pv命令进行安装, 其效果是输出的内容达到边敲边显示的样子。 sl 通过yum install sl 命令进行安装, 其效果为跑火车。 xeyes 通过yum install xeyes 命令进行安装,运行命令,会在图形显示界面会看到一双萌萌的眼睛盯着你。 Linux历史GNU和GPL GNU 建立一个自由、开放的 Unix 操作系统(FreeUnix) GPL(GNU General Public License) 为了避免 GNU 所开发的自由软件被其他人所利用而成为专利软件， 史托曼与律师草拟了有名的通用公共许可证(General Public License, GPL)， 并且称呼他为copyleft(相对于专利软件的 copyright！) Free Software和Close Software free software它更被能称为freedom software,自由软件。不是指免费的价格，而是拥有自由的权利。同时它还具有open source 开放源代码的特点。 1&quot;Free software&quot; is a matter of liberty, not price. To understand the concept, you should think of &quot;freespeech&quot;, not &quot;free beer&quot;. &quot;Free software&quot; refers to the users&apos; freedom to run, copy,distribute, study, change,and improve the software close software 即推出的可执行的二进制程序，是专利软件copyright常见的软件出售方式。 但是也有专利软件是免费使用的.Freeware和Shareware : 前者为免费软件，可以免费使用但是不会公开源代码；后者为共享软件，通常为有试用期，再试用期后就必须续费或者停止使用，它已经撰写好了失效程序。 Linux核心版本 可以使用uname -r查看当前linux版本: 12[root@izwz9gn12m5wual96636l2z ~]# uname -r3.10.0-514.26.2.el7.x86_64 主版本.次版本.释出版本-修改版本 在2.6.x版本前，托瓦兹将主次版本为奇数的定位发展中版本development，主要用于测试与发展；对于主次版本为偶数的定位稳定版本stable 在3.0版本后，依据主线版本MainLine开发，例如 3.10 就是在 3.9 的架构下继续开发出来的新的主线版本。而对于旧的版本，有两种机制来处理: 其一为结束开发End Of Live(EOL)，不会再维护；其二是长期维护版本Longterm，例如3.10为一个长期维护版本。 Linux Distrubution 可以使用cat /etc/xxx-release 或者lsb-release -a 或者查看 123456789[root@izwz9gn12m5wual96636l2z ~]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.3.1611 (Core) Release: 7.3.1611Codename: Core[root@izwz9gn12m5wual96636l2z ~]# cat /etc/centos-releaseCentOS Linux release 7.3.1611 (Core) linux distrubution 即linux发行版，它是linux kernel+softwares+Tools+可完全安装程序 。常见的有Redhat /OpenSuSe/Fedora/Ubuntu/Debian/CentOS等，它们都是支持于标准的。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门]]></title>
    <url>%2F2018%2F10%2F05%2Fgit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[介绍Git是一个免费的开源 分布式版本控制系统，旨在快速，高效地处理从小型到大型项目的所有事务。 Git 易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价的本地分支，便捷的临时区域和 多个工作流程等功能。 版本控制工具CVS/VSS – 锁定模式 2000年 - Subversion(SVN) – 合并模式上述为集中控制式的版本系统,必须有中央服务器。 2005年 - Git – 版本控制Mercury*分布式的版本系统 可视化工具Sourcetree SmartGit TortoiseGit 区域划分工作区 — 暂存区 — 仓库 本地仓库 git init 初始化，使当前目录初始化为git仓库，并创建.git的隐藏目录（它就是Git版本仓库） git add &lt;file&gt; git add . 将工作区的某个文件或全部文件添加到暂存区 git checkout -- &lt;file&gt; 对于某个已放入暂存区的文件，但是又不小心在工作区(目录下)删除了该文件，可以使用命令进行恢复。在Git 2.23发布了代替的测试命令git restore &lt;filename&gt; git status 查看工作区、暂存区和本地仓库的状态 git rm --cache &lt;file&gt; 将已放入暂存区的文件放回工作区 git commit -m &quot;提交说明&quot; 将暂存区的文件提交到本地仓库 git log --graph --pretty=oneline --abbrev-commit 查看提交的日志情况，包括分支合并图、一行显示、提交校验码缩略显示 git config --global user.name &quot;username&quot; git config --global user.email &quot;email@gmail.com&quot; 需要配置用户名和邮箱才能将代码提交到远程仓库 远程仓库免密访问如果项目是私有项目（公有项目无需），想在本地免密访问，就需要配置，使用下述命令得到密钥对 ssh-keygen -t rsa -b 2048 -C &quot;your_email@example.com&quot; 在本地操作远程仓库，通常可以使用上述命令获取公钥和私钥(~/.ssh目录下，即用户主目录下ssh目录)，然后在代码托管平台或者私服上配置公钥管理，配置完成后就能实现免密访问；若不使用，也可以通过Http协议在远程操作时进行用户身份认证。 添加远程仓库 git remote add origin git@github.com:mary/test.git 添加远程仓库，其中origin时服务器上仓库的别名，后面的地址是SSH免密下载的地址 git remote -v 查看已经指定的远程Git服务（通常连接一个服务器仓库，会有fetch和push两个服务） git remote remove &lt;name&gt; 根据指定的远程仓库别名删除Git服务 推送 git push 将当前分支推送到远端服务器的同名分支上 git push -u origin local_master:remote_master 将本地仓库的工作成果推送到远程仓库，-u origin时指定推送的服务器，master:master是指本地仓库分支名和远程仓库分支名（若它们建立了关联，就可以不指定远程分支，即冒号后面的master），-u相当于--set-upstream-to 拉取 git pull origin master 将远程仓库master分支的代码或文件发到本地分支 如果远端代码和本地分支可能出现冲突，应该采用git fetch+git merge；直接使用git fetch会将变化拉到当前分支；建议将远端拉到临时分支，具体 123456# 将远端master分支拉到本地名为temp的分支上git fetch origin master:temp# 查看代码冲突git diff # 合并git merge temp 分支操作创建分支 git branch &lt;branch-name&gt; 创建分支 git branch &lt;branch&gt; develop 基于本地的develop分支创建分支 git branch 查看本地分支 git branch -a 查看所有分支（含远端服务器分支） 切换分支 git checkout &lt;branch-name&gt; 切换分支，在Git 2.23中可以使用git switch &lt;branch&gt;切换分支 git checkout -b &lt;branch&gt; 创建分支同时切换到创建的分支，等同的git switch -c/C &lt;branch&gt; 关联分支 git branch -u &lt;remote&gt;/&lt;branch&gt; 将本地当前分支和远程仓库分支建立关联--set-upstream-to等同于 -u git branch --set-upstream-to &lt;remote&gt;/&lt;branch&gt; master 指定本地任一分支和远程仓库分支建立关联= 远程仓库别名/远程分支 本地任一分支 git branch --track &lt;branch&gt; origin/master 创建一个本地分支，并关联到远程仓库origin(别名)的master分支 git branch --unset-upstream &lt;branch-name&gt; 解除本地分支&lt;branch-name&gt;与远程分支的关联 合并分支合并分支是在切到主分支上对自己的分支合并 12git checkout mastergit merge --no-ff dev 在dev分支上完成开发任务后，如果要把dev分支的代码合并到master上，需要切换到master分支然后使用git merge进行合并；这种合并方式默认使用Fast Foward快速合并方法（如果删除了分支，分支上的信息全部丢失，若要保存分支的信息，需要--no-ff参数禁用Fast Foward） 分支合并时，没有冲突的部分会自动合并；若有冲突时，会报错，并提示让你修改错误，此时使用git diff查看错误，并手动进行修改选择保留的部分，再次使用上述的合并操作。实现如下： 1234567891011开始:master: a--&gt;b--&gt;c--&gt;d--&gt;e ↓ dev: ↘f --&gt;g合并：master: a--&gt; b--&gt; c--&gt;d --&gt; e ↓ ↘ h--&gt; i dev: ↘f --&gt;g ↗ master分支的e节点和dev分支的g节点合并，并形成h节点 分支变基分支合并是将两个分支合并成一个分支，但是随着业务的增加，分支就愈加复杂难以管理。此时，就需要考虑使用变基来管理分支的合并。变基是将dev分支连接到master的后面，将它们的成果同步到一起，然后合并。变基不仅会保留分支上的版本，还会使版本非常干净。 注意：变基是在dev上时对master进行的，然后合并到自己的分支dev上 12345# 当前在dev分支上git checkout devgit rebase mastergit checkout mastergit merge dev 实现效果如下: 1234567891011开始：master: a--&gt;b--&gt;c--&gt;d--&gt;e ↓ dev: ↘f --&gt;g 变基： (dev)master: a--&gt;b--&gt;c--&gt;d--&gt;e--&gt;f--&gt;g (master)dev分支从c节点断开变基，然后合并到e节点之后，形成一个分支 删除分支本地分支 git branch -d &lt;branch&gt; 使用上述命令删除分支，但是若分支上的工作成果没有合并的话，那么删除分支时会报错，提示分支没有合并。若要强行删除分支，使用-D参数（强行删除会导致数据丢失） git branch -D &lt;branch&gt; 远程分支12git branch -r -d origin/developgit push origin :develop 标签（发版本）同大多数VCS版本控制系统一样，Git可以对某一个时间点的版本打上标签 显示标签 git tag 显示所有标签 git tag -l &#39;v1.2.*&#39; 显示v1.2版本下的所有子版本，如(v1.2.1 v1.2.2 ...) 新建标签Git标签分为轻量级（lightweight）标签和含附注（annotated）的标签两种。前者是指向特定提交对象的引用，后者是存储在仓库中一个独立的对象，含自身校验和信息(标签名、邮件地址、日期和标签说明，以及签署功能)，一般建议使用后者 附注标签 git tag -a v1.1 -m &quot;this is version 1.1&quot; -a 参数是标签名，-m参数是标签说明 git show v1.1 使用命令取查看标签的版本信息和标签的提交对象 git tag -s v1.2 -m &quot;this is verison 1.2&quot; 签署标签（使用请跳转）如果有自己的私钥，用GPG来签署标签 git tag -v v1.2 如果有对应的公钥，可以通过上述命令取验证verify被签署的标签 轻量级标签它保存着对应提交对象的校验和信息，使用时不用给任何参数 git tag v1.1 后期加注标签 git tag -a v1.1 9fceb02 对9fceb02这个版本补上标签v1.1，-a表示新增 发布远端默认情况下，git push都不会将标签传到远端服务器，只有通过显式的命令才能分享到远端仓库 git push origin v1.2 将v1.2分享到origin远端服务器的仓库中 git push origin --tags 将所有新增的标签分享到远端服务器中 其他git fetch 下载远程仓库的所有变动到一个临时分支，再根据需要进行合并操作（git fetch + git merge --&gt; git pull） 123456789# 将远端与本地分支关联git branch -u origin/develop develop# 将远端origin分支 fetch到临时分支tempgit fetch origin :temp# 查看两个分支有无冲突并修改git diff develop temp# 切到develop分支并指定不快速合并git checkout developgit merge --no-ff temp git diff 比较工作区和仓库、暂存区和仓库、两个分支间冲突 git stash 将当前工作区和暂存区的变动放到一个临时的区域，其完成别的紧急的任务（只对git add的文件有效） git reset 回退版本 git cherry-pick挑选某个分支的单次提交并作为一个新的提交引入到你当前分支上 git revert撤回提交信息 分支管理策略github-flow1234567891. 克隆项目到本地并基于master分支创建自己的工作分支git clone git@github.com:xxx/xx.gitgit checkout -b work2. 在自己的分支上做开发并实施本地版本控制3. 将自己的分支推送服务器上(某一个/一组用户故事已经完成)git push origin work/work (可以直接使用 git push)4. 线上完成: 发起一次合并请求(请求将自己的工作成果合并到master分支) - 线上实施(页面上操作,发起无冲突合并)5. 项目的管理者和测试人员分别审查和测试代码, 然后决定是否合并 master分支就是代码分支，可能导致上线功能慢与分支功能 git-flowgit-flow 基本命令 git init 初始化，使当前目录初始化为git仓库，并创建.git的隐藏目录 git config –global user.name “name” 全局用户名可以随便写,仅标记主机 git config –global user.email “email@example.com“ 全局邮箱,可随便写 git add 将文件加入到暂存区 git add . 将当前目录下的所有文件加入到暂存区 git commit -m “版本提示内容” 将暂存区的内容提交到本地仓库 git status 查看暂存区状态 git log 查看当前版本日志(之前的版本) git reflog 查看所有版本git reset HEAD -将文件从暂存区移除 git checkout – 将暂存区回退到工作区，可用于文件恢复(用于上一次,并且还没有提交到本地仓库中；若是已经提交到仓库中，就可以使用hard来还原版本) git reset –hard 版本号 去往指定的版本 git reset –hard HEAD^ 还原到上个版本(HEAD^^还原到上上个版本) git reset –hard HEAD~num 还原到前num个版本 git clone - 将服务器的项目(仓库)克隆到本地 git push - 将代码推送到服务器(上传) git pull - 将服务器上代码同步到本地(下载) 代码托管平台用别人提供的git服务器github.comgitee.comcoding.net]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F10%2F05%2Fmutiphreading-md%2F</url>
    <content type="text"><![CDATA[##多线程技术 主线程 每个进程都会有一个线程, 这个线程是主线程。默认情况下, 所有代码都是在主线程中执行。 子线程 一个进程可以有多个线程,除了主线程的其他子线程需要去创建 创建线程通过导入threading模块。 threading是python中创建线程的内置模块，用来支持多线程。Thread类的对象就是线程，需要线程时，可创建这个类或其子类的对象。 实例 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingfrom datetime import datetimeimport time# 模拟下载电影def download(file): print(threading.currentThread()) print(file+&apos; 开始下载&apos;,datetime.now()) time.sleep(10) print(file+&apos; 结束下载&apos;, datetime.now())# 在两个子线程中去下载电影&apos;&apos;&apos;Thread(target,args)target:需要在在线程中调用的函数的函数名args: 函数的实参返回值:创建好的线程对象&apos;&apos;&apos;if __name__ == &apos;__main__&apos;: print(threading.current_thread()) print(&apos;主线程位置&apos;) print(&apos;===============================&apos;) t1 = threading.Thread(target=download, args=(&apos;闻香识女人&apos;,)) # t1.start()#想要子线程执行任务，通过线程对象调用start方法 print(&apos;=============================&apos;) t2 = threading.Thread(target=download, args=(&apos;猫鼠游戏&apos;,)) # t2.start() # 执行线程的代码result:&lt;_MainThread(MainThread, started 10552)&gt;主线程位置===============================&lt;Thread(Thread-1, started 8712)&gt;闻香识女人 开始下载 2018-09-15 09:27:07.418839=============================&lt;Thread(Thread-2, started 10564)&gt;猫鼠游戏 开始下载 2018-09-15 09:27:07.418839猫鼠游戏 结束下载 2018-09-15 09:27:17.419411闻香识女人 结束下载 2018-09-15 09:27:17.419411 ##面向对象的多线程 步骤1.声明一个类，继承Thread类2.重写run()方法,将需要在子线程中执行的任务，放到run()方法中3.在需要线程的位置，去创建这个类的对象然后用对象调用start方法，去执行run中的任务。 案例1234567891011121314151617rom threading import Threadfrom datetime import datetime # 从datetime包中引入datetime模块import timeclass R_Thread(Thread): &quot;&quot;&quot;下载线程类&quot;&quot;&quot; def __init__(self,name): super().__init__() self.name = name def run(self): print(self.name+&apos; 开始下载&apos;,datetime.now()) time.sleep(5) print(self.name+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: print(&apos;=========================&apos;) t1 = R_Thread(&apos;闻香识女人&apos;) t1.start() print(&apos;============================&apos;) ##join方法如果希望某个线程结束后才执行后续的操作，调用join方法 案例12345678910111213141516171819202122232425262728from threading import Threadfrom datetime import datetimeimport timefrom random import randint# 在两个子线程中下载两个电影,在主线程中国统计两个电影下载的总时间class R_Thread(Thread): def __init__(self,file): super().__init__() self.file = file def run(self): print(self.file+&apos; 开始下载&apos;,datetime.now()) time.sleep(randint(5,15)) print(self.file+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: t1 = R_Thread(&apos;闻香识女人&apos;) start = time.time() print(start) t1.start() t2 = R_Thread(&apos;美丽人生&apos;) t2.start() &apos;&apos;&apos; 如果希望某个线程结束后才执行后续的操作，调用join方法 &apos;&apos;&apos; t1.join() #这句代码后面的代码需要在t1对应的线程结束后执行 t2.join() end = time.time() print(end) print(end-start) ##多个线程数据共享通过加锁的方式，以解决多个线程同时对一个数据进行操作二带来的数据紊乱的问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import timefrom datetime import datetimefrom threading import Thread,Lock,RLockclass Account: &quot;&quot;&quot;账号类&quot;&quot;&quot; def __init__(self,balance): self.balance = balance # 创建锁对象 self.lock = Lock() # 存钱: 读余额, 确定钱的数目 def save_money(self,amount): self.lock.acquire() # 获取原来的余额 old_amount = self.balance # 模拟时间消耗 time.sleep(5) # 修改余额 self.balance = old_amount + amount print(&apos;存钱成功,余额&apos;,self.balance) self.lock.release() # 取钱 def get_money(self,amount): self.lock.acquire() old_amount = self.balance if old_amount &lt; amount: print(&apos;余额不足&apos;) return time.sleep(10) self.balance = old_amount - amount print(&apos;取钱成功,余额&apos;,self.balance) self.lock.release() def show_balance(self): print(&apos;余额:&apos;,self.balance)if __name__ == &apos;__main__&apos;: account = Account(1000) account.show_balance() &apos;&apos;&apos; 当多个线程同时对一个数据进行操作的时候,可能出现数据紊乱的问题 &apos;&apos;&apos; t1 = Thread(target=account.save_money,args=(200,)) t2 = Thread(target=account.get_money,args=(400,)) t1.start() t2.start() t1.join() account.show_balance() t2.join() account.show_balance() **]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
