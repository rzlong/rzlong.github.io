<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django权限]]></title>
    <url>%2F2018%2F10%2F31%2FDjango%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[RBAC 基于角色的访问控制Roles-Based Access Control 角色访问控制（RBAC）引入了Role的概念,目的是为了隔离User(即动作主体，Subject)与Privilege(权限，表示对Resource的一个操作，即Operation+Resource)。 Role作为一个用户(User)与权限(Privilege)的代理层，解耦了权限和用户的关系，所有的授权应该给予Role而不是直接给User或 Group。Privilege是权限颗粒，由Operation和Resource组成，表示对Resource的一个Operation。例如，对于新闻的删除操作。Role-Privilege是many-to-many的关系，这就是权限的核心。 完善的RBAC模型 对于大多数情况下, 我们说的RBAC模型, 就是这样子的, 分为用户、角色、权限三部分 通过给角色添加权限(多对多关系), 再给用户添加角色(多对多关系). 此时用户对权限的访问, 就过渡到给用户指定带有权限的角色. 模型 Django中对应权限控制的用户表，权限表和角色表，同时还设有三种表之间的多对多关系中间表 注: auth_user用户表 auth_group角色表(组表) auth_permissions权限表 auth_user_groups 用户-角色表 auth_group_permissions角色-权限表 auth_user_user_permissions用户-权限表 这些表都是Django帮我们写好的模型, 在我们执行迁移时, 自动给我们生成。当然，我们也可以依托于models完全重写用户表模型，或者依托于AbstractUser类进行重写用户表的模型(即扩展auth_user表，这样他就能使用Django内置的很多权限操作相关函数) 1234567891011from django.contrib.auth.models import AbstractUser class MyUser(AbstractUser): class Meta: # Django默认给每个模型初始化3个默认权限(change, delete, add) permissions = ( ('add_my_user', '新增用户权限'), ('change_my_user_username', '修改用户名权限'), ('change_my_user_password', '修改用户密码权限'), ('all_my_user', '查看所有用户权限'), )# permissions 参数内放置权限的元组(??????) 注意: 要想让Django知道,将User模型修改为自定义的User模型, 需要修改settings.py文件. 格式为:AUTH_USER_MODEL = &#39;app_name.ModelName&#39; 思想 在Django 中，我们对权限控制的理解: 1先创建角色,2 对角色分配权限, 3再为用户指定角色;4 但在特殊的情况下,又直接为用户分配权限。 三种表之间的访问控制 三种表的关系均为多对多的关系, 我们可以查看 AbstractUser –&gt; PermissionsMixin 和Group的定义, 然后我们知道三种表之间的多对多定义字段, 如下: User表 123groups = models.ManyToManyField(Group)user_permissions = models.ManyToManyField(Permission) Group表 1permissions = models.ManyToManyField(Permission) 添加和删除 我们通过一种模型对象去修改另一个模型的对象, 这个过程我们不用去关注两种表的中间表(多对多关系), Django已经为我们处理好了(类似级联删除和更新) 通过用户表去添加权限表中的数据 12# user是用户模型对象, permission是将被添加的权限模型对象user.user_permissions.add(permission) 通过用户表去删除权限表的数据 12# user是用户模型对象, del_permission是将被删除的权限模型对象user.user_permissions.remove(del_permission) ​ 查询 用户自定义查询 通过用户直接查询权限 123456# 得到指定user对象的所有权限对象, 返回的是一个QuerySet对象, 它的内部是由所有权限模型对象 组成的user.user_permissions.all()# 通过过滤得到指定user对象的权限对象, 返回的是一个QuerySet对象user.user_permission.filter(xxx)# 直接得到确定的指定user对象的一个权限对象, 返回的是一个权限模型对象user.user_permission.get(name=&apos;xxx&apos;) 通过用户查询角色再查询权限 12# 返回的一个QuerySet对象user.groups.all()[0].permissions.all() 注: 删除的两种查询方式所得结果就是user的全部权限 Django自带的查询 用户获取组权限 12# 返回的是组(角色)权限的字典(codename字段)user.get_group_permissions() 用户获取所有权限 12# 返回的是用户所有权限的字典(codename字段)user.get_all_permissions() 在前端也能使用这些对象 请注意对象,属性,索引在Django模板标签中使用方式(使用 . ,属性不加括号) 权限认证 权限认证的部分通过装饰器来实现, 判断是否有权限 12# 判断user对象是否有permission_name权限user.has_perm(app_name.permission_name) 自定义装饰器实现权限认证 1234567891011121314151617181920# 举例针对test2用户， 必须拥有all_my_user权限才能访问# 视图函数@index_requireddef index(request): # test2用户有查看所有用户权限, 才能访问如下视图函数(装饰器) if request.method == 'GET': return render(request, 'index.html') # 装饰器def index_required(func): def inner(request): user = MyUser.objects.filter(username='test2').first() if not user: return HttpResponse('没有该用户') per = user.user_permissions.filter(codename='all_my_user').first() if not per: return HttpResponse('没有all_my_user权限') else: return func(request) return inner Django提供的权限认证装饰器 123456789# 装饰器中的参数是 app_name.permission_name@permission_required('rbac.ll_my_user')def foo(request): if request.method == 'GET': # 同时需要在配置文件setting.py中加入以下:# 登录权限验证不通过, 跳转的地址(通常为登录地址的全路由)LOGIN_URL = '/rbac/login/' ​]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-user]]></title>
    <url>%2F2018%2F10%2F26%2Fdjango-user%2F</url>
    <content type="text"><![CDATA[准备工作 创建app 1# django-admin startapp app_name 配置urls.py文件 1234567891011121314# project/urls.pyfrom django.conf.urls import url, includeurlpatterns = [ url(r'^user/', include('user.urls', namespace='user')),]#project/app_name/urls.pyfrom django.conf.urls import urlfrom user import views# 放置自己需要的路由urlpatterns = [ url('^register/', views.register, name='register'),] 在setting.py文件下,在INSTALLED_APPS 中添加app models.py 写了三个model, User用户, UserTag用户令牌(存放cookie的会话id), UserInfo(User信息扩展) 123456789101112131415161718192021222324252627282930from django.db import modelsclass User(models.Model): username = models.CharField(max_length=15, unique=True, verbose_name='用户名') password = models.CharField(max_length=200, verbose_name='密码') email = models.EmailField( max_length=50, verbose_name='邮箱') create_time = models.DateTimeField(auto_now_add=True, verbose_name='创建时间') class Meta: db_table = 'user'class UserInfo(models.Model): phone = models.CharField(max_length=11) address = models.CharField(max_length=30) description = models.CharField(max_length=150) user = models.OneToOneField(User) class Meta: db_table = 'user_info'class UserTag(models.Model): # 标识符用于用户访问需要登录的页面时去验证 identifier = models.CharField(max_length=100, unique=True, verbose_name='标识符') user = models.OneToOneField(User) class Meta: db_table = 'user_tag' views.py 需要引入的模块 12345678import randomfrom django.http import HttpResponseRedirectfrom django.shortcuts import renderfrom django.urls import reversefrom user.models import User, UserTagfrom utils.functions import login_required 注: python引入模块的顺序: 在最上方放置python自带的模块 在中间放置第三方库的模块 在在下方放置本地写的模块 三种模块间换行处理 注册 1234567891011121314151617181920212223242526272829def register(request): if request.method == 'GET': return render(request, 'register.html') if request.method == 'POST': # 用于创建用户 # POST['xx'] 若获取不到参数返回错误 # POST.get('xx') 若获取不到参数不返回错误 # 1.获取参数 username = request.POST['username'] password = request.POST['password'] password2 = request.POST['password2'] # 2.检验参数是否完整 if not all([username, password, password2]): msg = '请填写完整' return render(request, 'register.html', &#123;'msg': msg&#125;) # 3.判断数据库是否存在用户 if User.objects.filter(username=username).first(): msg = '该账户已注册, 请去登录' return render(request, 'register.html', &#123;'msg': msg&#125;) # 4.检验密码是否一致 if password != password2: msg = '密码不一致, 请重新输入' return render(request, 'register.html', &#123;'msg': msg&#125;) # 5.注册 User.objects.create( username=username, password=password, ) return HttpResponseRedirect(reverse('user:login')) 登录 123456789101112131415161718192021222324252627282930313233343536373839def login(request): if request.method == 'GET': return render(request, 'login.html') if request.method == 'POST': # 1.获取参数 username = request.POST.get('username') password = request.POST.get('password') # 2.验证数据完整性 if not all([username, password]): msg = '输入不完整.' return render(request, 'login.html', &#123;'msg': msg&#125;) # 3.验证用户是否注册 user = User.objects.filter(username=username).first() if not user: msg = '该账号没有注册' return render(request, 'register.html', &#123;'msg': msg&#125;) # 4.校验密码 if password != user.password: msg = '密码不正确' return render(request, 'login.html', &#123;'msg': msg&#125;) # 5.请求与响应 # 请求: 客户端发送请求给服务器 # 响应: 服务器收到客户端的请求, 就发送一个响应给客户端 res = HttpResponseRedirect(reverse('user:index')) # 取随机标识符 tag = '' tags = '1234567890abcdefghijklmnopqrstuvwxyz' for _ in range(25): tag += random.choice(tags) # set_cookie(key, value, max_age) res.set_cookie('identifier', tag, max_age=1200) # 存标识符的值 user_tag = UserTag.objects.filter(user=user).first() if not user_tag: UserTag.objects.create(identifier=tag, user=user) else: user_tag.identifier = tag user_tag.save() return res 首页index, 使用装饰器 1234567891011@login_requireddef index(request): if request.method == 'GET': # identifier = request.COOKIES.get('identifier') # # 查询标识符 # identifier = UserTag.objects.filter(identifier=identifier).first() # if not identifier: # # 查找不到标识符的值, 就返回到登录 # return HttpResponseRedirect(reverse('user:login')) return render(request, 'index.html') 注销logout, 使用装饰器 1234567891011@login_requireddef logout(request): if request.method == 'GET': # 1.删除cookie res = HttpResponseRedirect(reverse('user:login')) res.delete_cookie('identifier') # 2.删除UserTag表中的内容 identifier = request.COOKIES.get('identifier') UserTag.objects.filter(identifier=identifier).delete() return res utils(package) 在工程下, 新建一个名为utils 的包文件, 里面放置像装饰器, 复用代码的模块 创建functions.py模块, 里面写登录和注销处理函数的装饰器 1234from django.http import HttpResponseRedirectfrom django.urls import reversefrom user.models import UserTag 1234567891011121314151617181920# 定义验证登录的装饰器# 闭包的三个条件(无参数闭包)# 1.外层函数套内层函数# 2.内层函数调用外层函数的参数# 3.外层函数返回内层函数def login_required(func): def check_login(request): # func是被login_required装饰的函数 identifier = request.COOKIES.get('identifier') if not identifier: # cookie中没有登录的标识符, 跳转到登录界面 return HttpResponseRedirect(reverse('user:login')) user_tag = UserTag.objects.filter(identifier=identifier).first() if not user_tag: # 标识符有误, 跳转到登录界面 return HttpResponseRedirect(reverse('user:login')) return func(request) return check_login 装饰器 闭包 装饰器的实现是以闭包为基础的, 首先我们来看一看闭包的实现. 12345678def foo1(): def foo2(): print('this is foo2!') return foo2if __name__ == '__main__': f1 = foo1() f1() 当我们去执行foo1()函数调用, 它返回的是foo2函数。因此将f1=foo1() 时, f1就等价于foo2, f1()就等价与执行foo2(); 这就是闭包的执行原理。 装饰器(无参数) 123456789101112def dec(func): def outer(*args): print(f'outer --&gt; &#123;args&#125;') func(args) return outer@decdef test(args): print(f'test --&gt; &#123;args&#125;')if __name__ == '__main__': test('别要搞些大新闻','wtf') 装饰器的使用就是在被装饰的函数上加上@decorator_name , 如上@dec就是给test加上装饰器, dec函数就是装饰器函数 执行被装饰的函数, 其实是执行装饰器, 并将被装饰的函数当做参数传给装饰器函数也就是说带装饰器时test相当于 dec(test); 而dec(test) 返回outer, 因此test(*args) 也就是相当于dec(test(*args))(传递的参数是赋给*args的, args是对*arg的使用) 被装饰器的函数相当于在装饰器的内部函数中进行加功能操作 装饰器(带参数) 12345678910111213141516171819def dec(type): # 最外层函数带参数 def outer(func): #中间的函数带外部函数的参数 def inner(*args): # 内层函数带实际参数(外部参数就是这儿的参数) if type == 'arg': print(f'inner --&gt; &#123;args&#125;') func(args) else: print(f'errors') return inner return outer@dec('arg')def test(args): print(f'test --&gt; &#123;args&#125;') if __name__ == '__main__': # test() test('123') dec('arg')(test('123')) 带参数的装饰器的原理和不猜参数的装饰器原理几乎相同, 只是变成3层内嵌函数. test() 就相当于调用dec(&#39;arg&#39;)(test()) 调用外部函数时, 外部函数传递的参数其实在装饰器的情况下, 会赋给inner中的*args, 而后续的test(arg), 就是对*args的使用(*args是元组) 扩展(表单验证) 表单验证, 其实现就是将前端中输入的数据(如,用户名,密码等)封装到一个类中, 并添加验证的函数。 系统models 注册​ 若request的方式是GET, 将返回到注册页面; 若request的方式是POST,说明它是通过表单的post方式传值的, 就在其中使用表单验证, 并 写入创建用户的验证部分功能。代码吐下： 123456789101112def register(request): if request.method == 'GET': return render(request, 'register.html') if request.method == 'POST': form = UserRegisterForm(request.POST) if form.is_valid(): User.objects.create_user(username=form.cleaned_data.get('username'), password=form.cleaned_data.get('password')) return HttpResponseRedirect(reverse('user:login')) else: return render(request, 'register.html', &#123;'errors': form.errors&#125;) 上述中User是引入自from django.contrib.auth.models import User , 是django自己提供供用户使用的模型, 对应在数据库中提供了一个名为auth_user的表 UserRegisterForm 是后续要添加表单验证的模块中的类, 此处需要引入from user.forms import UserRegisterForm form.is_valid() 返回表单验证的结果, 验证成功为True, 否则为False 创建用户使用 12# username为必填参数, 邮箱和密码可以为None(通常指定username和password即可)User.objects.create_user(username, email=None, password=None) form.cleaned_data 得到的是对表单数据验证成功后返回的字典, key就是所定义的类中名字 1&#123;'username': 'xxx', 'password': 'xxx' &#125; form.errors 是关于表单验证的错误内容的字典 获取值时, 尽量考虑字典的get()方法, 而不是[], 因为在某些情况下, 若得到值就返回错误. 登录登录与注册相比, 都会进行表单验证, 同时对于登录部分, 还需要验证用户和密码的正确性和可匹配到库, 还有为登录的用户创建会话id(sessionid) 和cookie值, 以表明用户身份.代码如下: 1234567891011121314151617def login(request): if request.method == 'GET': return render(request, 'login.html') if request.method == 'POST': data = request.POST form = UserLoginForm(data) if form.is_valid(): user = auth.authenticate(username=form.cleaned_data.get('username'), password=form.cleaned_data.get('password')) if user: auth.login(request, user) return HttpResponseRedirect(reverse('user:index')) else: return render(request, 'login.html', &#123;'err_pw': '账户或密码错误.'&#125;) else: return render(request, 'login.html', &#123;'errors': form.errors&#125;) UserLoginForm与UserRegisterForm 相同, 都是用户验证模块中的类, 引入自from user.forms import UserLoginForm auth 要从from django.contrib import auth中引入 123auth.authenticate(username=form.clean_data.get('username'), password=form.clean_data.get('password'))# 主要作用是将表单验证成功后的数据与数据库的auth_user表数据进行对比, 若是也能匹配成功, 此时会将用户定义为匿名用户(anonymous user) auth.login(request, user) 12# 负责登录操作, 向request.user赋值系统登录用户对象# 主要是对登录当前匿名用户给一个添加cookie中会话id(sessionid) 主页面此处仅用于测试, 但是主页面需要使用会话id的检测, 当然我们可以自己写相应的功能, 也可以借助django提供给我们使用的装饰器. 它来自from django.contrib.auth.decorators import login_required, 通过在函数上@login_required使用 1234@login_requireddef index(request): if request.method == 'GET': return render(request, 'index.html') 注销点击注销按钮, 然后退出登录, 并删除当前用户的会话id 12345@login_requireddef logout(request): if request.method == 'GET': auth.logout(request) return HttpResponseRedirect(reverse('user:login')) auth.login(request) 是django提供的用户注销的函数 表单验证详细通过在app 下新建一个forms.py文件，用户处理表单验证. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from django import formsfrom django.contrib.auth.models import Userclass UserRegisterForm(forms.Form): # 定义name字段, required字段为必填写字段 username = forms.CharField(max_length=10, min_length=4, required=True, error_messages=&#123; 'required': '姓名为必填项', 'max_length': '姓名最大长度10', 'min_length': '姓名最小长度4'&#125; ) password = forms.CharField(max_length=16, min_length=6, required=True, error_messages=&#123; 'required': '密码为必填项', 'max_length': '姓名最大长度16', 'min_length': '姓名最小长度6'&#125; ) password2 = forms.CharField(max_length=16, min_length=6, required=True, error_messages=&#123; 'required': '确认密码为必填项', 'max_length': '姓名最大长度16', 'min_length': '姓名最小长度6'&#125; ) def clean(self): # 获取用户名, 用于校验校验用户是否已经注册 username = self.cleaned_data.get('username') # 用于校验用户是否已经注册 user = User.objects.filter(username=username).first() if user: raise forms.ValidationError(&#123;'username': '账户已注册'&#125;) # 验证密码是否一致 if self.cleaned_data.get('password') != self.cleaned_data.get('password2'): raise forms.ValidationError(&#123;'password': '密码不一致'&#125;) return self.cleaned_dataclass UserLoginForm(forms.Form): # 定义name字段, required字段为必填写字段 username = forms.CharField(max_length=10, min_length=4, required=True, error_messages=&#123; 'required': '姓名为必填项', 'max_length': '姓名最大长度10', 'min_length': '姓名最小长度4'&#125; ) password = forms.CharField(max_length=16, min_length=6, required=True, error_messages=&#123; 'required': '密码为必填项', 'max_length': '姓名最大长度16', 'min_length': '姓名最小长度6'&#125; ) def clean(self): # 获取用户名, 用于校验校验用户是否已经注册 username = self.cleaned_data.get('username') # 用于校验用户是否已经注册 user = User.objects.filter(username=username).first() if not user: raise forms.ValidationError(&#123;'username': '该账户没有注册'&#125;) return self.cleaned_data errors_messaes 提供重写产生错误时提示消息, 可以改用汉语 其他 网页中关于错误的提示可以使用 123456&#123;% if errors.username %&#125; &#123;&#123; errors.username &#125;&#125;&#123;% endif %&#125;&#123;% if errors.password %&#125; &#123;&#123; errors.password &#125;&#125;&#123;% endif %&#125; ​ 自定义models 通过自定义需要的User模型，而不是使用django提供的模型 表达验证部分请参考上述系统models 和Views.py部分 中间件 中间件是Django请求/响应处理的钩子框架。它是一个轻巧的低级“插件”系统，用于全局改变Django的输入或输出。 每个中间件组件负责执行某些特定功能。例如，Django包含一个中间件组件 AuthenticationMiddleware，它将用户与使用会话的请求相关联。 Django附带了一些你可以直接使用的内置中间件。它们记录在内置中间件参考中。 在Django1.9 版本以上, MIDDLEWARE_CLASSES变成了MIDDLEWARE, 并且中间件的顺序也需要调整here. 小李子 1234567891011121314151617181920212223242526from django.utils.deprecation import MiddlewareMixinclass TestMiddleWare(MiddlewareMixin): def process_request(self, request): print('process_request1') # 继续执行视图函数 return None def process_response(self, request, response): print('process_response1') return responseclass Test2MiddleWare(MiddlewareMixin): def process_request(self, request): print('process_request2') # 继续执行视图函数 return None def process_response(self, request, response): print('process_response2') return response# 执行结果(若进返回一次HttpResponse对象)# process_request1 -&gt; process_request2 -&gt; process_response2 -&gt; process_response1 process_request和process_response是最常见的两个方法, 还有process_exception和process_view(共4个方法), 详见可参考这里 中间件执行是有顺序的 其中process_request是在执行views.py函数前执行的, 并且将所有process_request执行完毕, 在执行views函数, 在返回response对象时, 又回去执行process_response部分, 并且它的执行顺序刚好与process_requsest相反 添加文章 对于添加文章, 通常也是在用户登录的情况下进行的, 这里只做简单的添加上传 在models.py中添加模型 1234567891011121314151617class Article(models.Model): title = models.CharField(max_length=20) dec = models.CharField(max_length=100) img = models.ImageField(upload_to='article') create_time = models.DateTimeField(auto_now_add=True) class Meta: db_table = 'article' # upload_to=x 上传的位置, 当使用上传时, 会创建一个article的文件夹# auto_now_add=True 创建数据时自动增加当前时间# auto_now=True 修改数据时自动修改时间# 而通常我们将二进制类文件放置与media文件夹下, 此时需要配置media的全局参数(在setting.py添加以下)# media (媒体文件, 上传的文件)# MEDIA_URL = '/media/'# MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 添加路由 创建一个html文件, 写上传的页面, 使用继承 1234567891011121314&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;blog&#123;% endblock %&#125;&#123;% block body %&#125;&lt;form action="" method="post" enctype="multipart/form-data"&gt; 标题:&lt;input type="text" name="title"&gt;&lt;br&gt; 描述:&lt;textarea name="dsc" id="" cols="30" rows="5"&gt;&lt;/textarea&gt;&lt;br&gt; 图片:&lt;input type="file" name="img" &gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&#123;% endblock %&#125; enctype=&quot;multipart/form-data&quot; 12# application/x-www-form-urlencoded不是不能上传文件，是只能上传文本格式的文件# multipart/form-data是将文件以二进制的形式上传，这样可以实现多种类型的文件上传 &lt;imput type=&quot;file&quot;&gt; 上传文件 创建views.py 1234567891011121314def add2article(request): if request.method == 'GET': return render(request, 'add2article.html') if request.method == 'POST': # 获取数据 img = request.FILES.get('img') title = request.POST.get('title') dec = request.POST.get('dsc') # 创建文章 Article.objects.create(img=img, title=title, dec = dec) return HttpResponse('上传成功') 配置media 12345# media (媒体文件, 上传的文件)MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, 'media')# 配置后, 就能够识别到media路径, 然后之前的upload_to='article'的配置就会在media文件夹下创建article文件; 若不进行配置, 就会直接在工程主目录下创建一个article文件 查看文章 可以通过Article.objects.all() 获取所有的信息, 再到网页中进行遍历展示 通过在urls.py中修改路由, 在其后使用正则表达式, 添加一个主键id, 大概是这样子的:url(r&#39;show2article/(\d+)/&#39;, views.show2article, name=&#39;show2article&#39;),然后在views.py中添加执行函数 1234def show2article(request): if request.method == 'GET': articles = Article.objects.all() return render(request, 'show2article.html', &#123;'articles': articles&#125;) 分页操作 分页操作依赖于第三方库from django.core.paginator import Paginator 代码 123456789def article_list(request): if request.method == 'GET': page = request.GET.get('page', 1) articles = Article.objects.all() # 将所有文章进行分页, 每页最多4条记录 paginator = Paginator(articles, 4) # 获取当前显示页的文章信息 arts = paginator.page(page) return render(request, 'article_list.html', &#123;'arts': arts&#125;) request.GET.get(&#39;page&#39;, 1) get方式获取page属性值, 若没有, 赋其初值1 Paginator(articles, 4) 得到分页对象, 对articles对象进行分页, 每页4条记录.另外可以通过debug查看paginator还有什么属性 前台 1234567891011121314151617181920212223&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;分页&#123;% endblock %&#125;&#123;% block body %&#125; &#123;% for art in arts %&#125; 标题:&#123;&#123; art.title &#125;&#125;&lt;br&gt; 描述:&#123;&#123; art.dec &#125;&#125;&lt;br&gt; 图片:&lt;img src="/media/&#123;&#123;art.img&#125;&#125;" alt="" width="200" height="180"&gt;&lt;hr&gt; &#123;% endfor %&#125; &lt;p&gt; &#123;% if arts.has_previous %&#125; &lt;a href="&#123;% url 'user:article_list' %&#125;?page=&#123;&#123;arts.previous_page_number&#125;&#125;"&gt;上一页&lt;/a&gt; &#123;% endif %&#125; &#123;% for i in arts.paginator.page_range %&#125; &lt;a href="&#123;% url 'user:article_list' %&#125;?page=&#123;&#123;i&#125;&#125;"&gt;第&#123;&#123;i&#125;&#125;页&lt;/a&gt; &#123;% endfor %&#125; &#123;% if arts.has_next %&#125; &lt;a href="&#123;% url 'user:article_list' %&#125;?page=&#123;&#123;arts.next_page_number&#125;&#125;"&gt;下一页&lt;/a&gt; &#123;% endif %&#125; &lt;/p&gt;&#123;% endblock %&#125; arts.previous_page_number获取下一页的页码 arts.paginator.page_range获取页面页码的范围 arts.next_page_number获取下一页的页面 arts.has_previous判断是否有上一页 arts.has_next判断是否有下一页 日志 在settings中配置(可以去官方文档查看相应内容) 123456789101112131415161718192021222324252627282930313233# 配置日志LOGGING = &#123; # version 为定值1 &apos;version&apos;: 1, # 禁用日志 &apos;disable_existing_loggers&apos;: False, # 指定写入到日志文件中的日志格式 &apos;formatters&apos;: &#123; &apos;default&apos;: &#123; &apos;format&apos;: &apos;%(name)s %(asctime)s %(message)s&apos; &#125; &#125;, # &apos;handlers&apos;: &#123; &apos;console&apos;: &#123; &apos;level&apos;: &apos;INFO&apos;, &apos;filename&apos;: &apos;%s/log.txt&apos; % os.path.join(BASE_DIR, &apos;logs&apos;), &apos;formatter&apos;: &apos;default&apos;, # 当文件大于5M, 则自动备份 &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;maxBytes&apos;: 5 * 1024 * 1024, &#125; &#125;, &apos;loggers&apos;: &#123; &apos;&apos;: &#123; &apos;handlers&apos;: [&apos;console&apos;], &apos;level&apos;: &apos;INFO&apos; &#125; &#125;,&#125; 日志记录非常适合写在中间件中 123456789101112131415161718192021222324252627282930import timeimport loggingclass LoggingMiddleware(MiddlewareMixin): def process_request(self, request): # 记录当前请求访问服务器的时间 request.init_time = time.time() request.init_body = request.body return None def process_response(self, request, response): try: # 记录返回响应时间和访问服务器的时间差(访问耗时),记录返回状态码 times = time.time() - request.init_time # 响应状态码 s_code = response.status_code # 响应的内容 resp_body = response.content # 请求内容 req_body = request.init_body #日志信息 msg = &apos;%s %s %s %s&apos; % (times, s_code, resp_body, req_body) # 写入日志 logging.info(msg) except Exception as e: logging.critical(&apos;log error, Exception: %s&apos; % e) return response django官方文档1.11版本日志部分]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PEP8]]></title>
    <url>%2F2018%2F10%2F26%2FPEP8%2F</url>
    <content type="text"><![CDATA[概观 PEP8 内容 缩进 123456789101112131415161718192021222324252627282930311.每一级缩进4个空格(在pycahrm或其他IDE中, 所使用的tab, 系统会自动给转换成4个空格)2.python3不允许空格与制表符混用3.python是优先考虑4个空格# 与左括号对齐foo = long_function_name(var_one, var_two, var_three, var_four)# 用更多的缩进来与其他行区分def long_function_name( var_one, var_two, var_three, var_four): print(var_one)# 悬挂缩进应该再换一行foo = long_function_name( var_one, var_two, var_three, var_four) # 对于数组或元组字典, 考虑使用悬挂缩进my_list = [ 1, 2, 3, 4, 5, 6, ] # 或者my_list = [ 1, 2, 3, 4, 5, 6,] ​ 单行最大行宽限制79个字符, 文档和注释限制72个字符 1234# 换行处理,以下两个方面。# 使用小括号/中括号/大括号会隐式换行(元组/列表/字典)# 使用反斜杠 \ 进行换行 二元运算符在前或在后换行不做约束, 但是在运算符前换行更容易被理解 空行 123# 顶层函数和类的定义，前后用两个空行隔开。 # 类里的方法定义用一个空行隔开。 # Python接受control-L（即^L）换页符作为空格；许多工具把这些字符当作页面分隔符，所以你可以在文件中使用它们来分隔相关段落。请注意，一些编辑器和基于Web的代码阅读器可能无法识别control-L为换页，将在其位置显示另一个字形。 源文件编码 1234# Python核心发布版本中的代码总是以UTF-8格式编码（或者在Python2中用ASCII编码）。 # 使用ASCII（在Python2中）或UTF-8（在Python3中）编码的文件不应具有编码声明。 # 对于Python 3和更高版本，标准库规定了以下策略（参见 PEP 3131）：Python标准库中的所有标识符必须使用ASCII标识符，并在可行的情况下使用英语单词（在许多情况下，缩写和技术术语是非英语的）。此外，字符串文字和注释也必须是ASCII。唯一的例外是（a）测试非ASCII特征的测试用例，以及（b）作者的名称。作者的名字如果不使用拉丁字母拼写，必须提供一个拉丁字母的音译。 鼓励具有全球受众的开放源码项目采取类似的政策。 导入import 12345678# 导入分组顺序# 1. python标准库# 2. 相关第三方库导入# 3. 本地库/应用导入# 在每组的导入间使用换行# 推荐使用绝对路径进行导入, 因为它更容易理解, 报错时也更容易查出 模块级’呆’名 1234567891011# 像__all__ , __author__ , __version__ 等这样的模块级“呆名“（也就是名字里有两个前缀下划线和两个后缀下划线），应该放在文档字符串的后面，以及除from __future__ 之外的import表达式前面。Python要求将来在模块中的导入，必须出现在除文档字符串之外的其他代码之前。 # 例如:from __future__ import barry_as_FLUFL__all__ = ['a', 'b', 'c']__version__ = '0.1'__author__ = 'Cardinal Biggles'import osimport sys 字符串引号 123# 单引号和双引号作用一致, 但是对于一个文件应该使用相同的字符引号# 对于三引号字符串, 推荐使用双引号字符 空格的使用 12345678910111213141516171819202122232425262728# 小括号、中括号、大括号后不要使用空格# 逗号,冒号,分号之前不使用空格(之后通常使用空格, 避免字符与空格混淆,不易发觉)# 对于冒号# 左右应该使用相同的空格, 下列为推荐的格式ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]ham[lower:upper], ham[lower:upper:], ham[lower::step]ham[lower+offset : upper+offset]ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]ham[lower + offset : upper + offset]# 二元操作符左右使用空格, 但是对于优先级差异的运算, 应该对低优先的二元运算符使用空格, 例如:i = i + 1submitted += 1x = x*2 - 1hypot2 = x*x + y*yc = (a+b) * (a-b)# 对于关键字参数或默认值参数, 不要使用空格def complex(real, imag=0.0): return magic(r=real, i=imag)# 对于功能型注释, -&gt; 左右给空格def munge() -&gt; AnyStr: ... # 有类型备注的参数赋值, 在=符号左右给空格def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ... 其他 1234567# 同一行不要有多条语句# 对于if/ while/else 类的若其后的代码块只有1句, 也最好换行if foo == 'blah': do_blah_thing()else: do_non_blah_thing() 注释 12345678# 行内注释# 有节制地使用行内注释。 # 行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始。# 块注释# 块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 # 块注释内部的段落通过只有一个#的空行分隔。 文档说明 123# 要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。# 多行文档说明使用的结尾三引号应该自成一行# 对于单行的文档说明，尾部的三引号应该和文档在同一行。 命令风格 12345678910# b（单个小写字母）# B（单个大写字母）# lowercase 小写字母# lower_case_with_underscores 使用下划线分隔的小写字母# UPPERCASE 大写字母# UPPER_CASE_WITH_UNDERSCORES 使用下划线分隔的大写字母# CapitalizedWords（或者叫 CapWords，或者叫CamelCase 驼峰命名法 —— 这么命名是因为字母看上去有起伏的外观5）。有时候也被称为StudlyCaps。 # 注意：当在首字母大写的风格中用到缩写时，所有缩写的字母用大写，因此，HTTPServerError 比 HttpServerError 好。# mixedCase（不同于首字母大写，第一个单词的首字母小写）# Capitalized_Words_With_Underscores（丑陋！） 命令约定 12345678910111213141516171819202122232425262728293031# 规避的名字#永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。 #在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。# 模块# 模块应该用简短全小写的名字，如果为了提升可读性，下划线也是可以用的。# 当使用C或者C++编写了一个依赖于提供高级（更面向对象）接口的Python模块的扩展模块，这个C/C++模块需要一个下划线前缀（例如：_socket）# 例如: datetime# 包名# Python包名也应该使用简短全小写的名字，但不建议用下划线。 # 例如: static# 类名# 类名首字母大写的单词串 # 例如: MyClass# 函数# 通常使用小写, 为了提高可读性可以用下划线分隔。# 例如: my_first_day# 函数或方法参数# self 始终作为实例方法的第一个参数# cls 始终作为类方法的第一个参数# 若函数的参数名与已有的关键词冲突, 在参数名后加一个下划线比乱起名字打的好# 例如: class_ 比 clss 好# 常量# 通常使用下划线分割的全大写组成# 例如: MAX_DOODS_LENGTH 或 TOTAL 编程建议 12345678# 使用 is not 运算符，而不是 not … is 。虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑。 ( 直接not不好吗? :( )# 例如： if b is None: 或者 if b is not None# 当使用富比较（rich comparisons，一种复杂的对象间比较的新机制，允许返回值不为-1,0,1）实现排序操作的时候，最好实现全部的六个操作符（__eq__, __ne__, __lt__, __gt__, __ge__）而不是依靠其他的代码去实现特定的比较。 # 和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符。 # 始终使用def表达式，而不是通过赋值语句将lambda表达式绑定到一个变量上。(不好说) ​]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PEP8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django]]></title>
    <url>%2F2018%2F10%2F22%2FDjango%2F</url>
    <content type="text"><![CDATA[Django 简介 Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型model，视图(view)和控制器(controller)。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。 django1.11官方文档… MVC框架模式 MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。核心思想是解耦合。 model 指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 view 指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。 controller 是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 MVC的优缺点: 12优点: 耦合性低, 重用性高, 部署快, 生命周期成本低, 可维护性高缺点: 不易完全理解, 调试很麻烦, 不适合中小规模的应用程序, 系统结构和实现变复杂 MVT框架模式(Django采用) model 与MVC中的M功能相同，负责和数据库交互，进行数据处理。 view 与MVC中的C功能相同，接收请求，进行业务处理，返回应答。 template 与MVC中的V功能相同，负责封装构造要返回的html。 虚拟环境 安装虚拟环境 pip install virtualenv VENV使用 参数说明: -p 指定版本 –no-site-packages 指定纯净模式下安装 virtualenv –no-site-packages -p d:\python\python.exe djvenv 安装虚拟环境 pip -h 查看帮助 pip list 查看安装的包 pip freeze 查看版本 python -m pip install –upgrade pip 升级pip命令 如上 在djvenv/script 执行activate 就会进入虚拟环境, 使用deactivate退出虚拟环境 安装Django 进入对应的虚拟环境下进行安装 pip install django==1.11 创建项目 django-admin startproject &lt;projec-name&gt; 项目文件说明 manage.py 工具集管理文件 settings.py 项目配置文件 urls.py 资源定位文件 wsgi.py 即Python Web Server Gateway Interface python关于web服务器网关接口, 是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标 __init__.py 文件 运行服务 方式1–通过终端terminal python manage.py runserver 运行服务 python manage.py runserver 0.0.0.0:8080 指定可访问的站点和端口号运行服务, 0.0.0.0 表示所有人都能访问 123错误:1.Error: [WinError 10013] 以一种访问权限不允许的方式做了一个访问套接字的尝试。通常是端口已经被占用, 可以在terminal中使用 netstat -ano|findstr &lt;port&gt; 查看段口是否被占用, 解决方式: 换个端口 方式2–修改配置edit configurations Script path选择项目的manage.py文件 Parameters写入runserver [port](默认8000) 数据库配置 在settings中配置 1234567891011# 此处使用的是mysql数据库DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django', # 数据库名 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': '3307' # 通常是3306, 可以通过--&gt; 运行--&gt; services.msc查看对应的mysql服务的端口 &#125;&#125; pip install pymysql 安装需要的包 在__init__.py文件中配置, 进行初始化数据库的驱动 (因为python3不提供MYSQLdb 这个驱动, 必须导入) 12import mysql pymysql.install_as_MySQLdb() python manage.py migrate进行信息迁移(映射模型到数据库中), 在修改好数据库配置信息后, 会自动在指定的数据库生成一系列的表 12345auth_group/auth_group_permissions/auth_permission/auth_user/auth_user_groups/auth_user_user_permissions #6个关于用户、用户组及其权限相关的表django_admin_log # 用户日志表django_content_type # 内容类型表django_migrations # 信息迁移表django_session # session表 python manage.py createsuperuser 创建超级管理员 , 然后可以通过http://127.0.0.1:8000/admin访问 登录后台 创建APP django-admin startapp &lt;app-name&gt;/ python manage.py startapp &lt;app-name&gt; 在控制台创建app的命令 ORM对象关系映射 ORM 即object relational mapping对象关系映射 ORM应用流程 在当前的app中models.py 文件中创建一个类对象, 需要导入from django.db import models 注: 若使用类Meta 下定义了db_table = &#39;student&#39;, 在数据库中表名就是student, 否则数据库的表名就是appname_classname (app_Student) 在当前的app中views.py 定义一个自己需要的功能的方法, 这个方法可将将上述的类进行关联, 能使用ORM 形式访问和修改数据库. 上述添加信息与Students.objects.create(s_name=&#39;大荒&#39;)等价 123# 若使用对应的模块需要引入from django.http import HttpResponse # 引入http模块中HttpResponse响应方法from app.models import Students # 在app.models模块中引入需要使用的Sudents类 在项目同名文件中urls文件中, 添加需要url, 如: 在项目同名文件中setting.py文件中, 修改INSTALLED_APP中添加当前的app 配置迁移文件python manage.py makemigrations 进行迁移文件到数据库 python manage.py migrate 查询 all() 查询所有对象信息 filter() 过滤查询 1234567891011# 过滤查询stus = Students.objects.filter(s_name = '小明') #返回的是一个QuerySet对象# 注意: 若上述的过滤查询没有结果, 返回的是QuerySet为空. 因此, 与get()相比, filter() 方法更适用.# first和last方法被all和filter支持first() #获取第一个last() #获取最后一个# 可以同时使用多次过滤或者一次过滤多个条件stus = Students.objects.filter(s_age=20, s_gender=1)stus = Students.objects.filter(s_age=20).filter(s_gender=1) get() 获取确定的唯一一个结果 12stus2 = Students.objects.get(s_age = 20) #返回的是一个Students对象# 注意：若上述的查询没有结果或查询的结果有多个, 就会返回错误 模糊查询 sql中使用like &#39;%xxx%&#39; 包含x的情况 1stus = Students.objects.filter(s_name__contains='武') &#39;_xxx&#39; 以_开头 1stus = Students.objects.filter(s_name__startswith='武') xxx_ 以_结束 1stus = Students.objects.filter(s_name__endswith='武') 大于/大于等于 gt/gte 小于/小于等于lt/lte 12stus = Students.objects.filter(s_age__gt=18)stus = Students.objects.filter(s_age__gte=20) 排序 order_by() 12345# 升序stus = Students.objects.order_by('id')# 降序pystus = Students.objects.order_by('-s_name') 查询不满足条件的数据 exclude() 12# 查询不满足id小于等于10的数据stus = Students.objects.exclude(id__lte=10) 统计查询的结果数 count()或len() 12stus_count = stus.count()stus_count = len(stus) 取值可带参数 values() 12stus = Students.objects.values()stus = Students.objects.values('s_name') 主键的字段名和pk等价 12stus = Students.objects.filter(id=10)stus = Students.objects.filter(pk=10) Q() 方法: 用于对一条记录的多个字段进行操作 12345678# 或条件 Q()|Q()stus = Students.objects.filter(Q(s_age = 15) | Q(s_gender = 0))# 且条件 Q()&amp;Q()stus = Students.objects.filter(Q(s_age = 15) &amp; Q(s_gender = 0))# 非条件 ~Q()stus = Students.objects.filter(~Q(s_age = 20)) F() 方法: 用于对多条记录的一个字段进行操作 12# 查询语文成绩比数学成绩大10分 的学生信息stus = Students.objects.filter(chinese__gt=F('mathematics') + 10) ​ 修改 写修改的相关方法, 具体的修改语句为 &lt;object&gt;.objects.filter(field=xxx...).update(field=xxx...) 删除 写删除的相关方法, 具体删除语句为&lt;object&gt;.objects.filter(field=xxx...).delete() 模板层使用 拓展数据表 对于实际应用而言, 如学生信息的电话号码, 地址不是学生的必要信息时, 我们通常将他们拓展到另外的表中, 便于管理, 如下: 创建模板层目录 在项目主目录下, 新建一个名为templates 的目录, 其中放置html文件 此时为了使templates生效, 需要在settings.py文件进行配置TEMPLATES项 12345注:# os.path.abspath(__file__) 当前文件的绝对路径# os.path.dirname(os.path.abspath(__file__)) 当前文件的绝对路径的上一级路径# BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# os.path.join(a, b) 是将b拼接在a后面 模板继承 注释 &lt;!--xx--&gt; html中提供的注释方法, 但是注释内容会在网页中显示. Django中对网页内容的单行注释, 注释内容网页中不显示. Django中对网页内容的多行注释, 注释内容在网页中不显示. 12&#123;% comment %&#125; &#123;% endcomment %&#125;# 注: django中标签语法&#123;% xxx %&#125;与hexo转换md文件使用到nunjucks语法冲突,错误如下图. 解决方法(将这部分放在md格式下的多行注释部分即可) ​ 继承 通常我们对于一系列具有相同内容的网页, 通常使用模板的方式让子网页去继承模板网页中base.html的内容. 在模板网页内容中, 尽量不去放置标签/css/js, 可以再创建一个base_main.html 让它继承base.html , 然后其他子页面再去继承base_main.html 父模板base.html, 在父模板中定义block的位置(挖坑) 1&#123;% block xxx %&#125; &#123;% endblock %&#125; 子模板index.html , 在子模板中填写block(填坑) 12&#123;% extends &apos;base.html&apos; %&#125;&#123;% block xxx %&#125; contents &#123;% endblock %&#125; 标签 1&#123;% tag %&#125; &#123;% endtag %&#125; for 使用方法 123&#123;% for stu in students %&#125; &lt;p&gt;姓名: &#123;&#123;stu.s_name&#125;&#125;, 年龄: &#123;&#123;stu.s_age&#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; safe 12# 阻止转义, 即是阻止django将html语言的关键字过滤掉&#123;% var|safe %&#125; ifequal 1234# 如果变量var的值等于value&#123;% ifequal var value %&#125; &#123;% else %&#125; &#123;% endifequal %&#125; extends 12# 继承某个页面(html)&#123;% extends &apos;base.html&apos; %&#125; ​ 更多标签从这儿寻找 变量 变量从context中输出一个值, 它是一个类似于dict的对象, 将键映射到值 通过字典查找, 属性查找, 列表索引查找 使用点表示法实现 123456# 字典查找&#123;&#123; my_dict.key &#125;&#125;# 属性查找&#123;&#123; my_object.atrribute &#125;&#125;# 列表索引查找&#123;&#123; my_list.0 &#125;&#125; 对于context中输出的值, 也可以通过其一对一,一对多,多对多的特性得到其他的对象 12# 在views.py中返回context中含stu对象, 通过反向查询得到stu.studentinfo对象,获取其phone属性&#123;&#123;stu.studentinfo.phone&#125;&#125; forloop 使用方法 1234forloop.counter - 排序,依次递增序号,1开始forloop.counter0 - 排序,依次递增序号,0开始forloop.revcounter0 - 逆序,依次递减序号,0结束forloop.revcounter0 - 逆序,依次递减序号,1结束 block super 1234# 引用上级代码块, 并且能在其后作出修改(若不修改, 直接使用继承的block就好)&#123;% block js %&#125; &#123;&#123; block.super &#125;&#125;&#123;% endblock %&#125; ​ 过滤器 通过管道进行数据的过滤或转换 123456注:使用过滤器达到整除的目的&#123;% if forloop.counter|divisibleby:&quot;2&quot;%&#125; xxx&#123;% else %&#125; xxx&#123;% endif %&#125; 详情请见官方文档… static文件的引入 在django工程目录下创建static文件夹 在settings.py文件下配置, 找到STATIC_URL=&#39;/static&#39; , 在它的下面添加 1234STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static') ] 前端引入 方式一: 12345# 使用&#123;% load static %&#125;&#123;% block css %&#125; &#123;% load static %&#125; &lt;link href="&#123;% static 'css/index.css' %&#125;" rel="stylesheet"&gt;&#123;% endblock %&#125; 方式二: 直接使用绝对路径 1&lt;link href="/static/css/index.css" rel="stylesheet"&gt; urls.py的包含关系 我们在新建工程时, 会生成一个和工程同名的目录, 其下urls.py 用于路由识别. 但是开发中, 为了不使这个文件过于繁重, 也便于管理app; 我们在每个app的下面都创建一个urls.py文件, 那么如何使这个文件有效呢? 项目文件下的urls.py 其实是包含着app中的urls.py, 我们需要在项目文件下的urls.py中修改 12# 1. Import the include() function: from django.conf.urls import url, include# 2. Add a URL to urlpatterns: url(r'^blog/', include('blog.urls')) 这样子, 当我们访问某个路由时, 使用http://xxx.xxx.xxx.xxx/blog/url_name/ 进行访问. views.py 返回值辨析HttpResponse /HttpResponse/render 123# 从第三方库引入from django.http import HttpResponse, HttpResponseRedirectfrom django.shortcuts import render 1234567891011121314151617181920212223# render()render(request, template_name, context=None, content_type=None, status=None, using=None)# 对指定模板template与给定的上下文context结合, 并返回HttpResponse具有该呈现文本的对象。(下述有例子)# 1. 必须参数# request:用于生成此响应的请求对象# template_name:要使用的模板的全名或模板名称的序列。如果给出序列，则将使用存在的第一个模板。# 2. 可选参数# context:要添加到模板上下文的值的字典。# content_type:用于生成的文档的MIME类型。默认为DEFAULT_CONTENT_TYPE设置的值。# status:响应的状态代码, 默认200# using:该NAME模板引擎的使用加载的模板。def my_view(request): # View code here... return render(request, 'myapp/index.html', &#123; 'foo': 'bar', &#125;, content_type='application/xhtml+xml')# 相当于:def my_view(request): # View code here... t = loader.get_template('myapp/index.html') c = &#123;'foo': 'bar'&#125; return HttpResponse(t.render(c, request), content_type='application/xhtml+xml') 123# 类HttpResponse()return HttpResponse(&apos;msg&apos;)# 在网页做出处理后返回响应信息 1234# 类HttpResponseRedirect()return HttpResponseRedirect('/source/')# 它是HttpResponse()的子类# 对指定的路由(source)进行重定向处理, http状态码302(找到重定向) ​ url指定路径 123456789101112131415161718# 实现重定向到指定路径的方法# 第一种, 地址直接给硬编码return HttpResponseRedirect('/app/index/')# 第二种, 使用反向解析 reverse('namespace:name')return HttpResponseRedirect(reverse('rzlong:all_stu'))# 注: from django.urls import reverse# reverse('namespace:name') namespace就是工程下urls中include这个app的url指定的别名; name就是app下url的别名# 对应在模板中的使用# urls.py配置url(r'^edit_stu/', views.edit_stu, name='edit_stu')url(r'^edit_stu/(\d+)/', views.edit_stu, name='edit_stu')# 地址硬编码# &lt;a href="/app/edit_stu/?stu_id=&#123;&#123;stu.id&#125;&#125;"&gt; 带参数# &lt;a href="/app/edit_stu/&#123;&#123; stu.id &#125;&#125;/"&gt; 不带参数# 反向解析# &lt;a href=" &#123;% url 'rzlong:edit_stu' stu.id %&#125;"&gt; 不带参数 ​ Template使用过程 查询 1.在urls.py中添加查询的路由地址 1234urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^all_stu/', views.all_stu),] 2.在views.py中添加需要使用到的方法(访问路由需要使用方法/功能) 123456def all_stu(request): stus = Students.objects.all() # 返回页面 return render(request, 'stus.html', &#123;'students':stus&#125;)# 通过传递context到html文件中以达到填充模板的目的# render() 中返回时Unicode对象, Django也一致使用Unicode编码的字符 3.在stus.html中使用 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% for stu in students %&#125; &lt;p&gt;姓名: &#123;&#123;stu.s_name&#125;&#125;, 年龄: &#123;&#123;stu.s_age&#125;&#125;&lt;/p&gt; &#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 增加 1.在urls.py增加路由信息 1url(r'add_info/', views.add_info) 2.新增add_info方法 1234def add_info(request): # method 获取请求HTTP方法 if request.method == 'GET': return render(request, 'info.html') ​ 3.修改(新增)stus.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for stu in students %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;stu.s_name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;stu.s_age&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href="/add_info/?stu_id=&#123;&#123; stu.id &#125;&#125;"&gt;添加拓展表信息&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 4.增加info.html文件 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="post"&gt; 电话号码: &lt;input type="text" name="phone"&gt; 地址: &lt;input type="text" name="address"&gt; &lt;input type="submit" value="提交"&gt; &#123;% csrf_token %&#125; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 5.在views中修改相应函数add_info() 12345678910111213141516def add_info(request): # method 获取请求HTTP方法 if request.method == 'GET': return render(request, 'info.html') if request.method == 'POST': phone = request.POST.get('phone') address = request.POST.get('address') stu_id = request.GET.get('stu_id') # 保存 StudentInfo.objects.create( phone=phone, address=address, stu_id=stu_id ) return HttpResponse('创建扩展表信息成功') 拓展查询 在urls.py中添加路由信息 12url(r'^sel_info_by_stu', views.sel_info_by_stu),url(r'^sel_stu_by_info', views.sel_stu_by_info), 在views.py添加执行的函数 1234567891011121314151617def sel_info_by_stu(request): if request.method == 'GET': stu = Students.objects.get(s_name='lee') # 方式一 获取关联表对象 # info = StudentInfo.objects.filter(stu_id=stu.id) ## 等价于 info = StudentIndo.objects.filter(stu=stu) # 方式二 学生对象关联模型名的小写 info = stu.studentinfo print(info.address) return HttpResponse('通过学生表查学生信息扩展表')def sel_stu_by_info(request): if request.method == 'GET': info = StudentInfo.objects.get(phone='13547191919') student =info.stu print(student.s_name) return HttpResponse('通过扩展表查看学生信息表') 关联关系 一对一 对两张表中的任意一张表, 使用OneToOneFiled , 指定一对一的关联 123456789class TempleA: id = xx b = OneToOneField(TempleB) class TempleB: id = xx #正向: 查找b对象(通过a对象): a.b#反向: 查找a对象(通过b对象): b.templeb(类名的小写) 一对多 对两张表中选择 “多” 的表, 使用ForeignKey , 指定一对多的关联. (TempleA 属于”多”的表) 12345678910class TempleA: id = xx b = ForeignKey(TempleB, null=False) class TempleB: id = xx # 正向查询: 查找b对象(通过a对象): a.b# 反向查询: 查找a对象(通过b对象): b.templeb_set# 添加直接使用 create()方法 多对多 对两张表中任意选择一张表, 使用ManyToManyField , 指定多对多的关联。 当我们对两张表进行数据库迁移的时候, django为我们会自动生成了两张表之间的关系表。 12345678910class TempleA: id = xx b = ManyToManyField(TempleB) class TempleB: id = xx 注: 正向查询: 查找b对象(通过a对象): a.b反向查询: 查找a对象(通过b对象): b.templeb_set 多对多的添加: 1234# 反向添加stu.course_set.add(course)# 正向添加course.stu.add(stu) 多对多的删除 1234# 反向删除stu.course_set.remove(course)# 正向删除course.stu.remove(stu) 响应重定向需要引入HttpResponseRedirect 123from django.http import HttpResponse, HttpResponseRedirect# 使用响应重定向在后续操作执行完后又会回到指定路由位置return HttpResponseRedirect('/all_stu/',) user模块案例 详情请点击… 权限控制 详情请点击… Debug 通过dubug (step into my code)--&gt; console --&gt; show the prompt, 然后可以访问查看各种数据。 附录 ##pycharm语法 123ctrl d 复制光标所在行(选中多行后, 复制多行)ctrl y 删除alt enter 快速导入]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis first time]]></title>
    <url>%2F2018%2F10%2F18%2Fredis-first-time%2F</url>
    <content type="text"><![CDATA[简述redis redis 即remote dictionary server, 主要用于高速缓存, 去优化系统的的性能. redis通常放置体量小的热点数据, 体量大的数据放置在MySQL/ MangoDB 更合适. 安装redis 1.在redis.cn中可以找到下载源文件链接wget &lt;download site&gt; 2.对下载的文件解压缩 gunzip &lt;file&gt; 3.对解压缩的文件进行解归档 tar &lt;file&gt; 4.进入解归档的文件, 发现它已经有了makefile 的文件, 就不用进行进行配置, 直接构建安装 make &amp;&amp; make install 启动redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647方式一:修改默认配置文件redis.conf后再运行#1 ifconfig -- 私网172.18.170.112(在文件中修改bind字段的ip地址)#2 redis端口(merz) 6379(port)#3 (/requirepass) --修改 requirepass 口令#4 (/appendonly ) --修改 appendonly yes ,它会在创建服务器的时候, 生成appendonly.aof的文件, 存储的是每次执行的命令, 当你退出后在进入的时候, 若没有dump.rdb文件就执行所有的命令, 以达成数据持久化.注: rdbcompression yes 默认设置yes, dbfilename dump.rdb 就是默认存储所处理的数据的文件, 能达到数据持久化.foo bar配置哨兵(当主服务器崩掉, 利用哨兵选取新的主服务器)sentinel.confcp redis / sentinel.conf .配置: sentinel monitor mymaster &lt;masterip&gt; &lt;masterport&gt; &lt;int(哨兵数量投票数量)&gt;sentinel down-ater-milliseconds mymaster 10000 主机mymaster挂掉10秒就重新选主服务器sentinel failover-timeout mymaster 180000 故障恢复时间内, 若前服务器重连就使他加入努力， 否则删除主从服务群启动哨兵模式redis-server sentinel.conf --sentinel slaveof no one摆脱奴隶info replication120.77.222.217awk 文字处理grep -v op 不要带op的一一行xargs kill 将前面的输出作为kill的参数传入redis-server 虽然可以直接启动,但是使用的是默认的配置redis-server redis.conf &amp; 后台运行redis服务器redis-server redis.conf &gt; redis.log &amp; 后台启动服务器并输出重定向redis.log文件redis-cli -h ip(对自己用私网id, 对别人用公网ip)方式二:直接在redis-server后接参数启动redis-server --port 6379 --requirepass 123123 --appendonly yes &gt; redis.log &amp;flushall 删除当前库所有数据flushdb 删除所有库所有数据select 1 切换数据库(redis默认启动了16个库)save 同步保存bgsave 异步保存测试吞吐量redis-benchmark -h 公网ip -a passwd 关闭redis服务器 1234关闭redis服务1. ps -ef | grep redis 然后再kill psid2.将后台进程转到前台 -- fg %编号 再使用ctrl c关闭3.在客户端使用shutdown string字符串 12345678910111213set key value -&gt; 设置键值对set key value ex 1000 设置键值对存活(exists) 1000s- ttl key 查看对应键超时时间(time to live) -1为永不超时 -2已经超时- expire key time 指定超时时间get key 查看对应键的值exists key 查看键是否存在del key key可以是多个keys * 查看多有键setnx key value 若key不存在就添加键值对(set not exists)setex key ttl value 设置键值对的时候必须指定超时时间mset key1 value1 key2 value2... 可以同时指定多条数据mget key1 key2... 可以同时获取多条数据若key对应的value是数值时,可以使用incr key增加 decr key减少 hash哈希表 12345678910hset key field value 添加hash对象hget key filed 获取hash对象指定的字段hgetall key 获取hash对象所有键值对hvals key 获取hash对象的所有valuehmset key filed1 value1 filed2 value2...同时指定hash对象的多个字段hdel key filed 删除hash对象指定的字段hexists key filed 检查hash对象有没有指定的字段hkeys key 显示hash对象有哪些键hlen key 显示hash对象有几个键值对hscan key cursor遍历hash对象键值对, 若(1)中为0, 表示已经没有可遍历的对象, 若(1)中大于0, 表示还有可遍历的hash对象 list列表 123456lpush key value [value...] 从list对象的左边放入rpush key value [value...] 从list对象的右边放入lpop key 从list对象的左边取出一个值rpop key 从list对象的右边取出一个值lrange key start end 从左边找到list[start, end]rpoplpush key1 key2 从key1的右边取值再放到key2的左边 set集合 12345678910sadd key value [values...] 往集合中加入元素scard key 查看集合中有几个元素(有自动去重)sinter key1 key2 求集合key1和集合key2的交集sunion key1 key2 求集合key1和集合key2的并集sdiff key1 key2 求集合key1和集合key2的差集sismember key value 判断集合key中有没有valuesmembers key 查看集合key中所有元素srandmember key 从集合key中随机取一个元素spop key 从集合key中随机删除一个元素srem key value 从集合key中指定的删除一个元素 SortedSet有序集合 12zadd key score number [socre number...] 添加有序集合zrange key start stop 查看key[start, stop] 之间所有number 主从复制 123456修改redis.conf文件slaveof &lt;master_ip&gt; &lt;master_port&gt;masterauth &lt;passwd&gt;redis-cli 连接自己的redis服务器info replication 查看主从状态信息 参考文档 123redis.io resis官网resis.cn resis中文版redisdoc.com 提供redis参考文档]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql&python]]></title>
    <url>%2F2018%2F10%2F17%2Fmysql-python%2F</url>
    <content type="text"><![CDATA[python -m venv venv 安装虚拟环境 pycharm下载包 打开pycharm–&gt;File–&gt;Settings–&gt;Project Interpreter –&gt; 点击+–&gt; 输入需要的包名进行下载 使用import you_need_package –&gt; 会报错, 点击灯泡, 选择install package you_need_package 在terminal –&gt; pip install you_need_package 通常会使用国外的文件镜像, 比较慢,可以使用doubanio 速度很快, 具体如下: 12345# 1.在用户主目录 c:\user\administrator 下创建pip目录# 2.在pip目录中创建pip的文件, 修改器后缀名 ini , 注意要将文件的隐藏后缀.txt 去掉(工具-文件夹选项-查看-去除 隐藏已知文件的扩展名)# 3.在pip.ini的文件中,写入:[global]index-url=https://pypi.doubanio.com/simple pymysql conn = pymysql.connect() 建立连接 123456789options:host=&apos;localhost&apos;port=3306db=&apos;db_hrs&apos;user=&apos;root&apos;passwd=&apos;123456&apos;charset=&apos;utf8&apos; 字符集设置autocommit=&apos;true&apos; 自动提交事务cursorclass=pymysql.cursors.DictCursor cursor = conn.cursor() 创建游标 cursor.execute(sql) 执行sql语句, 它返回的是影响后的行数 cursor.fetchone() 获取查询到下一条记录 cursor.fetchall() 获取查询到的全部结果行 cursor.fetchmany(size) 获得查询到的size条记录 conn.commit() 提交事务(若没有设置自动提交事务, 则需手动添加该语句) conn.rollback() 事务回滚 conn.close() 关闭连接 instance: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import pymysqlclass Dept(): def __init__(self, no, name, loc): self.no = no self.name = name self.loc = locdef main(): # 1.create db connection conn = pymysql.connect(host=&apos;localhost&apos;, port=3307, db=&apos;hrs&apos;, user=&apos;root&apos;, passwd=&apos;123456&apos;, charset=&apos;utf8&apos;, autocommit=&apos;true&apos;, cursorclass=pymysql.cursors.DictCursor) try: # 2. 获得游标对象 with conn.cursor() as cursor: # 3.向数据库服务器发出sql # result = cursor.execute(&apos;update tbdept set dname=%s, dloc=%s where dno=%s&apos;,(name, addr, no)) cursor.execute(&apos;&apos;&apos;select dno as no, dname as name, dloc as loc from tbdept&apos;&apos;&apos;) datas = cursor.fetchall() # 查3条记录 # datas = cursor.fetchmany(3) print(datas) # 方法 1 # for data in datas: # print(f&apos;部门编号:&#123;data[0]&#125;\n部门名称:&#123;data[1]&#125;\n部门地址:&#123;data[2]&#125;\n&apos;) # 方法 2 # for data in datas: # print(f&apos;部门编号:&#123;data[&quot;no&quot;]&#125;&apos;) # print(f&apos;部门名称:&#123;data[&quot;name&quot;]&#125;&apos;) # print(f&apos;部门地址:&#123;data[&quot;loc&quot;]&#125;&apos;) # print(&apos;-&apos;.ljust(30,&apos;-&apos;)) # 方法 3 for data in datas: dept = Dept(**data) print(dept.no, end=&apos; &apos;) print(dept.name, end=&apos; &apos;) print(dept.loc, end=&apos; &apos;) print() conn.commit() except pymysql.MySQLError: print(&apos;error&apos;) conn.rollback() finally: conn.close()if __name__ == &apos;__main__&apos;: main() ​]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql&amp;python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用命令]]></title>
    <url>%2F2018%2F10%2F16%2Fwindows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[基础命令 cmd 命令提示符(command) mspaint 画图 osk 打开屏幕键盘(open screen keyboard) calc 打开计算器 (calculator) taskmgr打开任务管理器（task manager）与ctrl+windows delete相同 msconfig 打开系统配置 control 打开控制面板 explorer 打开文件资源管理器 相当于windows+E ver 显示Windows的版本号 services.msc 查看服务 Win命令 windows+d 最小桌面化 windows+e 打开资源管理器(我的电脑) windows+l 锁屏 windows+++++++ 放大镜(windows + ----还原) windows+x windows移动中心 windows+p 投影 windows+上下左右 分别实现窗口最大化/窗口最小化/窗口左布局/窗口右布局(窗口排版) windows+tab3D文件切换(win10中是虚拟桌面) windows+home 除当前窗口的其他所有窗口最小化 shift+windows+1~9 按编号启动底部工具栏(同时使用多次会出现窗口分身) windows+g 屏幕录制(win10有效) Dos命令文件命令 dir 列出当前目录下的文件夹 md 创建目录(make directory) rd 删除目录(remove directory) cd 改变目录(change directory) cd ..退后一级 cd \ 到根目录 d: 切换盘符 del 删除文件 type file 显示文件内容 exit 退出Dos命令 cls 清屏(clear screen) doskey /history 查看历史命令 参数命令 &lt;command&gt; /?或 help &lt;command&gt; 查看帮助 cmd /c 其他 直接运行命令后关闭cmd窗口 cmd /k 其他 直接运行命令后保留cmd窗口 参数命令的路径使用反斜杠\ ,同时若路径中出现空格, 要引起来,如del &quot;d:\program files\files\test.txt&quot; tree 目录 显示对应的目录的目录结构 chcp 改变代码页(默认936简体中文gbk编码) 12使用chcp 65001 可以将显示的编码转换为utf-8, 可以解决乱码问题chcp 437是美国英语编码 net start 查看有那些服务 1234net start 服务名 -- 开启服务net stop 服务名 -- 关闭服务net pasuse 服务名 -- 暂停服务net password 新密码 更改系统登录 ​ netstat -ano | findstr 8080 查看端口状态, 并且是和8080端口相关的内容(管道 findstr与linux中的grep功能一致)]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows命令</tag>
        <tag>装x专用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js之-Browser]]></title>
    <url>%2F2018%2F10%2F15%2Fjs%E4%B9%8B-Browser%2F</url>
    <content type="text"><![CDATA[DOM 节点 DOM 为Document Object Model , 在html的DOM中, 每一个元素都是节点.文档是一个文档节点, 所有的HTML元素都是元素节点, 所有的HTML属性都是属性节点, 文本插入到HTML元素是文本节点, 注释是注释节点. 当浏览器载入HTML文档时, 它就会称为Document对象, Document对象是HTML文档的根节点.More请浏览菜鸟… Document对象 改变HTML document.write 写HTML内容 获取元素对象 document.getElementById() 通过标签ID选择器获取标签 document.getElementsByTagName() 通过标签标签名列表获取标签 document.getElementsByClassName() 通过类选择器列表获取标签 document.querySelector() 通过选择器获取标签(可以是类,id等) document.querySelectorAll() 通过全部选择器的列表获取标签(可以是类,id等) 改变CSS 通过获取的元素对象的style属性, 如elm.style.width=90px 改变元素属性 通过获取的元素对象的某属性, 如elm.disabled=true , 表示elm元素节点不可用 事件 事件监听器 1document.getElementById(&quot;myBtn&quot;).onclick=function()&#123;displayDate()&#125;; 但是当多个div或者元素在同一个坐标重合出现, 就会出现事件冒泡现象.(它的意思是事件在子元素节点上触发后, 会在其父节点上触发, 由内向外的触发; 相对的还有事件捕获, 它是一种事件由外向内触发的机制) ​ 为了解决事件冒泡, 我们可以使用阻止事件来解决, 比如: 12evt.stopPropagation()阻止事件冒泡(子节点向父节点传播的现象)evt.cancelBubble = true;阻止事件传播(解决的ie的兼容性) 但是有更好的解决方式, 就是添加事件监听器elm.addEventListener(evt,func) , 它能帮助我们处理事件冒泡的现象. 注意: 在循环中, 对于多个标签, 不同通过下标取值, 而是通过evt.target获取触发当前事件的节点 计时器 通过计时器有效的控制事件发生的频次和时间.JavaScript中提供了两种计时器, 分别是setTimeout 和 setInterval 12myval = setTimeout(func(), time) time毫秒后发生myval = setInterval(func(),time) 每time毫秒发生 对应的有删除计时器的函数 12clearTimeout(myval)clearInterval(myval) 当我们使用匿名函数, 可以使用arguements.callee 它指向当前的函数, 就能实现递归. 节点 12345子节点children 父节点parentNode 兄弟节点previousSibling(前一个)/nextSibling(后一个) firstChild第一个子节点lastChild最后一个节点 增加节点 增加节点可以使用elm = document.createElement()创造标签(节点), 当有了elm节点后, 有两种方式可以将它插入document中 第一种, 使用elm.parentNode.appendChild(insert_elm)在某个节点之后插入节点 第二种, 使用elm.parentNode.insertBefore(insert_elm, target_elm) 在目标节点前插入节点 删除节点 删除节点请食用 elm.parentNode.removeChild(elm) 通过子节点的父节点删除子节点 修改节点 修改在内容属性 innerHTML – 获取html的标签和内容textContent – 获取文本内容(标签也会以文本获取)input标签的内容是value字段 修改节点的style属性 elm.style.width 大概就是这个形式, 注意它不能读只能写, 因此使用window.alert(elm.style.width) 是不能得到它的宽度. 要想读样式中的数据, 要通过document.defaultView.getComputedStyle(elm) 修改节点的其他属性 elm.&lt;property&gt; 直接通过得到的节点对象修改其属性 查看节点 直接通过elm.&lt;property&gt;进行读的操作 Json json , 即JavaScript Object Notation, 是一种轻量级的数据交换格式。它现在被广泛用于数据的存储和传输. 原型对象 func_name.prototype.&lt;property&gt; 能够通过实例化的对象去访问该属性 123456789实例:function Student(name,age)&#123; this.name = name; this.age = age;&#125;Student.prototype.study = function(courseName)&#123; alert(this.name + &quot;正在学习&quot; + courseName); &#125;var obj = new Student(&quot;1000phone&quot;,10); #实例化的对象 可以访问原型定义的属性 obj.study(&quot;PYTHON&quot;) JQuery 介绍 jQuery是一个 JavaScript 库。它帮助我们解决浏览器版本和浏览器种类带来的兼容性问题, 极大地简化了 JavaScript 编程。它的关键用法就是$的使用, 它就代表着jquery $四种用法 $函数的参数是个函数 1$(function()&#123;&#125;) 传入函数是页面加载完成之后要执行的函数(回调函数) $函数的参数是个选择器字符串 1$(&apos;#move&apos;) 获取页面上的标签并且将它转换成jQuery对象 $函数的参数是个标签 1$(&lt;li&gt;) -- 创建标签并且返回对应的jQuery对象 $函数的参数是原生JS对象 12 $(evt.target) -- 将原生js对象转换成jQuery对象-如果bar是一个jQuery对象可以通过bar[0] / bar.get(0) 在循环中可以通过下标去得到 ​ 相关属性和方法 12345678910-绑定/反绑定事件: on() / off() / one()-获取/修改标签内容: text() / html() 不传参就是获取，传参就是提供内容-获取/修改标签属性: attr(name, value)-获取input标签的内容: val()-添加子节点: append() / prepend() -删除/清空节点: remove() / empty()-修改样式表: css(&apos;color&apos;)读样式 css(&#123;&apos;color&apos;:&apos;red&apos;,&apos;font-size&apos;:&apos;18px&apos;&#125;)修改多个样式-获取父节点: parent()-获取子节点: children()-获取兄弟节点: prev() / next() 下一个/上一个 AJAX 介绍 Ajax 即 Asynchronous Javascript And XML（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术. 它能够在无需重新加载整个网页的情况下，更新部分网页. getJSON方式 1$.getJSON(api_url, function(jsonobj)&#123;&#125;) ajax方式 123456789101112131415161718$.ajax(&#123; &quot;url&quot;:url, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&#123; &quot;key&quot;:&quot;bilibili&quot;, &quot;word&quot;:str &#125;, &quot;datatype&quot;:&quot;json&quot;, &quot;success&quot;:function(jsonobj)&#123; if(jsonObj.code == 200)&#123; //http状态码 200成功 250成功但是没有查到数据 $(&quot;#content&quot;).text(jsonObj.newslist[0].result) &#125;else&#123; $(&quot;#content&quot;).text(jsonObj.msg) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js&#39;s DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql初体验]]></title>
    <url>%2F2018%2F10%2F15%2FMysql%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[数据库 数据库, 即database, 通过数据库我们可以实现数据的持久化 当我们左数据持久化操作是不仅仅是希望能够把数据长久的保存起来, 更重要的是便利的管理数据—方便的存取。 1970s IBM - 关系型数据库 12345理论基础: 关系代数和集合论具体表象: 用二维表来组织数据二维表: - 行, 即记录- 列, 即字段 SQL(Structure Query Language)结构化查询语言 12345678SQL对大小写不敏感SQL分为6个部分，分别为:- DQL数据查询语言(即数据检索select下的where、order by、group by、having)，- DML数据操作语言(即insert、update、delete)，- TPL事务处理语言(即begin transaction开始事务,commit提交,rollback回滚)，- DCL数据控制语言(即grant授予，revoke撤销，确定对单个用户和用户组对数据库对象的访问)，- DDL数据定义语言(即create创建表,drop删除表和alter修改表,为表加入索引，保留字)，- CCL指针控制语言(即)。 SQL相关组成 1234DB - Database 数据库DBMS - Database Management System 数据库管理系统DBA - Database Administrator 数据库管理员DBS - Database System 数据库系统 图形化MySQL客户端工具 123- Navicat - 支持SQL- Toad - Oracle开发 ​ DDL(data definition language) 数据库操作 12345678- create databaseCREATE DATABASE student DEFAULT CHARSET utf8;- drop databasedrop database if exists student;- alter database... 数据表操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- 在命令列界面(安装mysql时给的,在Navicat中不支持)使用 ? &lt;参数&gt; 可以查看帮助- create table# create table tb_name(column_name, datatype, constraint);# 命名方式给前缀如table - tb_student, 便于查看# 非空约束 -- not null# 默认值约束 -- default# 主键约束 -- primary key --&gt; 主键是表中能够唯一标识一条记录的列# instance:create table tb_student(stuid int not null, stuname varchar(4) not null, gender bit not null default 1, birth date, addr varchar(50),primary key(stuid) );- drop table# drop table if exists tb_name;- alter table# alter table tb_student add column tel char(11) not null;# alter table tb_student drop column tel;- insert-- a recordinsert into tb_student values(2018001, &apos;王晗旭&apos;, 1, &apos;1995-10-10&apos;, &apos;中国大陆&apos;);insert into tb_student (stuid, stuname, gender) values(2018002, &apos;卢姥爷&apos;, 1);-- many recordsinsert into tb_student (stuid, stuname, gender) values(2018003, &apos;卢姥爷&apos;, 1),(2018004, &apos;蛇姥爷&apos;, 1),(2018005, &apos;老姥爷&apos;, 1);- delete-- a recorddelete from tb_student where stuid = 2018005;--many recordsdelete from tb_student where stuid in (2018005, 2018006, 2018007);- truncate truncate table tb_name;- updateupdate tb_student set addr=&apos;Sichuan,China&apos;, gender=0 where stuid in (2018002, 2018003);- select select * from tb_name; DQL(data query language) select select * from tb_name; 查询tb_name中的全部内容 select stuname as 姓名, gender as 性别 from tb_name; 别名式查询, 其中的as可以省略 12345- alias selectselect stuname as 姓名, gender as 性别 from tb_student;- alias select and handle filedselect stuname as 姓名, if (gender, &apos;男&apos;, &apos;女&apos;) as 性别 from tb_student;select stuname as 姓名, case gender when 1 then &apos;男&apos; else &apos;女&apos; end as 性别 from tb_student; where 对表中的某列或某些列做处理或给定筛选条件, 再查询 123456789select concat(stuname,&apos;: &apos; , addr) as 信息 from tb_student where gender = 0; 将stuname和addr字段连接起来再查询select * from tb_student where stuid between 2018001 and 2018010; 查询2018001和2018010之间的所有记录select * from tb_student where addr is null; -- 查询addr为空的所有记录select * from tb_student where addr is not null; -- 查询addr不为空的所有记录select * from tb_student where stuid &gt; 2018001 and gender = 0; -- 查询满足所有条件的记录select * from tb_student where stuid &gt; 2018001 or gender = 0; -- 查询满足至少一个条件的所有记录 like 模糊查询 123select * from tb_student where stuname like &apos;%姥爷%&apos;; %表示0个或多个字符, 查询字段中有&apos;姥爷&apos;的所有记录select * from tb_student where stuname like &apos;_姥爷&apos;; _ 表示一个字符, 查询所有一个字符后&apos;姥爷&apos;的所有记录 order by 排序查询 123456select * from tb_student order by stuid; 升序查询所有记录select * from tb_student order by stuid desc; 降序查询所有记录select * from tb_student order by gender, stuid desc; 先按gender升序排, 对相同的记录再按stuid降序排列所有记录select * from tb_student where gender = 0 order by stuid; 先筛选再排序, 列出所有记录 limit offset 分页查询 123select * from tb_student limut 3; 查询3条记录select * from tb_student limit 3 offset 6; 跳过6条记录在查询3条记录等价于 select from tb_student limit 6, 3; 跳过6条记录在查询3条记录 null 查询空内容的记录 12# 同时判断条件 null 和 &apos;&apos;select sname &apos;学生姓名&apos; from tb_student where addr is null or addr = &apos;&apos;; distinct 去重查询 123456789select distinct seldate as &apos;去重后日期&apos; from tb_score;对比:-- 去重运算(distinct)和集合运算(in/not in) 效率很低-- 通常建议使用exists或not exists替代# distinctselect ename, job from tbemp where eno in (select distinct mgr from tbemp where mgr is not null);# where existsselect ename, job from tbemp t1 where exists (select &apos;f&apos; from tbemp t2 where t1.eno=t2.mgr); aggregate function 聚合函数 1聚合函数 max()/ min() / sum() / avg() / count() group by 分组查询 12# 通常聚合函数和分组group by是联合使用select sid as &apos;学号&apos;, avg(mark) as &apos;平均成绩&apos; from tb_score group by sid; having 集合运算 123456# where 在group by(或order by)前查询# having在group by(或order by)后查询# 通常若使用having的字段必须在出现在前面的查询的字段中, 而where不能解决对表筛选后再次筛选的目的。select sid from tb_score group by sid having count(sid)&gt;2- 在tb_score表中,根据学生id(sid)进行分组查询学生id(sid).再进行sid出现次数大于2的记录select ename, sal from TbEmp where sal&gt;(select avg(sal) from TbEmp) ; ​ subquery 子查询 12345# 筛选的字段也是通过查询获取的# 字段=值select sname from tb_student where birth=(select min(birth) from tb_student);# 字段 in tableselect sname as &apos;姓名&apos; from tb_student where stuid in (select sid from tb_score group by sid having count(sid)&gt;2); inner join...on 内连接查询 123select sname, cname, mark from tb_student inner join tb_score on stuid=sid inner join tb_course on cid=couid where mark is not null; # 等价于select sname, cname, mark from tb_student, tb_course, tb_score where stuid=sid and couid=cid and mark is not null; left/right join...on 左外连接/右外连接(mysql不支持全外连接) 12345select sname, num from tb_student as tb1 inner join (select sid, count(cid) as num from tb_score group by sid) as tb2 on tb1.stuid = tb2.sid;select sname, num from tb_student as tb1 left join (select sid, count(cid) as num from tb_score group by sid) as tb2 on tb1.stuid = tb2.sid;-- 左外连接 把左表(写在前面的表)不满足连接条件的记录也查出来对应记录补上null-- 右外连接 把左表(写在前面的表)不满足连接条件的记录也查出来对应记录补上null ​ 约束(constraint) 外键(foreign key) 123456789# 创建外键前要在表中加入外键对应的字段# alter table tb_name add column tb_field;alter table tb_student add column clg_id int;# 创建外键约束alter table tb_student add constraint fk_clg2stu foreign key(clg_id) references tb_college(clg_id); # 删除外键约束alter table tb_student drop foreign key fk_clg2stu; 唯一约束(unique) 1234# 创建唯一约束alter table tb_college add constraint unique_clg_site unique(clg_site);# 删除唯一约束alter table tb_college drop index unique_clg_site; 非空约束(not null) 12345# 修改成非空约束alter table tb_name modify col_name col_type not null;# 删除也是通过修改alter table tb_name modify col_name col_type; 默认值约束(default) 12345# 修改成默认值约束alter table tb_name modify col_name col_type default df_value;# 删除也是通过修改alter table tb_name modify col_name col_type; 主键约束(primary key) 1234567# 添加主键约束alter table tb_name add primary key(col_name);# 删除主键约束## 若有自动增长类型, 要先去除, 再删除主键;若没有, 直接删除主键(因为自动增长是依托于主键的)alter table tb_name modify col_name int;alter table tb_name drop primary key 数据完整性(data integrity) 实体完整性(entity intergrity) 每一条记录都是独一无二的,没有冗余 – 依托于主键primary key/唯一约束unique 参照完整性(referential intergrity) B表参照A表, A表没有的数据B表绝对不能出现 – 依托于外键foreign key 域完整性(domain intergrity) 录入的数据都是有效的 – 依托于数据类型 / 非空约束not null / 默认值约束default / 检查约束(可以写入, 但是在mysql中不生效) 数据一致性(data consistency) 事务 12345678910111213141516171819数据库在出现并发事务访问数据时, 数据库底层有锁机制来保护数据;但是通常我们书写SQL的时候不会显示锁, 数据库会根据我们设定的事务隔离级别自动加锁。事务隔离级别(由低到高)Read Uncommited 读未提交的数据Read Commited 读提交的数据Repeatable Read 可重复读Serializable 串行化修改事务隔离级别:set session/global transaction isolation level 级别字段;查询事务隔离级别:select @@tx_isolation;并发数据访问可能出现的问题:第1类丢失更新第2类丢失更新脏读 -- 一个事务读取到另外一个事务尚未提交的数据不可重复读 -- 一个事务正在查询的时候发现其他事务更新了数据导致无法查询幻读 -- 一个是事务在执行查询的时候被其他事务提交了新的数据 DCL(data control language) 创建用户 12-- %表示任意地址, 也可以直接指定地址, 本地地址可以是localhost或128.0.0.1create user &apos;cuser&apos;@&apos;%&apos; identified by&apos;123456&apos;; 授权(grant) 1234567891011# src为数据库名, 若为*.* 即是所有数据库中所有资料-- 授予特定的权限grant select on srs.* to &apos;cuser&apos;@&apos;%&apos;;grant insert, delete on srs.* to &apos;cuser&apos;@&apos;%&apos;;grant create, drop, alter on srs.* to &apos;cuser&apos;@&apos;%&apos;;-- 授予所有权限grant all privileges on srs.* to &apos;cuser&apos;@&apos;%&apos;;-- 授予所有权限且还能授权给他人grant all privileges on srs.* to &apos;cuser&apos;@&apos;%&apos; with grant option; 召回(revoke) 12-- 召回所有权限revoke all privileges on srs.* from &apos;cuser&apos;@&apos;%&apos;; DPL(transaction processing language) 事务控制 begin | start transaction 开启事务 commit 事务提交, 要全部任务成功执行则提交 rollback 事务回滚, 只要存在任务失败则回滚 instance 123456789-- 事务开启begin;# or start transactionupdate tb_score set mark=mark+2 where sid=1001;update tb_score set mark=mark+2 where sid=1002;-- 事务提交commit;-- 事务回滚rollback; 视图(view) 概念 12345视图是虚拟表，本身不存储数据，而是按照指定的方式进行查询。也可以说视图是查询的快照权限控制时将用户对表的访问权限,限制到对指定列的访问。可以通过给定查询视图的权限,而不给查询表的权限来实现。对创建好的视图, 可以通过查询语句直接使用视图 栗子 1234# create view vw_name as select ...create view vw_tbemp as select * from tbempselect * from vw_tbemp; 索引 概念 123456789索引相当于图书的目录为表创建索引而达到加速查询就是典型的(牺牲空间换取时间)索引会使增删改变慢, 不能滥用, 其原因是增删改操作可能导致所以索引的更新通常将索引建在经常被查询的字段上主键默认唯一索引 事务的ACID的特性 1234Atomicity原子性 不可分割Consistency 一致性 事务前后数据状态一致Isolation 隔离性 多个事务不能看到彼此的中间状态Duration 持久性 事务完成后数据要持久化 栗子12345678-- 对于模糊索引, 若它以%开头,索引失效; 若它不以%开头,索引有效(下划线_有效)-- 创建索引create index idx_emp_name on tbemp(ename);-- 创建唯一索引create unique index uidx_emp_name on tbemp(ename);-- 删除索引alter table tb_name drop index uidx_name; 12]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之-Window]]></title>
    <url>%2F2018%2F10%2F13%2FJS%E4%B9%8B-Window%2F</url>
    <content type="text"><![CDATA[navigator对象 属性 1.appCodeName -- 返回浏览器的代码名 Mozilla 2.appName -- 返回浏览器的名称 Netscape 3.appVersion -- 返回浏览器的平台和版本消息 4.cookieEnabled -- 启用cookie 5.platform -- 硬件平台 win32 6.userAgent --用户代理 7.systemLanguage -- 用户代理语言 浏览器版本黑历史:) 12345678910111213141516 Mosaic(马赛克)，最早的浏览器 Mozilla(魔斯拉)(意为Mosaic杀手) -- 后改名为Netscape Mozilla/1.0(Win3.1)，由于网景支持框架，而框架被大众喜爱，网站管理员探测userAgent时对Mozilla浏览器发送有框架的页面，对非Mozilla的浏览器发送没有框架的页面。网景拿微软寻开心，称微软是&quot;没有调试过的硬件驱动程序&quot;，微软很生气，开发了自己的浏览器。 微软 IE(Internet Explorer)--IE也支持框架，但它不是Mozilla，总是收不到含有框架的网页， 又等不及所有的网站管理员去了解IE，就宣布IE是兼容Mozilla的，并模仿Netscape，自称Mozilla/1.22(compatible; MSIE 2.0; Windows 95)，于是IE就能接受所有的含有框架的网页，微软开心了，网站管理员崩溃了。微软和Netscape的大战，由于微软的捆绑销售等原因，Netscape退出历史舞台。 FireFox火狐--Netscape以MOzilla的名义，开发了Gecko，它的渲染引擎很出色，Gecko变得出色，其他浏览器使用它的代码，并伪装成Mozilla，但是却使用Gecko。userAgent的探测规则偏向Gecko Linux下的conqueror -- 引擎是KHTML，但因为不是Gecko得不到好的页面，将自己伪装成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko) Opera欧朋 -- 跳出来说应该让用户决定想让我们伪装成什么浏览器。给定三个选项，“Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51”==IE或者“Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51”==火狐， 或者“Opera/9.51 (Windows NT 5.1; U; en)==欧朋 Safari苹果 -- 使用KHTML作为渲染引擎，后来基于KHTML另开辟分支WebKit，又不想抛弃哪些KHTML的页面，就自称Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5 chorme谷歌 --使用Webkit作为渲染引擎，它想要哪些Safari的页面，于是它伪装成Safari.Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36 于是Chrome使用WebKit，并将自己伪装成Safari，WebKit伪装成KHTML，KHTML伪装成Gecko，最后所有的浏览器都伪装成了Mozilla，这就是为什么所有的浏览器User-Agent里都有Mozilla。 Screen对象 123width/height --屏幕宽度/高度availWidth/availheight 可用宽度/高度 (如屏幕底部的状态栏就不含在可用高度内)colorDepth/pixelDepth -- 颜色深度/颜色分辨率 ，其实是一个意思，但是主流服浏览器多用前者 History 对象 属性 length 返回历史记录的地址数 方法 123back()加载history列表中的前一个url 》》 加载时只能加载当前标签对应的history列表，而不是整个历史记录forward() 加载history列表中的后一个urlgo(num) 加载到history列表中的第num个页面(以当前来看) -- go(0)就是刷新页面 Location对象 URL Uniform Resource Locator, 即统一资源定位符 属性 12345678hash -- 返回一个url的锚部分 -- 即是url中#后的部分。通常用于&lt;a name=&quot;location&quot;&gt;&lt;/a&gt;标记去向的位置；使用&lt;a href=&quot;#location&quot;&gt;&lt;/a&gt;可以直接转到指定的位置 。并且#后数据用于位置标识，在服务端没有作用。 但是改变#后值会增加增加一条历史记录到列表中，可以使用history加载)search -- 返回url的查询部分 即是?号之后的部分host -- 返回对应url的主机名和端口号（若端口号是80http 、443https，不会返回端口号）hostname -- 返回对应的url的主机名href -- 返回对应url的完整URLpathname -- 返回url路径名 即主机名之后的部分port -- 返回url的端口号 (若是80端口返回空串)protocol -- 返回url的协议(http/https/ftp ...) 关于hash部分的锚点, 详细请看锚点讲解 方法 123assign -- 加载一个文档 location.assign(url)reload -- 重新加载当前的文档，绕过缓存，重新在服务器上加载数据 与ctrl shift R相同 (若有post提交数据，也会重新提交)replace --替换到一个新文档中 location.replace(url) (网上说replace后的新页面会取代原网页的窗口，不能返回到上一个记录，但是好像可以。。。好像和assign功能上没什么不一样) 注: 以上实验在chorme上进行的. 弹窗 alert() 警告框, 可以提示内容 confirm() 确认框, 有确认和取消按钮 prompt() 提示框, 通常提示用户输入怎样的值 close() 关闭窗口 获取标签 document.getElementById() 通过标签ID选择器获取标签 document.getElementsByTagName() 通过标签标签名列表获取标签 document.getElementsByClassName() 通过类选择器列表获取标签 document.querySelector() 通过选择器获取标签(可以是类,id) document.querySelectorAll() 通过全部选择器的列表获取标签(可以是类,id) instances: 12345var h1 = document.getElementById(&quot;message&quot;); var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]var h1 = document.getElementsByClassName(&quot;msg&quot;)[0]var h1 = document.querySelector(&quot;#message&quot;)var h1 = document.querySelectorAll(&quot;#message&quot;)[0] 计时器 setInterval 设置计时器 setinterval(function, interval_time) 设置一个计时器, 它每隔interval_time的时间执行一次function函数, interval_time的时间单位是毫秒 删除计时器 在设置计时器的时候, 将计时器函数赋给一个变量, 如 var myVar =setInterval(func,1000), 当需要解除计时器的时候, 使用clearInterval(myVar) 即可. setTimeout 设置计时器setTimeout(function, timeout_time) 设置一个计时器, 它在timeout_time时间结束后执行function函数, timeout_time的时间单位是毫秒 删除计时器 在设置计时器的时候, 将计时器函数赋给一个变量, 如 var myVar =setTimeout(func,1000), 当需要解除计时器的时候, 使用clearTimeout(myVar) 即可.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js&#39;s BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识JS]]></title>
    <url>%2F2018%2F10%2F13%2F%E5%88%9D%E8%AF%86JS%2F</url>
    <content type="text"><![CDATA[js概要 JavaScript与java 123456JavaScript 与 Java 是两种完全不同的语言，无论在概念上还是设计上。Java（由 Sun 发明）是更复杂的编程语言。ECMA-262 是 JavaScript 标准的官方名称。JavaScript 由 Brendan Eich 发明。它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ECMA（一个标准协会）采纳。 JavaScript 是互联网上最流行的脚本语言, 对于网页来说, 它负责事件和渲染部分。因此通常我们将它放在网页的最后部分。 JS由ECMAScript + BOM + DOM 三部分组成 ECMAScript ,ECMA(European Computer Manufactures Association 欧洲电脑制造商协会)。它定义了JavaScript的标准, 现在我们大都使用ECMAScript 5.1，在ECMAScript 6以后添加了类和模块 BOM 是浏览器对象模型 对应window对象 DOM 是 文件对象模型 对应document对象 js基础 注释 单行注释使用// 多行注释使用/* */ 标识符 12341.要求是由数字、字母、下划线和$组成 2.对大小写敏感3.使用驼峰式命名, 不能是js中的关键字, 见名知意instance: var abc , var $12c 基本数据类型 123456789Number 数字类型(包含所有数字, 不支持复数) +12.2 10e2Boolean 布尔类型 true falseString 字符串 &apos;如果有来生&apos; &quot;apple&quot; 单双引号皆可Array 数组 [1,&apos;abc&apos;,true]Object 对象 &#123;a:100, name:&apos;张德帅&apos;,age:20&#125;特殊类型:NaN 不存在的数字null 空,一般用来清空变量的内容 underfined 变量没有赋值或没有结果时 js语句 12#1.一条语句结束后可以写分号，也可以不写,但是提倡写,便于js的压缩。如果一行有多条语句，必须写分号#2.js没有缩进语法的要求，需要使用代码块的时候使用大括号 变量 1231.变量声明: var 变量名 或 var 变量名 = 初值2.初值可有可无3.变量要声明再使用 运算符 123456数学运算符 + - * / % （**,js7）++ --比较运算符 &gt; &lt; = == != &gt;= &lt;= ===(完全相等) !== &gt;== &lt;==- ==只判断值相等 2 == &apos;2&apos; //true- ===类型和值都要相等逻辑运算符 &amp;&amp;与 ||或 !非三目运算符 表达式1？值1:值2 判断表达式，如果为真返回值1，否则返回值2 分支结构 1234567891011#if语句- if- if-else- if-else if-else#switch语句switch(表达式)&#123; case 值1: 代码段 break case 值2: 代码段 break ... default:代码段&#125; 循环结构 12345678910111213#for-in循环for(var 变量 in 序列)&#123;循环体&#125;#for循环for(表达式1:表达式2:表达式3)&#123;循环体&#125;#while循环while(条件语句)&#123;循环体&#125;#do-while循环do&#123;循环体&#125;while(条件语句) 函数 123456789function 函数名(参数列表)&#123; 函数体&#125;注:function:js中声明函数的关键字;函数名:标识符，不能是关键字,见名知意参数列表:形参js不能同时返回多个值js中函数能够作为变量 instance： var fn = function(参数列表) &#123;函数体&#125;js中函数能够作为参数或者返回值 ##]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷酷的aview]]></title>
    <url>%2F2018%2F10%2F12%2F%E9%85%B7%E9%85%B7%E7%9A%84aview%2F</url>
    <content type="text"><![CDATA[1.安装AAlibAA(Ascii Art),AAlib是一个便携式ascii艺术GFX库(GFX lib是一个小型的C库，用于开发针对伟大的MSX计算机的图形应用程序) aalib-1.2的最新版本是1.4, 但是后续安装bb是基于1.2的, 因此要先安装1.2的版本. 安装AAlib之前需要安装gcc和libtool,可以通过yum install xx直接安装. aalib-1.2默认安装在/usr/local下面 1234567891011121314#1 下载aalib-1.2wget http://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz#2 解压缩gunzip aalib-1.2.tar.gz#3 解归档tar -xvf aalib-1.2.tar#4 对安装的软件进行配置,检查依赖关系./configure#5 编译安装make &amp;&amp; make install (先执行make, 在执行make install) 出现的问题: 12345678ltconfig: you must specify a host type if you use `--no-verify&apos;Try `ltconfig --help&apos; for more information.configure: error: libtool configure failed出现这样的问题,其实是配置时不能识别系统类型,需要自己指定主机类型.解决方法是将下述的两个文件覆盖带/aalib-1.2/下面. (下述 . 指当前文件夹下)cp /usr/share/libtool/config/config.guess .cp /usr/share/libtool/config/config.sub . 2.安装bbbb是一种图形演示程序,它需要AAlib库 12345678910111213141516171819#1 下载bb源文件wget http://prdownloads.sourceforge.net/aa-project/bb-1.2.tar.gz#2 解压缩gunzip bb-1.2.tar.gz #3 解归档tar -xvf bb-1.2.tar #4 配置环境变量,使bb能找到AAlibexport CFLAGS=-I/usr/local/include#5 配置cd bb-1.2./configure注: 配置会出错,因为textform.c文件中很多位置缺少结束字符&quot; ,只要将报错的地方全部使用 &quot;&quot; 将之引起来就好了。(仿照正确的地方的格式)#6 编译生成可执行文件bbmake 3.安装aviewaview是一款高质量的图像(pnm)浏览器和动画(fli/flc)播放器，以ASCII-art方式输出。它是使用AA-lib实现的。 它提供了一个asciiview的脚本，利用convert转换图片格式，然后再传递给aview. aview是依赖aalib-1.4，因此需要先安装aalib-1.4, 安装方式与aalib-1.2相同, 链接https://downloads.sourceforge.net/aa-project/aalib-1.4rc5.tar.gz 123456789101112131415#1 安装aviewwget http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gz#2 解压缩gunzip aview-1.3.0rc1.tar.gz #3 解归档tar -xvf aview-1.3.0rc1.tar #4 配置cd aview-1.3.0./configure#5 编译安装make &amp;&amp; make install 4.安装ImageMagickImageMagick介绍在此http://www.imagemagick.org/script/index.php 它可以直接通过yum安装 5.try在此,应该是将所有软件安装完毕, 随便在浏览器上扣一张图,使用命令acsiiview 图片路径效果如下: 原图 ascii图 注: 上述使用linux的发行版本为CentOS 6.x。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>aview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xshell和linux]]></title>
    <url>%2F2018%2F10%2F11%2Fxshell%2F</url>
    <content type="text"><![CDATA[基本命令 who 显示当前连接服务器的所有用户 who am i 只显示本用户 w显示本用户详细信息 last显示最近登录的用户信息 ps 显示所有进程 1ps -ef 查看进程 kill pid 杀死指定id的进程 1kill -9 pid 强行杀死指定id的进程 用户管理 adduser username 添加新的用户 passwd username 为指定的用户建立密码(若是root用户, 可以修改任何用户的密码 userdel username 删除用户 userdel -r username 删除用户及其用户主目录(recursive递归的) userdel -f username 强制删除用户(force强制) su username 切换用户(switch user) tab制表键 自动补全 man 命令 查看指定命令的手册(manual手册) info 命令 查看命令的手册(以coder的角度) 命令 --help 查看指定命令的help pwd 查看工作目录(print work directory) cd 或 cd~ 返回到当前目录的主目录 cd /directory 绝对路径的方式改变当前目录 cd directory 相对路径的方式改变当前目录 wget 联网下载 cat filename 连接多个文件并查看文件内容(concatenates) history 查看历史命令 history -c 清除历史命令 ! historyid 执行历史命令编号的命令 pwd 打印当前工作目录(print name of work directory) ls 列出文件 123-a 显示隐藏文件-l 长格式显示文件-R 递归显示文件 alias newname = &quot;命令&quot; 将一个命令起一个别名 12alias rmd = &quot;rm -rf&quot; 使rmd称为直接强制删除的命令别名unalias rmd 取消所起的别名 rmdir 移除空目录(remove directory) mkdir 创建目录 (make directory) cp 拷贝文件 mv 剪切文件或文件夹 12mv index.html new.html 更改文件index.html为new.htmlmv index.html /abc/rz 剪切index.html到/abc/rz的目录下 rm 删除文件或目录 1234rm -f 直接删除指定的文件或目录rm -r 递归式的删除rm -i 交互式删除注:参数可以放在一起或分开 -r -f 等价于 -rf #表示root用户 $表示普通用户 echo 输出内容 1234echo &quot;print &apos;hello world!&apos;&quot; 在控制台打印字符串echo &quot;print &apos;hello world!&apos;&quot; &gt; hello.py 输出(覆盖)内容到hello.py文件中echo &quot;print &apos;hello world!&apos;&quot; &gt;&gt; hello.py 追加内容到hello.py文件中2&gt; 错误输出重定向 cal 查看日历 123cal 2018 查看2018整年的日历cal 2018 &gt; date.txt 将日历信息重定向到date.txt文件中cal 12 2018 查看2018年12月的日历 date 查看日期 bc 计算器 1scale = number number指小数点后几位的num shutdown / init 0 关机, 前者有1m的等待时间，后者直接关机 reboot / init 6 重启 head -n file 查看文件的前n行 tail -n file 查看文件最后n行 less/more file 分页查看文件 | 管道，用于进程间通信。把前一个进程的输出用于后一个进程的输入。 wc 用于统计(print newline, word, and byte counts for each file) 123-l 统计行数-c 统计字节数-m 统计单词个数 uniq 去重的作用(仅去重相邻的重复项) 1sort test.txt | uniq 先排序test.txt文件再去重 vim -d file1 file2比较2个文件的不同(通过创建2个子窗口) chmod 修改权限 chown 修改文件所有者 write 用户名 发送消息给用户,ctrl d结束 wall 发送消息给所有用户 !v 使用vim打开最近一次使用vim的文件 top 查看任务管理器 ls || cal 按顺序执行，若有一个命令执行成功，后续不执行 ls &amp;&amp; cal 按顺序执行，上一个命令执行成功，再执行后一个命令。若遇到执行不成功的,后续也不执行 ls; cal 按顺序执行命令(先ls 再cal) #Linux用户管理 用户添加 12345678910useradd [option] username -- 添加用户option:-c --&gt; 指定一段注释性描述-d --&gt; 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录-g --&gt; 指定用户所属的用户组-s --&gt; 指定用户登录的shell-u --&gt; 指定用户的用户号instance:# useradd -d /usr/mary -m Mary -- 创建名为Mary的用户,并指定其主目录为mary,若没有mary目录就创建一个目录# 默认下新建用户均会在/usr/目录下创建一个和用户名相同的用户主目录 删除账号 123userdel [option] username -- 删除用户option:-r --&gt; 删除用户的同时会删除用户的主目录和用户相关的记录 修改用户 12usermod [option] username -- 修改用户的信息option: 与添加用户部分的参数相同 口令管理(密码管理) 123456789passwd [option] [username]option:-l --&gt; 锁定口令,禁用账号-u --&gt; 解除锁定口令-d --&gt; 使账号无口令-f --&gt; 强迫用户下次登录时修改口令username:- 当没有指定username时, 修改当前用户的口令- 若当前用户是普通用户时, 修改口令需要指定旧口令; 若当前用户为root用户, 可以直接指定新的口令, 不需要旧口令。 Linux安装软件使用包管理工具yum/rpm123456yum search &lt;name&gt; -- 搜索相关包yum - y install &lt;name1&gt; &lt;name2&gt; -- -y参数是默认所有选项为yes，后可以接多个包进行安装yum -y remove &lt;name1&gt; &lt;name&gt; -- 卸载,也可以多个yum info &lt;name&gt; -- 查看软件的信息yum update &lt;name&gt; -- 更新指定的包,若没有指定name,则更新全部包yum list installed -- 将已经安装的包列出来 源代码构建安装 1gcc -- 通常linux系统自带 压缩文件 12gz --- 压缩gzip(解压缩gunzip)xz --- 压缩xzip(解压缩xz -d) 归档文件 12WinRAR --- 归档与解归档tar --- 归档文件(linux下) centos安装python3.x.x 12345678910111213141516171819201.下载源代码 -- wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz2.解压缩 -- gunzip Python-3.6.5.tgz 3.解归档 -- tar -xvf Python-3.6.5.tar (x抽离 v归档显示 f文件)4.安装Python依赖库 -- yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel5.安装前配置 -- 进入Python3.x.x文件，使用./configure --prefix=/usr/local/python36 --enable-optimizations6.源代码构建安装make &amp;&amp; make install(&amp;&amp;表示如果make成功马上执行make install)7.配置PATH环境变量export PATH=$PATH:/usr/local/python36/bin8.注册一个软链接(符号链接) --- 非必要注:软链接 -- 相当于文件的快捷方式，文件删除则链接失效硬链接 -- 文件的引用。只要引用数不为0，文件就会一直存在ln -s 带完整路径的文件名 链接文件名(不带s为硬链接，带s为软链接)对于一个可执行的文件: ./可执行文件配置永久环境变量ls -al | grep .bash_profilevim .bash_profilei修改第10行(:set nu) -- PATH=$PATH:/usr/local/python36/bin修改第11行 -- export PATH 系统目录介绍/bin 1bin是Binary的缩写, 这个目录存放着最经常使用的命令, 如cat cp ls等(通常为普通用户和root用户必备的命令) /sbin 1sbin是Superuser Binary, 这个用户存放系统管理的命令(也称程序) 如reboot shutdown init ifconfig等 /boot 1存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /dev 1device，存放linux的外部设备文件(在linux中访问设备和访问文件的方式相同) /etc 1234存放所有的系统管理所需要的配置文件/etc/profile /etc/csh.login /etc/csh.cshrc 启动shell执行的文件。修改此文件,能够在登录用户后给提示信息./etc/passwd 用户数据库, 其中给出了用户名, 家目录, 命令目录/etc/shells 列出所有可以使用的shell /usr 12345678/usr/bin -- usr下的bin目录放置可执行程序/usr/local -- 手动安装软件的默认目录/usr/share -- 放置共享数据,帮助手册(/usr/share/man)/usr/lib -- 程序和子系统的库文件/usr/include -- c语言编程中的头文件/usr/bin -- 通常放置应用软件工具的必备命令 如gcc zip man等/usr/sbin -- 通常放置放置网路管理的必备程序, 如httpd dhcpd sendmail等/usr/src -- 内核源代码默认的放置目录 /home 1用户的主目录, 里面放置所有用户的主目录文件 /lib 1放置最基本的动态链接共享库, 类似window下的dll文件, 几乎所有程序都需要用到这些共享库 /proc 1process - 放置进程文件,它是系统内存的映射, 是一个虚拟目录 /var 1234存放系统运行时要改变的数据/var/lib -- 存放系统正常运行要改变的文件/var/local -- 存放/usr/local中安装的程序的可变数据/var/log -- 存放各种程序的日志文件 /root 1作为系统管理员的主目录 vim命令模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344按 i 可切换到 编辑模式h/left -- 光标左移1j/down -- 光标下移1k/top -- 光标上移1l/right -- 光标右移1同时可以 10right/10l 的组合键向右移动10个字符0或home 移动到一行的首字符$或end 移动到一行的末字符H 光标移动到屏幕的第一行首字符M 光标移动弄到屏幕的中间行首字符L 光标移动到屏幕最后一行的首字符w 光标移动一个单词G 光标移动到文件的最后一行gg 光标移动到文件的第一行(相当于1G)nG 光标移动到第n行(20G -- 第20行) -- 配合set nu使用n&lt;Enter&gt; 光标向下移动n行/word 向光标之下寻找名称为word的字符串n/N 对应/word使用,前者为下一个,后者为上一个:n1,n2s/word1/word2/g 在n1到n2行之间,将word1字符串替换成word2:1,$s/word1/word2/g 在第一行到最后一行间,将word1字符串替换成word2:1,$s/word1/word2/gice c是confirm确认,i是ignore忽略大小写,g是global全局模式,e是error忽略错误?正则表达式 反向搜索(与/相反)ctrl f 屏幕向下移动1页(page down)ctrl b 屏幕向上移动1页(page up)ctrl e 向下翻1行ctrl y 向上翻1行x 向后删除一个字符 X 向前删除一个字符dd 删除光标所在一整行ndd 删除含光标所有n行yy 复制光标所在一行nyy 复制含光标所在n行p 将复制的数据在光标下一行贴上 P将复制的数据在上一行贴上u 复原前一个动作ctrl r 重做上一个动作 . 重做上一个动作ctrl x + ctrl o 代码提示r/R 进入取代模式(replace) r会取代光标所在的字符一次, R会一直取代ZZ --- 没改动则直接离开，若改动则保存退出 编辑模式 1234567enter 换行backspace 删除光标前一个字符delete 删除光标后一个字符home/end 移动光标到行首/行尾pg up/pg dn 上/下翻页insert 切换光标为输入/替换模式(replace)esc 切换到命令模式 底线命令模式 123456789101112131415在命令模式下,按下:冒号进入底线命令模式:systax off/on --- 关闭/打开高亮语法:set nu/nonu --- 设置行号/关闭行号:wq --- 保存退出:ls 查看打开的文件:b &lt;编号&gt; 查看指定编号文件(可实现vim同时打开多个文件):vs 垂直拆分窗口:sp 水平拆分ctrl w + ctrl w 切换窗口:qa 退出全部:wqa 全部保存退出:qa! 全部强制退出:map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行:inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 .vimrc(vim配置文件) 12345678syntax on/off 高亮语法打开/关闭set number 设置行号set tabstop=4 设置tab缩进为4 set ruler 显示标尺set nohls 搜索时去除高亮set autoindent 设置换行时自动缩进map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 linux锁屏与解锁 12ctrl s 会将终端terminal锁屏,造成假死的现象ctrl q 进行解除锁屏 ssh远程登录 1远程登录命令 ssh &lt;user&gt;@公网ip password ssh远程传输 12345scp &lt;local file&gt; &lt;user&gt;@公网ip:/传输的路径 passwd(注意用户的级别与所放置文件的目录访问权限有关) --- 将本地文件发送给别的用户的某个路径下例如:scp sohu2.html rzlong@120.77.178.218:/home/rzlongscp &lt;user&gt;@公网ip:/传输的路径 &lt;user&gt;@公网ip:/传输的路径 passwd1 passwd2 将用户1的某个文件发给用户2,如果要发送文件可以加上 -r 参数例如:scp rzlong@120.77.178.218:/home/rzlong/sohu2.html lnx@47.93.248.0:/home/lnx sftp安全文件传输 12345678910111213sftp &lt;user&gt;@公网ip passwd 进入sftp模式help可以查看相关命令相关命令:get [-Ppr] remote [local] Download filereget remote [local] Resume download fileput [-Ppr] local [remote] Upload filels [-1afhlnrSt] [path] Display remote directory listingmkdir path Create remote directoryrename oldpath newpath Rename remote filerm path Delete remote filermdir path Remove remote directorypwd Display remote working directory此时要在sftp模式中操纵本地 在以上命名前加上l(local),如lcd, lls, lpwd DoS和DDoS 12 查看端口情况 12netstat -anp | grep 80 查看所有占用80端口的情况 n数值型ip a是all p是进程例如:tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2033/sshd 进程id为2033, ip为0.0.0.0，端口号22, 传输协议为tcp, sshd是secure shell deamon安全外壳守护进程(后台程序) 服务相关 1234567891011121314151617centos 6.xservice &lt;name&gt; startservice &lt;name&gt; stopcentos 7.xsystemctl start &lt;name&gt; - 启动服务systemctl stop &lt;name&gt; - 停止服务systemctl restart &lt;name&gt; - 重启服务systemctl status &lt;name&gt; - 服务状态syatemctl enable &lt;name&gt; - 设置服务开机自启systemctl disable &lt;name&gt; - 设置服务不启动安装Appache服务器yum -y install httpdps -ef | grep nginx 进程后台运行 12345678910111213141516171819top -- 查看任务管理器jobs -- 查看后台运行的进程ctrl c -- 结束进程ctrl z -- 进程暂停置于后台ctrl d -- 停止输入bg %编号 -- 让暂停的进程继续在后台运行 backgroundfg %编号 -- 让后台的进程在前台(terminal)运行 foreground./hello.py &amp; -- 将一个程序置于后台运行说明:Key FunctionCtrl-c Kill foreground process Ctrl-z Suspend foreground processCtrl-d Terminate input, or exit shellCtrl-s Suspend output 暂停输出Ctrl-q Resume output 回复输出Ctrl-o Discard output 抛弃输出Ctrl-l Clear screen 清屏 计算机网络分层架构模型 1234567TCP/IP 协议族TCP -- Transfer Control Protocol 传输控制协议UDP -- User DataGram Protocol 用户数据报协议IP -- Internet Protocol 网际协议应用层(定义应用级协议)- HTTP / SMTP / POP3 / FTP / SSH / linux下防火墙firewall 123456789systemctl start firewalld -- 开启防火墙 firewall-cmd -- 配置防火墙 firewall-cmd --help 查看相关命令firewall-cmd --permanent --add-port=80/tcp 配置永久开启80端口firewall-cmd --remove-port=80/tcp 删除80端口firewall-cmd --query-port-80/tcp 查看端口是否开启firewall-cmd --query-service=ssh 查看ssh服务是否开启注:当修改了端口(打开或关闭),需要重启防火墙才能生效。 iptables Linux关于python代码风格检测12yun install pycodestyleyum install pylint Linux中好玩的命令pv 通过yum install pv命令进行安装, 其效果是输出的内容达到边敲边显示的样子。 sl 通过yum install sl 命令进行安装, 其效果为跑火车。 xeyes 通过yum install xeyes 命令进行安装,运行命令,会在图形显示界面会看到一双萌萌的眼睛盯着你。 Linux历史GNU和GPL GNU 建立一个自由、开放的 Unix 操作系统(FreeUnix) GPL(GNU General Public License) 为了避免 GNU 所开发的自由软件被其他人所利用而成为专利软件， 史托曼与律师草拟了有名的通用公共许可证(General Public License, GPL)， 并且称呼他为copyleft(相对于专利软件的 copyright！) Free Software和Close Software free software它更被能称为freedom software,自由软件。不是指免费的价格，而是拥有自由的权利。同时它还具有open source 开放源代码的特点。 1&quot;Free software&quot; is a matter of liberty, not price. To understand the concept, you should think of &quot;freespeech&quot;, not &quot;free beer&quot;. &quot;Free software&quot; refers to the users&apos; freedom to run, copy,distribute, study, change,and improve the software close software 即推出的可执行的二进制程序，是专利软件copyright常见的软件出售方式。 但是也有专利软件是免费使用的.Freeware和Shareware : 前者为免费软件，可以免费使用但是不会公开源代码；后者为共享软件，通常为有试用期，再试用期后就必须续费或者停止使用，它已经撰写好了失效程序。 Linux核心版本 可以使用uname -r查看当前linux版本: 12[root@izwz9gn12m5wual96636l2z ~]# uname -r3.10.0-514.26.2.el7.x86_64 主版本.次版本.释出版本-修改版本 在2.6.x版本前，托瓦兹将主次版本为奇数的定位发展中版本development，主要用于测试与发展；对于主次版本为偶数的定位稳定版本stable 在3.0版本后，依据主线版本MainLine开发，例如 3.10 就是在 3.9 的架构下继续开发出来的新的主线版本。而对于旧的版本，有两种机制来处理: 其一为结束开发End Of Live(EOL)，不会再维护；其二是长期维护版本Longterm，例如3.10为一个长期维护版本。 Linux Distrubution linux distrubution 即linux发行版，它是linux kernel+softwares+Tools+可完全安装程序 。常见的有Redhat /OpenSuSe/Fedora/Ubuntu/Debian/CentOS等，它们都是支持于标准的。 12 12]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本控制工具]]></title>
    <url>%2F2018%2F10%2F05%2Fgit-md%2F</url>
    <content type="text"><![CDATA[版本控制工具CVS/VSS – 锁定模式 2000年 - Subversion(SVN) – 合并模式上述为集中控制式的版本系统,必须有中央服务器。 2005年 - Git – 版本控制Mercury分布式的版本系统 区域划分工作区 — 暂存区 — 仓库 基本命令 git init 初始化，使当前目录初始化为git仓库，并创建.git的隐藏目录 git config –global user.name “name” 全局用户名可以随便写,仅标记主机 git config –global user.email “email@example.com“ 全局邮箱,可随便写 git add 将文件加入到暂存区 git add . 将当前目录下的所有文件加入到暂存区 git commit -m “版本提示内容” 将暂存区的内容提交到本地仓库 git status 查看暂存区状态 git log 查看当前版本日志(之前的版本) git reflog 查看所有版本git reset HEAD -将文件从暂存区移除 git checkout – 将暂存区回退到工作区，可用于文件恢复(用于上一次,并且还没有提交到本地仓库中；若是已经提交到仓库中，就可以使用hard来还原版本) git reset –hard 版本号 去往指定的版本 git reset –hard HEAD^ 还原到上个版本(HEAD^^还原到上上个版本) git reset –hard HEAD~num 还原到前num个版本 git clone - 将服务器的项目(仓库)克隆到本地 git push - 将代码推送到服务器(上传) git pull - 将服务器上代码同步到本地(下载) 代码托管平台用别人提供的git服务器github.comgitee.comcoding.net]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F10%2F05%2Fmutiphreading-md%2F</url>
    <content type="text"><![CDATA[##多线程技术 主线程 每个进程都会有一个线程, 这个线程是主线程。默认情况下, 所有代码都是在主线程中执行。 子线程 一个进程可以有多个线程,除了主线程的其他子线程需要去创建 创建线程通过导入threading模块。 threading是python中创建线程的内置模块，用来支持多线程。Thread类的对象就是线程，需要线程时，可创建这个类或其子类的对象。 实例 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingfrom datetime import datetimeimport time# 模拟下载电影def download(file): print(threading.currentThread()) print(file+&apos; 开始下载&apos;,datetime.now()) time.sleep(10) print(file+&apos; 结束下载&apos;, datetime.now())# 在两个子线程中去下载电影&apos;&apos;&apos;Thread(target,args)target:需要在在线程中调用的函数的函数名args: 函数的实参返回值:创建好的线程对象&apos;&apos;&apos;if __name__ == &apos;__main__&apos;: print(threading.current_thread()) print(&apos;主线程位置&apos;) print(&apos;===============================&apos;) t1 = threading.Thread(target=download, args=(&apos;闻香识女人&apos;,)) # t1.start()#想要子线程执行任务，通过线程对象调用start方法 print(&apos;=============================&apos;) t2 = threading.Thread(target=download, args=(&apos;猫鼠游戏&apos;,)) # t2.start() # 执行线程的代码result:&lt;_MainThread(MainThread, started 10552)&gt;主线程位置===============================&lt;Thread(Thread-1, started 8712)&gt;闻香识女人 开始下载 2018-09-15 09:27:07.418839=============================&lt;Thread(Thread-2, started 10564)&gt;猫鼠游戏 开始下载 2018-09-15 09:27:07.418839猫鼠游戏 结束下载 2018-09-15 09:27:17.419411闻香识女人 结束下载 2018-09-15 09:27:17.419411 ##面向对象的多线程 步骤1.声明一个类，继承Thread类2.重写run()方法,将需要在子线程中执行的任务，放到run()方法中3.在需要线程的位置，去创建这个类的对象然后用对象调用start方法，去执行run中的任务。 案例1234567891011121314151617rom threading import Threadfrom datetime import datetime # 从datetime包中引入datetime模块import timeclass R_Thread(Thread): &quot;&quot;&quot;下载线程类&quot;&quot;&quot; def __init__(self,name): super().__init__() self.name = name def run(self): print(self.name+&apos; 开始下载&apos;,datetime.now()) time.sleep(5) print(self.name+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: print(&apos;=========================&apos;) t1 = R_Thread(&apos;闻香识女人&apos;) t1.start() print(&apos;============================&apos;) ##join方法如果希望某个线程结束后才执行后续的操作，调用join方法 案例12345678910111213141516171819202122232425262728from threading import Threadfrom datetime import datetimeimport timefrom random import randint# 在两个子线程中下载两个电影,在主线程中国统计两个电影下载的总时间class R_Thread(Thread): def __init__(self,file): super().__init__() self.file = file def run(self): print(self.file+&apos; 开始下载&apos;,datetime.now()) time.sleep(randint(5,15)) print(self.file+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: t1 = R_Thread(&apos;闻香识女人&apos;) start = time.time() print(start) t1.start() t2 = R_Thread(&apos;美丽人生&apos;) t2.start() &apos;&apos;&apos; 如果希望某个线程结束后才执行后续的操作，调用join方法 &apos;&apos;&apos; t1.join() #这句代码后面的代码需要在t1对应的线程结束后执行 t2.join() end = time.time() print(end) print(end-start) ##多个线程数据共享通过加锁的方式，以解决多个线程同时对一个数据进行操作二带来的数据紊乱的问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import timefrom datetime import datetimefrom threading import Thread,Lock,RLockclass Account: &quot;&quot;&quot;账号类&quot;&quot;&quot; def __init__(self,balance): self.balance = balance # 创建锁对象 self.lock = Lock() # 存钱: 读余额, 确定钱的数目 def save_money(self,amount): self.lock.acquire() # 获取原来的余额 old_amount = self.balance # 模拟时间消耗 time.sleep(5) # 修改余额 self.balance = old_amount + amount print(&apos;存钱成功,余额&apos;,self.balance) self.lock.release() # 取钱 def get_money(self,amount): self.lock.acquire() old_amount = self.balance if old_amount &lt; amount: print(&apos;余额不足&apos;) return time.sleep(10) self.balance = old_amount - amount print(&apos;取钱成功,余额&apos;,self.balance) self.lock.release() def show_balance(self): print(&apos;余额:&apos;,self.balance)if __name__ == &apos;__main__&apos;: account = Account(1000) account.show_balance() &apos;&apos;&apos; 当多个线程同时对一个数据进行操作的时候,可能出现数据紊乱的问题 &apos;&apos;&apos; t1 = Thread(target=account.save_money,args=(200,)) t2 = Thread(target=account.get_money,args=(400,)) t1.start() t2.start() t1.join() account.show_balance() t2.join() account.show_balance() **]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
