<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[酷酷的aview]]></title>
    <url>%2F2018%2F10%2F12%2F%E9%85%B7%E9%85%B7%E7%9A%84aview%2F</url>
    <content type="text"><![CDATA[1.安装AAlibAA(Ascii Art),AAlib是一个便携式ascii艺术GFX库(GFX lib是一个小型的C库，用于开发针对伟大的MSX计算机的图形应用程序) aalib-1.2的最新版本是1.4, 但是后续安装bb是基于1.2的, 因此要先安装1.2的版本. 安装AAlib之前需要安装gcc和libtool,可以通过yum install xx直接安装. aalib-1.2默认安装在/usr/local下面 1234567891011121314#1 下载aalib-1.2wget http://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz#2 解压缩gunzip aalib-1.2.tar.gz#3 解归档tar -xvf aalib-1.2.tar#4 对安装的软件进行配置,检查依赖关系./configure#5 编译安装make &amp;&amp; make install (先执行make, 在执行make install) 出现的问题: 12345678ltconfig: you must specify a host type if you use `--no-verify&apos;Try `ltconfig --help&apos; for more information.configure: error: libtool configure failed出现这样的问题,其实是配置时不能识别系统类型,需要自己指定主机类型.解决方法是将下述的两个文件覆盖带/aalib-1.2/下面. (下述 . 指当前文件夹下)cp /usr/share/libtool/config/config.guess .cp /usr/share/libtool/config/config.sub . 2.安装bbbb是一种图形演示程序,它需要AAlib库 12345678910111213141516171819#1 下载bb源文件wget http://prdownloads.sourceforge.net/aa-project/bb-1.2.tar.gz#2 解压缩gunzip bb-1.2.tar.gz #3 解归档tar -xvf bb-1.2.tar #4 配置环境变量,使bb能找到AAlibexport CFLAGS=-I/usr/local/include#5 配置cd bb-1.2./configure注: 配置会出错,因为textform.c文件中很多位置缺少结束字符&quot; ,只要将报错的地方全部使用 &quot;&quot; 将之引起来就好了。(仿照正确的地方的格式)#6 编译生成可执行文件bbmake 3.安装aviewaview是一款高质量的图像(pnm)浏览器和动画(fli/flc)播放器，以ASCII-art方式输出。它是使用AA-lib实现的。 它提供了一个asciiview的脚本，利用convert转换图片格式，然后再传递给aview. aview是依赖aalib-1.4，因此需要先安装aalib-1.4, 安装方式与aalib-1.2相同, 链接https://downloads.sourceforge.net/aa-project/aalib-1.4rc5.tar.gz 123456789101112131415#1 安装aviewwget http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gz#2 解压缩gunzip aview-1.3.0rc1.tar.gz #3 解归档tar -xvf aview-1.3.0rc1.tar #4 配置cd aview-1.3.0./configure#5 编译安装make &amp;&amp; make install 4.安装ImageMagickImageMagick介绍在此http://www.imagemagick.org/script/index.php 它可以直接通过yum安装 5.try在此,应该是将所有软件安装完毕, 随便在浏览器上扣一张图,使用命令acsiiview 图片路径效果如下: 原图 ascii图 注: 使用linux的内核版本为centeos。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>aview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xshell]]></title>
    <url>%2F2018%2F10%2F11%2Fxshell%2F</url>
    <content type="text"><![CDATA[基本命令 who 显示当前连接服务器的所有用户 who am i 只显示本用户 w显示本用户详细信息 last显示最近登录的用户信息 ps 显示所有进程 1ps -ef 查看进程 kill pid 杀死指定id的进程 1kill -9 pid 强行杀死指定id的进程 adduser username 添加新的用户 passwd username 为指定的用户建立密码 userdel username 删除用户 userdel -r username 删除用户及其文件夹(recursive递归的) userdel -f username 强制删除用户(force强制) su username 切换用户(switch user) tab制表键 自动补全 man 命令 查看指定命令的手册(manual手册) info 命令 查看命令的手册(以coder的角度) 命令 --help 查看指定命令的help pwd 查看工作目录(print work directory) cd 或 cd~ 返回到当前目录的主目录 cd /directory 绝对路径的方式改变当前目录 cd directory 相对路径的方式改变当前目录 wget 联网下载 cat filename 连接多个文件并查看文件内容(concatenates) history 查看历史命令 history -c 清除历史命令 ! historyid 执行历史命令编号的命令 pwd 打印当前工作目录(print name of work directory) ls 列出文件 123-a 显示隐藏文件-l 长格式显示文件-R 递归显示文件 alias newname = &quot;命令&quot; 将一个命令起一个别名 12alias rmd = &quot;rm -rf&quot; 使rmd称为直接强制删除的命令别名unalias rmd 取消所起的别名 rmdir 移除空目录(remove directory) mkdir 创建目录 (make directory) cp 拷贝文件 mv 剪切文件或文件夹 12mv index.html new.html 更改文件index.html为new.htmlmv index.html /abc/rz 剪切index.html到/abc/rz的目录下 rm 删除文件或目录 1234rm -f 直接删除指定的文件或目录rm -r 递归式的删除rm -i 交互式删除注:参数可以放在一起或分开 -r -f 等价于 -rf #表示root用户 $表示普通用户 echo 输出内容 1234echo &quot;print &apos;hello world!&apos;&quot; 在控制台打印字符串echo &quot;print &apos;hello world!&apos;&quot; &gt; hello.py 输出(覆盖)内容到hello.py文件中echo &quot;print &apos;hello world!&apos;&quot; &gt;&gt; hello.py 追加内容到hello.py文件中2&gt; 错误输出重定向 cal 查看日历 123cal 2018 查看2018整年的日历cal 2018 &gt; date.txt 将日历信息重定向到date.txt文件中cal 12 2018 查看2018年12月的日历 date 查看日期 bc 计算器 1scale = number number指小数点后几位的num shutdown / init 0 关机, 前者有1m的等待时间，后者直接关机 reboot / init 6 重启 head -n file 查看文件的前n行 tail -n file 查看文件最后n行 less/more file 分页查看文件 | 管道，用于进程间通信。把前一个进程的输出用于后一个进程的输入。 wc 用于统计(print newline, word, and byte counts for each file) 123-l 统计行数-c 统计字节数-m 统计单词个数 uniq 去重的作用(仅去重相邻的重复项) 1sort test.txt | uniq 先排序test.txt文件再去重 vim -d file1 file2比较2个文件的不同(通过创建2个子窗口) chmod 修改权限 chown 修改文件所有者 write 用户名 发送消息给用户,ctrl d结束 wall 发送消息给所有用户 !v 使用vim打开最近一次使用vim的文件 top 查看任务管理器 ls || cal 按顺序执行，若有一个命令执行成功，后续不执行 ls &amp;&amp; cal 按顺序执行，上一个命令执行成功，再执行后一个命令。若遇到执行不成功的,后续也不执行 ls; cal 按顺序执行命令(先ls 再cal) ​ Linux安装软件使用包管理工具yum/rpm 123456yum search &lt;name&gt; -- 搜索相关包yum - y install &lt;name1&gt; &lt;name2&gt; -- -y参数是默认所有选项为yes，后可以接多个包进行安装yum -y remove &lt;name1&gt; &lt;name&gt; -- 卸载,也可以多个yum info &lt;name&gt; -- 查看软件的信息yum update &lt;name&gt; -- 更新指定的包,若没有指定name,则更新全部包yum list installed -- 将已经安装的包列出来 源代码构建安装 1gcc -- 通常linux系统自带 压缩文件 12gz --- 压缩gzip(解压缩gunzip)xz --- 压缩xzip(解压缩xz -d) 归档文件 12WinRAR --- 归档与解归档tar --- 归档文件(linux下) centos安装python3.x.x 12345678910111213141516171819201.下载源代码 -- wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz2.解压缩 -- gunzip Python-3.6.5.tgz 3.解归档 -- tar -xvf Python-3.6.5.tar (x抽离 v归档显示 f文件)4.安装Python依赖库 -- yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel5.安装前配置 -- 进入Python3.x.x文件，使用./configure --prefix=/usr/local/python36 --enable-optimizations6.源代码构建安装make &amp;&amp; make install(&amp;&amp;表示如果make成功马上执行make install)7.配置PATH环境变量export PATH=$PATH:/usr/local/python36/bin8.注册一个软链接(符号链接) --- 非必要注:软链接 -- 相当于文件的快捷方式，文件删除则链接失效硬链接 -- 文件的引用。只要引用数不为0，文件就会一直存在ln -s 带完整路径的文件名 链接文件名(不带s为硬链接，带s为软链接)对于一个可执行的文件: ./可执行文件配置永久环境变量ls -al | grep .bash_profilevim .bash_profilei修改第10行(:set nu) -- PATH=$PATH:/usr/local/python36/bin修改第11行 -- export PATH 目录介绍dev 1device，存放linux的外部设备文件(在linux中访问设备和访问文件的方式相同) etc 12存放所有的系统管理所需要的配置文件/etc/profile 修改此文件,能够在登录用户后给提示信息. usr 12/bin -- usr下的bin目录放置可执行程序/local -- 安装软件的默认目录 proc 1process - 进程文件 vim命令模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344按 i 可切换到 编辑模式h/left -- 光标左移1j/down -- 光标下移1k/top -- 光标上移1l/right -- 光标右移1同时可以 10right/10l 的组合键向右移动10个字符0或home 移动到一行的首字符$或end 移动到一行的末字符H 光标移动到屏幕的第一行首字符M 光标移动弄到屏幕的中间行首字符L 光标移动到屏幕最后一行的首字符w 光标移动一个单词G 光标移动到文件的最后一行gg 光标移动到文件的第一行(相当于1G)nG 光标移动到第n行(20G -- 第20行) -- 配合set nu使用n&lt;Enter&gt; 光标向下移动n行/word 向光标之下寻找名称为word的字符串n/N 对应/word使用,前者为下一个,后者为上一个:n1,n2s/word1/word2/g 在n1到n2行之间,将word1字符串替换成word2:1,$s/word1/word2/g 在第一行到最后一行间,将word1字符串替换成word2:1,$s/word1/word2/gice c是confirm确认,i是ignore忽略大小写,g是global全局模式,e是error忽略错误?正则表达式 反向搜索(与/相反)ctrl f 屏幕向下移动1页(page down)ctrl b 屏幕向上移动1页(page up)ctrl e 向下翻1行ctrl y 向上翻1行x 向后删除一个字符 X 向前删除一个字符dd 删除光标所在一整行ndd 删除含光标所有n行yy 复制光标所在一行nyy 复制含光标所在n行p 将复制的数据在光标下一行贴上 P将复制的数据在上一行贴上u 复原前一个动作ctrl r 重做上一个动作 . 重做上一个动作ctrl x + ctrl o 代码提示r/R 进入取代模式(replace) r会取代光标所在的字符一次, R会一直取代ZZ --- 没改动则直接离开，若改动则保存退出 编辑模式 1234567enter 换行backspace 删除光标前一个字符delete 删除光标后一个字符home/end 移动光标到行首/行尾pg up/pg dn 上/下翻页insert 切换光标为输入/替换模式(replace)esc 切换到命令模式 底线命令模式 123456789101112131415在命令模式下,按下:冒号进入底线命令模式:systax off/on --- 关闭/打开高亮语法:set nu/nonu --- 设置行号/关闭行号:wq --- 保存退出:ls 查看打开的文件:b &lt;编号&gt; 查看指定编号文件(可实现vim同时打开多个文件):vs 垂直拆分窗口:sp 水平拆分ctrl w + ctrl w 切换窗口:qa 退出全部:wqa 全部保存退出:qa! 全部强制退出:map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行:inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 .vimrc(vim配置文件) 12345678syntax on/off 高亮语法打开/关闭set number 设置行号set tabstop=4 设置tab缩进为4 set ruler 显示标尺set nohls 搜索时去除高亮set autoindent 设置换行时自动缩进map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 linux锁屏与解锁 12ctrl s 会将终端terminal锁屏,造成假死的现象ctrl q 进行解除锁屏 ssh远程登录 1远程登录命令 ssh &lt;user&gt;@公网ip password ssh远程传输 12345scp &lt;local file&gt; &lt;user&gt;@公网ip:/传输的路径 passwd(注意用户的级别与所放置文件的目录访问权限有关) --- 将本地文件发送给别的用户的某个路径下例如:scp sohu2.html rzlong@120.77.178.218:/home/rzlongscp &lt;user&gt;@公网ip:/传输的路径 &lt;user&gt;@公网ip:/传输的路径 passwd1 passwd2 将用户1的某个文件发给用户2,如果要发送文件可以加上 -r 参数例如:scp rzlong@120.77.178.218:/home/rzlong/sohu2.html lnx@47.93.248.0:/home/lnx sftp安全文件传输 12345678910111213sftp &lt;user&gt;@公网ip passwd 进入sftp模式help可以查看相关命令相关命令:get [-Ppr] remote [local] Download filereget remote [local] Resume download fileput [-Ppr] local [remote] Upload filels [-1afhlnrSt] [path] Display remote directory listingmkdir path Create remote directoryrename oldpath newpath Rename remote filerm path Delete remote filermdir path Remove remote directorypwd Display remote working directory此时要在sftp模式中操纵本地 在以上命名前加上l(local),如lcd, lls, lpwd DoS和DDoS 12 查看端口情况 12netstat -anp | grep 80 查看所有占用80端口的情况 n数值型ip a是all p是进程例如:tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2033/sshd 进程id为2033, ip为0.0.0.0，端口号22, 传输协议为tcp, sshd是secure shell deamon安全外壳守护进程(后台程序) 服务相关 1234567891011121314151617centos 6.xservice &lt;name&gt; startservice &lt;name&gt; stopcentos 7.xsystemctl start &lt;name&gt; - 启动服务systemctl stop &lt;name&gt; - 停止服务systemctl restart &lt;name&gt; - 重启服务systemctl status &lt;name&gt; - 服务状态syatemctl enable &lt;name&gt; - 设置服务开机自启systemctl disable &lt;name&gt; - 设置服务不启动安装Appache服务器yum -y install httpdps -ef | grep nginx 进程后台运行 12345678910111213141516171819top -- 查看任务管理器jobs -- 查看后台运行的进程ctrl c -- 结束进程ctrl z -- 进程暂停置于后台ctrl d -- 停止输入bg %编号 -- 让暂停的进程继续在后台运行 backgroundfg %编号 -- 让后台的进程在前台(terminal)运行 foreground./hello.py &amp; -- 将一个程序置于后台运行说明:Key FunctionCtrl-c Kill foreground process Ctrl-z Suspend foreground processCtrl-d Terminate input, or exit shellCtrl-s Suspend output 暂停输出Ctrl-q Resume output 回复输出Ctrl-o Discard output 抛弃输出Ctrl-l Clear screen 清屏 计算机网络分层架构模型 1234567TCP/IP 协议族TCP -- Transfer Control Protocol 传输控制协议UDP -- User DataGram Protocol 用户数据报协议IP -- Internet Protocol 网际协议应用层(定义应用级协议) - HTTP / SMTP / POP3 / FTP / SSH / linux下防火墙firewall 123456789systemctl start firewalld -- 开启防火墙 firewall-cmd -- 配置防火墙 firewall-cmd --help 查看相关命令firewall-cmd --permanent --add-port=80/tcp 配置永久开启80端口firewall-cmd --remove-port=80/tcp 删除80端口firewall-cmd --query-port-80/tcp 查看端口是否开启firewall-cmd --query-service=ssh 查看ssh服务是否开启注:当修改了端口(打开或关闭),需要重启防火墙才能生效。 iptables Linux关于python代码风格检测 12yun install pycodestyleyum install pylint Linux中好玩的命令pv 通过yum install pv命令进行安装, 其效果是输出的内容达到边敲边显示的样子。 sl 通过yum install sl 命令进行安装, 其效果为跑火车。 xeyes 通过yum install xeyes 命令进行安装,运行命令,会在图形显示界面会看到一双萌萌的眼睛盯着你。 GNU和GPL GNU 建立一个自由、开放的 Unix 操作系统(FreeUnix) GPL(GNU General Public License) 为了避免 GNU 所开发的自由软件被其他人所利用而成为专利软件， 史托曼与律师草拟了有名的通用公共许可证(General Public License, GPL)， 并且称呼他为copyleft(相对于专利软件的 copyright！) Free Software和Close Software free software它更被能称为freedom software,自由软件。不是指免费的价格，而是拥有自由的权利。同时它还具有open source 开放源代码的特点。 1&quot;Free software&quot; is a matter of liberty, not price. To understand the concept, you should think of &quot;freespeech&quot;, not &quot;free beer&quot;. &quot;Free software&quot; refers to the users&apos; freedom to run, copy,distribute, study, change,and improve the software close software 即推出的可执行的二进制程序，是专利软件copyright常见的软件出售方式。 但是也有专利软件是免费使用的.Freeware和Shareware : 前者为免费软件，可以免费使用但是不会公开源代码；后者为共享软件，通常为有试用期，再试用期后就必须续费或者停止使用，它已经撰写好了失效程序。 Linux核心版本 可以使用uname -r查看当前linux版本: 12[root@izwz9gn12m5wual96636l2z ~]# uname -r3.10.0-514.26.2.el7.x86_64 主版本.次版本.释出版本-修改版本 在2.6.x版本前，托瓦兹将主次版本为奇数的定位发展中版本development，主要用于测试与发展；对于主次版本为偶数的定位稳定版本stable 在3.0版本后，依据主线版本MainLine开发，例如 3.10 就是在 3.9 的架构下继续开发出来的新的主线版本。而对于旧的版本，有两种机制来处理: 其一为结束开发End Of Live(EOL)，不会再维护；其二是长期维护版本Longterm，例如3.10为一个长期维护版本。 Linux Distrubutionlinux distrubution 即linux发行版，它是linux kernel+softwares+Tools+可完全安装程序 。常见的有Redhat /OpenSuSe/Fedora/Ubuntu/Debian/CentOS等，它们都是支持于标准的。 12]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本控制工具]]></title>
    <url>%2F2018%2F10%2F05%2Fgit-md%2F</url>
    <content type="text"><![CDATA[版本控制工具CVS/VSS – 锁定模式 2000年 - Subversion(SVN) – 合并模式上述为集中控制式的版本系统,必须有中央服务器。 2005年 - Git – 版本控制Mercury分布式的版本系统 区域划分工作区 — 暂存区 — 仓库 基本命令 git init 初始化，使当前目录初始化为git仓库，并创建.git的隐藏目录 git config –global user.name “name” 全局用户名可以随便写,仅标记主机 git config –global user.email “email@example.com“ 全局邮箱,可随便写 git add 将文件加入到暂存区 git add . 将当前目录下的所有文件加入到暂存区 git commit -m “版本提示内容” 将暂存区的内容提交到本地仓库 git status 查看暂存区状态 git log 查看当前版本日志(之前的版本) git reflog 查看所有版本git reset HEAD -将文件从暂存区移除 git checkout – 将暂存区回退到工作区，可用于文件恢复(用于上一次,并且还没有提交到本地仓库中；若是已经提交到仓库中，就可以使用hard来还原版本) git reset –hard 版本号 去往指定的版本 git reset –hard HEAD^ 还原到上个版本(HEAD^^还原到上上个版本) git reset –hard HEAD~num 还原到前num个版本 git clone - 将服务器的项目(仓库)克隆到本地 git push - 将代码推送到服务器(上传) git pull - 将服务器上代码同步到本地(下载) 代码托管平台用别人提供的git服务器github.comgitee.comcoding.net]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F10%2F05%2Fmutiphreading-md%2F</url>
    <content type="text"><![CDATA[##多线程技术 主线程 每个进程都会有一个线程, 这个线程是主线程。默认情况下, 所有代码都是在主线程中执行。 子线程 一个进程可以有多个线程,除了主线程的其他子线程需要去创建 创建线程通过导入threading模块。 threading是python中创建线程的内置模块，用来支持多线程。Thread类的对象就是线程，需要线程时，可创建这个类或其子类的对象。 实例 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingfrom datetime import datetimeimport time# 模拟下载电影def download(file): print(threading.currentThread()) print(file+&apos; 开始下载&apos;,datetime.now()) time.sleep(10) print(file+&apos; 结束下载&apos;, datetime.now())# 在两个子线程中去下载电影&apos;&apos;&apos;Thread(target,args)target:需要在在线程中调用的函数的函数名args: 函数的实参返回值:创建好的线程对象&apos;&apos;&apos;if __name__ == &apos;__main__&apos;: print(threading.current_thread()) print(&apos;主线程位置&apos;) print(&apos;===============================&apos;) t1 = threading.Thread(target=download, args=(&apos;闻香识女人&apos;,)) # t1.start()#想要子线程执行任务，通过线程对象调用start方法 print(&apos;=============================&apos;) t2 = threading.Thread(target=download, args=(&apos;猫鼠游戏&apos;,)) # t2.start() # 执行线程的代码result:&lt;_MainThread(MainThread, started 10552)&gt;主线程位置===============================&lt;Thread(Thread-1, started 8712)&gt;闻香识女人 开始下载 2018-09-15 09:27:07.418839=============================&lt;Thread(Thread-2, started 10564)&gt;猫鼠游戏 开始下载 2018-09-15 09:27:07.418839猫鼠游戏 结束下载 2018-09-15 09:27:17.419411闻香识女人 结束下载 2018-09-15 09:27:17.419411 ##面向对象的多线程 步骤1.声明一个类，继承Thread类2.重写run()方法,将需要在子线程中执行的任务，放到run()方法中3.在需要线程的位置，去创建这个类的对象然后用对象调用start方法，去执行run中的任务。 案例1234567891011121314151617rom threading import Threadfrom datetime import datetime # 从datetime包中引入datetime模块import timeclass R_Thread(Thread): &quot;&quot;&quot;下载线程类&quot;&quot;&quot; def __init__(self,name): super().__init__() self.name = name def run(self): print(self.name+&apos; 开始下载&apos;,datetime.now()) time.sleep(5) print(self.name+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: print(&apos;=========================&apos;) t1 = R_Thread(&apos;闻香识女人&apos;) t1.start() print(&apos;============================&apos;) ##join方法如果希望某个线程结束后才执行后续的操作，调用join方法 案例12345678910111213141516171819202122232425262728from threading import Threadfrom datetime import datetimeimport timefrom random import randint# 在两个子线程中下载两个电影,在主线程中国统计两个电影下载的总时间class R_Thread(Thread): def __init__(self,file): super().__init__() self.file = file def run(self): print(self.file+&apos; 开始下载&apos;,datetime.now()) time.sleep(randint(5,15)) print(self.file+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: t1 = R_Thread(&apos;闻香识女人&apos;) start = time.time() print(start) t1.start() t2 = R_Thread(&apos;美丽人生&apos;) t2.start() &apos;&apos;&apos; 如果希望某个线程结束后才执行后续的操作，调用join方法 &apos;&apos;&apos; t1.join() #这句代码后面的代码需要在t1对应的线程结束后执行 t2.join() end = time.time() print(end) print(end-start) ##多个线程数据共享通过加锁的方式，以解决多个线程同时对一个数据进行操作二带来的数据紊乱的问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import timefrom datetime import datetimefrom threading import Thread,Lock,RLockclass Account: &quot;&quot;&quot;账号类&quot;&quot;&quot; def __init__(self,balance): self.balance = balance # 创建锁对象 self.lock = Lock() # 存钱: 读余额, 确定钱的数目 def save_money(self,amount): self.lock.acquire() # 获取原来的余额 old_amount = self.balance # 模拟时间消耗 time.sleep(5) # 修改余额 self.balance = old_amount + amount print(&apos;存钱成功,余额&apos;,self.balance) self.lock.release() # 取钱 def get_money(self,amount): self.lock.acquire() old_amount = self.balance if old_amount &lt; amount: print(&apos;余额不足&apos;) return time.sleep(10) self.balance = old_amount - amount print(&apos;取钱成功,余额&apos;,self.balance) self.lock.release() def show_balance(self): print(&apos;余额:&apos;,self.balance)if __name__ == &apos;__main__&apos;: account = Account(1000) account.show_balance() &apos;&apos;&apos; 当多个线程同时对一个数据进行操作的时候,可能出现数据紊乱的问题 &apos;&apos;&apos; t1 = Thread(target=account.save_money,args=(200,)) t2 = Thread(target=account.get_money,args=(400,)) t1.start() t2.start() t1.join() account.show_balance() t2.join() account.show_balance() **]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
