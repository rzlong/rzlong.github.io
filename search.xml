<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django]]></title>
    <url>%2F2018%2F10%2F22%2FDjango%2F</url>
    <content type="text"><![CDATA[Django 简介 Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型model，视图(view)和控制器(controller)。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。 MVC框架模式 MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。核心思想是解耦合。 model 指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 view 指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。 controller 是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 MVC的优缺点: 12优点: 耦合性低, 重用性高, 部署快, 生命周期成本低, 可维护性高缺点: 不易完全理解, 调试很麻烦, 不适合中小规模的应用程序, 系统结构和实现变复杂 MVT框架模式(Django采用) model 与MVC中的M功能相同，负责和数据库交互，进行数据处理。 view 与MVC中的C功能相同，接收请求，进行业务处理，返回应答。 template 与MVC中的V功能相同，负责封装构造要返回的html。 虚拟环境 安装虚拟环境 pip install virtualenv VENV使用 参数说明: -p 指定版本 –no-site-packages 指定纯净模式下安装 virtualenv –no-site-packages -p d:\python\python.exe djvenv 安装虚拟环境 pip -h 查看帮助 pip list 查看安装的包 pip freeze 查看版本 python -m pip install –upgrade pip 升级pip命令 如上 在djvenv/script 执行activate 就会进入虚拟环境, 使用deactivate退出虚拟环境 安装Django 进入对应的虚拟环境下进行安装 pip install django==1.11 创建项目 django-admin startproject &lt;projec-name&gt; 项目文件说明 manage.py 工具集管理文件 settings.py 项目配置文件 urls.py 资源定位文件 wsgi.py 即Python Web Server Gateway Interface python关于web服务器网关接口, 是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标 __init__.py 文件 运行服务 方式1–通过终端terminal python manage.py runserver 运行服务 python manage.py runserver 0.0.0.0:8080 指定可访问的站点和端口号运行服务, 0.0.0.0 表示所有人都能访问 123错误:1.Error: [WinError 10013] 以一种访问权限不允许的方式做了一个访问套接字的尝试。通常是端口已经被占用, 可以在terminal中使用 netstat -ano|findstr &lt;port&gt; 查看段口是否被占用, 解决方式: 换个端口 方式2–修改配置edit configurations Script path选择项目的manage.py文件 Parameters写入runserver [port](默认8000) 数据库配置 在settings中配置 1234567891011此处使用的是mysql数据库DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;django&apos;, # 数据库名 &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;123456&apos;, &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: &apos;3307&apos; # 通常是3306, 可以通过--&gt; 运行--&gt; services.msc查看对应的mysql服务的端口 &#125;&#125; pip install pymysql 安装需要的包 在__init__.py文件中配置, 进行初始化数据库的驱动 (因为python3不提供MYSQLdb 这个驱动, 必须导入) 12import mysql pymysql.install_as_MySQLdb() python manage.py migrate进行信息迁移(映射模型到数据库中), 在修改好数据库配置信息后, 会自动在指定的数据库生成一系列的表 12345auth_group/auth_group_permissions/auth_permission/auth_user/auth_user_groups/auth_user_user_permissions 6个关于用户、用户组及其权限相关的表django_admin_log用户日志表django_content_type内容类型表django_migrations 信息迁移表django_session session表 python manage.py createsuperuser 创建超级管理员 , 然后可以通过http://127.0.0.1:8000/admin访问 登录后台 创建APP django-admin startapp &lt;app-name&gt;/ python manage.py startapp &lt;app-name&gt; 在控制台创建app的命令 ORM对象关系映射 ORM 即object relational mapping对象关系映射 对象迁移 在当前的app中models.py 文件中创建一个类对象, 需要导入from django.db import models 在当前的app中views.py 定义一个自己需要的功能的方法, 这个方法可将将上述的类进行关联, 能使用ORM 形式访问和修改数据库. 123若使用对应的模块需要引入- from django.http import HttpResponse 引入http模块中HttpResponse响应方法- from app.models import Students 在app.models模块中引入需要使用的Sudents类 在项目同名文件中urls文件中, 添加需要url, 如: 在项目同名文件中setting.py文件中, 修改INSTALLED_APP中添加当前的app 配置迁移文件python manage.py makemigrations 进行迁移文件到数据库 python manage.py migrate]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis first time]]></title>
    <url>%2F2018%2F10%2F18%2Fredis-first-time%2F</url>
    <content type="text"><![CDATA[简述redis redis 即remote dictionary server, 主要用于高速缓存, 去优化系统的的性能. redis通常放置体量小的热点数据, 体量大的数据放置在MySQL/ MangoDB 更合适. 安装redis 1.在redis.cn中可以找到下载源文件链接wget &lt;download site&gt; 2.对下载的文件解压缩 gunzip &lt;file&gt; 3.对解压缩的文件进行解归档 tar &lt;file&gt; 4.进入解归档的文件, 发现它已经有了makefile 的文件, 就不用进行进行配置, 直接构建安装 make &amp;&amp; make install 启动redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647方式一:修改默认配置文件redis.conf后再运行#1 ifconfig -- 私网172.18.170.112(在文件中修改bind字段的ip地址)#2 redis端口(merz) 6379(port)#3 (/requirepass) --修改 requirepass 口令#4 (/appendonly ) --修改 appendonly yes ,它会在创建服务器的时候, 生成appendonly.aof的文件, 存储的是每次执行的命令, 当你退出后在进入的时候, 若没有dump.rdb文件就执行所有的命令, 以达成数据持久化.注: rdbcompression yes 默认设置yes, dbfilename dump.rdb 就是默认存储所处理的数据的文件, 能达到数据持久化.foo bar配置哨兵(当主服务器崩掉, 利用哨兵选取新的主服务器)sentinel.confcp redis / sentinel.conf .配置: sentinel monitor mymaster &lt;masterip&gt; &lt;masterport&gt; &lt;int(哨兵数量投票数量)&gt;sentinel down-ater-milliseconds mymaster 10000 主机mymaster挂掉10秒就重新选主服务器sentinel failover-timeout mymaster 180000 故障恢复时间内, 若前服务器重连就使他加入努力， 否则删除主从服务群启动哨兵模式redis-server sentinel.conf --sentinel slaveof no one摆脱奴隶info replication120.77.222.217awk 文字处理grep -v op 不要带op的一一行xargs kill 将前面的输出作为kill的参数传入redis-server 虽然可以直接启动,但是使用的是默认的配置redis-server redis.conf &amp; 后台运行redis服务器redis-server redis.conf &gt; redis.log &amp; 后台启动服务器并输出重定向redis.log文件redis-cli -h ip(对自己用私网id, 对别人用公网ip)方式二:直接在redis-server后接参数启动redis-server --port 6379 --requirepass 123123 --appendonly yes &gt; redis.log &amp;flushall 删除当前库所有数据flushdb 删除所有库所有数据select 1 切换数据库(redis默认启动了16个库)save 同步保存bgsave 异步保存测试吞吐量redis-benchmark -h 公网ip -a passwd 关闭redis服务器 1234关闭redis服务1. ps -ef | grep redis 然后再kill psid2.将后台进程转到前台 -- fg %编号 再使用ctrl c关闭3.在客户端使用shutdown string字符串 12345678910111213set key value -&gt; 设置键值对set key value ex 1000 设置键值对存活(exists) 1000s- ttl key 查看对应键超时时间(time to live) -1为永不超时 -2已经超时- expire key time 指定超时时间get key 查看对应键的值exists key 查看键是否存在del key key可以是多个keys * 查看多有键setnx key value 若key不存在就添加键值对(set not exists)setex key ttl value 设置键值对的时候必须指定超时时间mset key1 value1 key2 value2... 可以同时指定多条数据mget key1 key2... 可以同时获取多条数据若key对应的value是数值时,可以使用incr key增加 decr key减少 hash哈希表 12345678910hset key field value 添加hash对象hget key filed 获取hash对象指定的字段hgetall key 获取hash对象所有键值对hvals key 获取hash对象的所有valuehmset key filed1 value1 filed2 value2...同时指定hash对象的多个字段hdel key filed 删除hash对象指定的字段hexists key filed 检查hash对象有没有指定的字段hkeys key 显示hash对象有哪些键hlen key 显示hash对象有几个键值对hscan key cursor遍历hash对象键值对, 若(1)中为0, 表示已经没有可遍历的对象, 若(1)中大于0, 表示还有可遍历的hash对象 list列表 123456lpush key value [value...] 从list对象的左边放入rpush key value [value...] 从list对象的右边放入lpop key 从list对象的左边取出一个值rpop key 从list对象的右边取出一个值lrange key start end 从左边找到list[start, end]rpoplpush key1 key2 从key1的右边取值再放到key2的左边 set集合 12345678910sadd key value [values...] 往集合中加入元素scard key 查看集合中有几个元素(有自动去重)sinter key1 key2 求集合key1和集合key2的交集sunion key1 key2 求集合key1和集合key2的并集sdiff key1 key2 求集合key1和集合key2的差集sismember key value 判断集合key中有没有valuesmembers key 查看集合key中所有元素srandmember key 从集合key中随机取一个元素spop key 从集合key中随机删除一个元素srem key value 从集合key中指定的删除一个元素 SortedSet有序集合 12zadd key score number [socre number...] 添加有序集合zrange key start stop 查看key[start, stop] 之间所有number 主从复制 123456修改redis.conf文件slaveof &lt;master_ip&gt; &lt;master_port&gt;masterauth &lt;passwd&gt;redis-cli 连接自己的redis服务器info replication 查看主从状态信息 参考文档 123redis.io resis官网resis.cn resis中文版redisdoc.com 提供redis参考文档]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql&python]]></title>
    <url>%2F2018%2F10%2F17%2Fmysql-python%2F</url>
    <content type="text"><![CDATA[python -m venv venv 安装虚拟环境 pycharm下载包 打开pycharm–&gt;File–&gt;Settings–&gt;Project Interpreter –&gt; 点击+–&gt; 输入需要的包名进行下载 使用import you_need_package –&gt; 会报错, 点击灯泡, 选择install package you_need_package 在terminal –&gt; pip install you_need_package 通常会使用国外的文件镜像, 比较慢,可以使用doubanio 速度很快, 具体如下: 12345# 1.在用户主目录 c:\user\administrator 下创建pip目录# 2.在pip目录中创建pip的文件, 修改器后缀名 ini , 注意要将文件的隐藏后缀.txt 去掉(工具-文件夹选项-查看-去除 隐藏已知文件的扩展名)# 3.在pip.ini的文件中,写入:[global]index-url=https://pypi.doubanio.com/simple pymysql conn = pymysql.connect() 建立连接 123456789options:host=&apos;localhost&apos;port=3306db=&apos;db_hrs&apos;user=&apos;root&apos;passwd=&apos;123456&apos;charset=&apos;utf8&apos; 字符集设置autocommit=&apos;true&apos; 自动提交事务cursorclass=pymysql.cursors.DictCursor cursor = conn.cursor() 创建游标 cursor.execute(sql) 执行sql语句, 它返回的是影响后的行数 cursor.fetchone() 获取查询到下一条记录 cursor.fetchall() 获取查询到的全部结果行 cursor.fetchmany(size) 获得查询到的size条记录 conn.commit() 提交事务(若没有设置自动提交事务, 则需手动添加该语句) conn.rollback() 事务回滚 conn.close() 关闭连接 instance: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import pymysqlclass Dept(): def __init__(self, no, name, loc): self.no = no self.name = name self.loc = locdef main(): # 1.create db connection conn = pymysql.connect(host=&apos;localhost&apos;, port=3307, db=&apos;hrs&apos;, user=&apos;root&apos;, passwd=&apos;123456&apos;, charset=&apos;utf8&apos;, autocommit=&apos;true&apos;, cursorclass=pymysql.cursors.DictCursor) try: # 2. 获得游标对象 with conn.cursor() as cursor: # 3.向数据库服务器发出sql # result = cursor.execute(&apos;update tbdept set dname=%s, dloc=%s where dno=%s&apos;,(name, addr, no)) cursor.execute(&apos;&apos;&apos;select dno as no, dname as name, dloc as loc from tbdept&apos;&apos;&apos;) datas = cursor.fetchall() # 查3条记录 # datas = cursor.fetchmany(3) print(datas) # 方法 1 # for data in datas: # print(f&apos;部门编号:&#123;data[0]&#125;\n部门名称:&#123;data[1]&#125;\n部门地址:&#123;data[2]&#125;\n&apos;) # 方法 2 # for data in datas: # print(f&apos;部门编号:&#123;data[&quot;no&quot;]&#125;&apos;) # print(f&apos;部门名称:&#123;data[&quot;name&quot;]&#125;&apos;) # print(f&apos;部门地址:&#123;data[&quot;loc&quot;]&#125;&apos;) # print(&apos;-&apos;.ljust(30,&apos;-&apos;)) # 方法 3 for data in datas: dept = Dept(**data) print(dept.no, end=&apos; &apos;) print(dept.name, end=&apos; &apos;) print(dept.loc, end=&apos; &apos;) print() conn.commit() except pymysql.MySQLError: print(&apos;error&apos;) conn.rollback() finally: conn.close()if __name__ == &apos;__main__&apos;: main() ​]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql&amp;python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用命令]]></title>
    <url>%2F2018%2F10%2F16%2Fwindows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[基础命令 cmd 命令提示符(command) mspaint 画图 osk 打开屏幕键盘(open screen keyboard) calc 打开计算器 (calculator) taskmgr打开任务管理器（task manager）与ctrl+windows delete相同 msconfig 打开系统配置 control 打开控制面板 explorer 打开文件资源管理器 相当于windows+E ver 显示Windows的版本号 services.msc 查看服务 Win命令 windows+d 最小桌面化 windows+e 打开资源管理器(我的电脑) windows+l 锁屏 windows+++++++ 放大镜(windows + ----还原) windows+x windows移动中心 windows+p 投影 windows+上下左右 分别实现窗口最大化/窗口最小化/窗口左布局/窗口右布局(窗口排版) windows+tab3D文件切换(win10中是虚拟桌面) windows+home 除当前窗口的其他所有窗口最小化 shift+windows+1~9 按编号启动底部工具栏(同时使用多次会出现窗口分身) windows+g 屏幕录制(win10有效) Dos命令文件命令 dir 列出当前目录下的文件夹 md 创建目录(make directory) rd 删除目录(remove directory) cd 改变目录(change directory) cd ..退后一级 cd \ 到根目录 d: 切换盘符 del 删除文件 type file 显示文件内容 exit 退出Dos命令 cls 清屏(clear screen) doskey /history 查看历史命令 参数命令 &lt;command&gt; /?或 help &lt;command&gt; 查看帮助 cmd /c 其他 直接运行命令后关闭cmd窗口 cmd /k 其他 直接运行命令后保留cmd窗口 参数命令的路径使用反斜杠\ ,同时若路径中出现空格, 要引起来,如del &quot;d:\program files\files\test.txt&quot; tree 目录 显示对应的目录的目录结构 chcp 改变代码页(默认936简体中文gbk编码) 12使用chcp 65001 可以将显示的编码转换为utf-8, 可以解决乱码问题chcp 437是美国英语编码 net start 查看有那些服务 1234net start 服务名 -- 开启服务net stop 服务名 -- 关闭服务net pasuse 服务名 -- 暂停服务net password 新密码 更改系统登录 ​ netstat -ano | findstr 8080 查看端口状态, 并且是和8080端口相关的内容(管道 findstr与linux中的grep功能一致)]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows命令</tag>
        <tag>装x专用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js之-Browser]]></title>
    <url>%2F2018%2F10%2F15%2Fjs%E4%B9%8B-Browser%2F</url>
    <content type="text"><![CDATA[DOM 节点 DOM 为Document Object Model , 在html的DOM中, 每一个元素都是节点.文档是一个文档节点, 所有的HTML元素都是元素节点, 所有的HTML属性都是属性节点, 文本插入到HTML元素是文本节点, 注释是注释节点. 当浏览器载入HTML文档时, 它就会称为Document对象, Document对象是HTML文档的根节点.More请浏览菜鸟… Document对象 改变HTML document.write 写HTML内容 获取元素对象 document.getElementById() 通过标签ID选择器获取标签 document.getElementsByTagName() 通过标签标签名列表获取标签 document.getElementsByClassName() 通过类选择器列表获取标签 document.querySelector() 通过选择器获取标签(可以是类,id等) document.querySelectorAll() 通过全部选择器的列表获取标签(可以是类,id等) 改变CSS 通过获取的元素对象的style属性, 如elm.style.width=90px 改变元素属性 通过获取的元素对象的某属性, 如elm.disabled=true , 表示elm元素节点不可用 事件 事件监听器 1document.getElementById(&quot;myBtn&quot;).onclick=function()&#123;displayDate()&#125;; 但是当多个div或者元素在同一个坐标重合出现, 就会出现事件冒泡现象.(它的意思是事件在子元素节点上触发后, 会在其父节点上触发, 由内向外的触发; 相对的还有事件捕获, 它是一种事件由外向内触发的机制) ​ 为了解决事件冒泡, 我们可以使用阻止事件来解决, 比如: 12evt.stopPropagation()阻止事件冒泡(子节点向父节点传播的现象)evt.cancelBubble = true;阻止事件传播(解决的ie的兼容性) 但是有更好的解决方式, 就是添加事件监听器elm.addEventListener(evt,func) , 它能帮助我们处理事件冒泡的现象. 注意: 在循环中, 对于多个标签, 不同通过下标取值, 而是通过evt.target获取触发当前事件的节点 计时器 通过计时器有效的控制事件发生的频次和时间.JavaScript中提供了两种计时器, 分别是setTimeout 和 setInterval 12myval = setTimeout(func(), time) time毫秒后发生myval = setInterval(func(),time) 每time毫秒发生 对应的有删除计时器的函数 12clearTimeout(myval)clearInterval(myval) 当我们使用匿名函数, 可以使用arguements.callee 它指向当前的函数, 就能实现递归. 节点 12345子节点children 父节点parentNode 兄弟节点previousSibling(前一个)/nextSibling(后一个) firstChild第一个子节点lastChild最后一个节点 增加节点 增加节点可以使用elm = document.createElement()创造标签(节点), 当有了elm节点后, 有两种方式可以将它插入document中 第一种, 使用elm.parentNode.appendChild(insert_elm)在某个节点之后插入节点 第二种, 使用elm.parentNode.insertBefore(insert_elm, target_elm) 在目标节点前插入节点 删除节点 删除节点请食用 elm.parentNode.removeChild(elm) 通过子节点的父节点删除子节点 修改节点 修改在内容属性 innerHTML – 获取html的标签和内容textContent – 获取文本内容(标签也会以文本获取)input标签的内容是value字段 修改节点的style属性 elm.style.width 大概就是这个形式, 注意它不能读只能写, 因此使用window.alert(elm.style.width) 是不能得到它的宽度. 要想读样式中的数据, 要通过document.defaultView.getComputedStyle(elm) 修改节点的其他属性 elm.&lt;property&gt; 直接通过得到的节点对象修改其属性 查看节点 直接通过elm.&lt;property&gt;进行读的操作 Json json , 即JavaScript Object Notation, 是一种轻量级的数据交换格式。它现在被广泛用于数据的存储和传输. 原型对象 func_name.prototype.&lt;property&gt; 能够通过实例化的对象去访问该属性 123456789实例:function Student(name,age)&#123; this.name = name; this.age = age;&#125;Student.prototype.study = function(courseName)&#123; alert(this.name + &quot;正在学习&quot; + courseName); &#125;var obj = new Student(&quot;1000phone&quot;,10); #实例化的对象 可以访问原型定义的属性 obj.study(&quot;PYTHON&quot;) JQuery 介绍 jQuery是一个 JavaScript 库。它帮助我们解决浏览器版本和浏览器种类带来的兼容性问题, 极大地简化了 JavaScript 编程。它的关键用法就是$的使用, 它就代表着jquery $四种用法 $函数的参数是个函数 1$(function()&#123;&#125;) 传入函数是页面加载完成之后要执行的函数(回调函数) $函数的参数是个选择器字符串 1$(&apos;#move&apos;) 获取页面上的标签并且将它转换成jQuery对象 $函数的参数是个标签 1$(&lt;li&gt;) -- 创建标签并且返回对应的jQuery对象 $函数的参数是原生JS对象 12 $(evt.target) -- 将原生js对象转换成jQuery对象-如果bar是一个jQuery对象可以通过bar[0] / bar.get(0) 在循环中可以通过下标去得到 ​ 相关属性和方法 12345678910-绑定/反绑定事件: on() / off() / one()-获取/修改标签内容: text() / html() 不传参就是获取，传参就是提供内容-获取/修改标签属性: attr(name, value)-获取input标签的内容: val()-添加子节点: append() / prepend() -删除/清空节点: remove() / empty()-修改样式表: css(&apos;color&apos;)读样式 css(&#123;&apos;color&apos;:&apos;red&apos;,&apos;font-size&apos;:&apos;18px&apos;&#125;)修改多个样式-获取父节点: parent()-获取子节点: children()-获取兄弟节点: prev() / next() 下一个/上一个 AJAX 介绍 Ajax 即 Asynchronous Javascript And XML（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术. 它能够在无需重新加载整个网页的情况下，更新部分网页. getJSON方式 1$.getJSON(api_url, function(jsonobj)&#123;&#125;) ajax方式 123456789101112131415161718$.ajax(&#123; &quot;url&quot;:url, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&#123; &quot;key&quot;:&quot;bilibili&quot;, &quot;word&quot;:str &#125;, &quot;datatype&quot;:&quot;json&quot;, &quot;success&quot;:function(jsonobj)&#123; if(jsonObj.code == 200)&#123; //http状态码 200成功 250成功但是没有查到数据 $(&quot;#content&quot;).text(jsonObj.newslist[0].result) &#125;else&#123; $(&quot;#content&quot;).text(jsonObj.msg) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js&#39;s DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql初体验]]></title>
    <url>%2F2018%2F10%2F15%2FMysql%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[数据库 数据库, 即database, 通过数据库我们可以实现数据的持久化 当我们左数据持久化操作是不仅仅是希望能够把数据长久的保存起来, 更重要的是便利的管理数据—方便的存取。 1970s IBM - 关系型数据库 12345理论基础: 关系代数和集合论具体表象: 用二维表来组织数据二维表: - 行, 即记录- 列, 即字段 SQL(Structure Query Language)结构化查询语言 12345678SQL对大小写不敏感SQL分为6个部分，分别为:- DQL数据查询语言(即数据检索select下的where、order by、group by、having)，- DML数据操作语言(即insert、update、delete)，- TPL事务处理语言(即begin transaction开始事务,commit提交,rollback回滚)，- DCL数据控制语言(即grant授予，revoke撤销，确定对单个用户和用户组对数据库对象的访问)，- DDL数据定义语言(即create创建表,drop删除表和alter修改表,为表加入索引，保留字)，- CCL指针控制语言(即)。 SQL相关组成 1234DB - Database 数据库DBMS - Database Management System 数据库管理系统DBA - Database Administrator 数据库管理员DBS - Database System 数据库系统 图形化MySQL客户端工具 123- Navicat - 支持SQL- Toad - Oracle开发 ​ DDL(data definition language) 数据库操作 12345678- create databaseCREATE DATABASE student DEFAULT CHARSET utf8;- drop databasedrop database if exists student;- alter database... 数据表操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- 在命令列界面(安装mysql时给的,在Navicat中不支持)使用 ? &lt;参数&gt; 可以查看帮助- create table# create table tb_name(column_name, datatype, constraint);# 命名方式给前缀如table - tb_student, 便于查看# 非空约束 -- not null# 默认值约束 -- default# 主键约束 -- primary key --&gt; 主键是表中能够唯一标识一条记录的列# instance:create table tb_student(stuid int not null, stuname varchar(4) not null, gender bit not null default 1, birth date, addr varchar(50),primary key(stuid) );- drop table# drop table if exists tb_name;- alter table# alter table tb_student add column tel char(11) not null;# alter table tb_student drop column tel;- insert-- a recordinsert into tb_student values(2018001, &apos;王晗旭&apos;, 1, &apos;1995-10-10&apos;, &apos;中国大陆&apos;);insert into tb_student (stuid, stuname, gender) values(2018002, &apos;卢姥爷&apos;, 1);-- many recordsinsert into tb_student (stuid, stuname, gender) values(2018003, &apos;卢姥爷&apos;, 1),(2018004, &apos;蛇姥爷&apos;, 1),(2018005, &apos;老姥爷&apos;, 1);- delete-- a recorddelete from tb_student where stuid = 2018005;--many recordsdelete from tb_student where stuid in (2018005, 2018006, 2018007);- truncate truncate table tb_name;- updateupdate tb_student set addr=&apos;Sichuan,China&apos;, gender=0 where stuid in (2018002, 2018003);- select select * from tb_name; DQL(data query language) select select * from tb_name; 查询tb_name中的全部内容 select stuname as 姓名, gender as 性别 from tb_name; 别名式查询, 其中的as可以省略 12345- alias selectselect stuname as 姓名, gender as 性别 from tb_student;- alias select and handle filedselect stuname as 姓名, if (gender, &apos;男&apos;, &apos;女&apos;) as 性别 from tb_student;select stuname as 姓名, case gender when 1 then &apos;男&apos; else &apos;女&apos; end as 性别 from tb_student; where 对表中的某列或某些列做处理或给定筛选条件, 再查询 123456789select concat(stuname,&apos;: &apos; , addr) as 信息 from tb_student where gender = 0; 将stuname和addr字段连接起来再查询select * from tb_student where stuid between 2018001 and 2018010; 查询2018001和2018010之间的所有记录select * from tb_student where addr is null; -- 查询addr为空的所有记录select * from tb_student where addr is not null; -- 查询addr不为空的所有记录select * from tb_student where stuid &gt; 2018001 and gender = 0; -- 查询满足所有条件的记录select * from tb_student where stuid &gt; 2018001 or gender = 0; -- 查询满足至少一个条件的所有记录 like 模糊查询 123select * from tb_student where stuname like &apos;%姥爷%&apos;; %表示0个或多个字符, 查询字段中有&apos;姥爷&apos;的所有记录select * from tb_student where stuname like &apos;_姥爷&apos;; _ 表示一个字符, 查询所有一个字符后&apos;姥爷&apos;的所有记录 order by 排序查询 123456select * from tb_student order by stuid; 升序查询所有记录select * from tb_student order by stuid desc; 降序查询所有记录select * from tb_student order by gender, stuid desc; 先按gender升序排, 对相同的记录再按stuid降序排列所有记录select * from tb_student where gender = 0 order by stuid; 先筛选再排序, 列出所有记录 limit offset 分页查询 123select * from tb_student limut 3; 查询3条记录select * from tb_student limit 3 offset 6; 跳过6条记录在查询3条记录等价于 select from tb_student limit 6, 3; 跳过6条记录在查询3条记录 null 查询空内容的记录 12# 同时判断条件 null 和 &apos;&apos;select sname &apos;学生姓名&apos; from tb_student where addr is null or addr = &apos;&apos;; distinct 去重查询 123456789select distinct seldate as &apos;去重后日期&apos; from tb_score;对比:-- 去重运算(distinct)和集合运算(in/not in) 效率很低-- 通常建议使用exists或not exists替代# distinctselect ename, job from tbemp where eno in (select distinct mgr from tbemp where mgr is not null);# where existsselect ename, job from tbemp t1 where exists (select &apos;f&apos; from tbemp t2 where t1.eno=t2.mgr); aggregate function 聚合函数 1聚合函数 max()/ min() / sum() / avg() / count() group by 分组查询 12# 通常聚合函数和分组group by是联合使用select sid as &apos;学号&apos;, avg(mark) as &apos;平均成绩&apos; from tb_score group by sid; having 集合运算 123456# where 在group by(或order by)前查询# having在group by(或order by)后查询# 通常若使用having的字段必须在出现在前面的查询的字段中, 而where不能解决对表筛选后再次筛选的目的。select sid from tb_score group by sid having count(sid)&gt;2- 在tb_score表中,根据学生id(sid)进行分组查询学生id(sid).再进行sid出现次数大于2的记录select ename, sal from TbEmp where sal&gt;(select avg(sal) from TbEmp) ; ​ subquery 子查询 12345# 筛选的字段也是通过查询获取的# 字段=值select sname from tb_student where birth=(select min(birth) from tb_student);# 字段 in tableselect sname as &apos;姓名&apos; from tb_student where stuid in (select sid from tb_score group by sid having count(sid)&gt;2); inner join...on 内连接查询 123select sname, cname, mark from tb_student inner join tb_score on stuid=sid inner join tb_course on cid=couid where mark is not null; # 等价于select sname, cname, mark from tb_student, tb_course, tb_score where stuid=sid and couid=cid and mark is not null; left/right join...on 左外连接/右外连接(mysql不支持全外连接) 12345select sname, num from tb_student as tb1 inner join (select sid, count(cid) as num from tb_score group by sid) as tb2 on tb1.stuid = tb2.sid;select sname, num from tb_student as tb1 left join (select sid, count(cid) as num from tb_score group by sid) as tb2 on tb1.stuid = tb2.sid;-- 左外连接 把左表(写在前面的表)不满足连接条件的记录也查出来对应记录补上null-- 右外连接 把左表(写在前面的表)不满足连接条件的记录也查出来对应记录补上null ​ 约束(constraint) 外键(foreign key) 123456789# 创建外键前要在表中加入外键对应的字段# alter table tb_name add column tb_field;alter table tb_student add column clg_id int;# 创建外键约束alter table tb_student add constraint fk_clg2stu foreign key(clg_id) references tb_college(clg_id); # 删除外键约束alter table tb_student drop foreign key fk_clg2stu; 唯一约束(unique) 1234# 创建唯一约束alter table tb_college add constraint unique_clg_site unique(clg_site);# 删除唯一约束alter table tb_college drop index unique_clg_site; 非空约束(not null) 12345# 修改成非空约束alter table tb_name modify col_name col_type not null;# 删除也是通过修改alter table tb_name modify col_name col_type; 默认值约束(default) 12345# 修改成默认值约束alter table tb_name modify col_name col_type default df_value;# 删除也是通过修改alter table tb_name modify col_name col_type; 主键约束(primary key) 1234567# 添加主键约束alter table tb_name add primary key(col_name);# 删除主键约束## 若有自动增长类型, 要先去除, 再删除主键;若没有, 直接删除主键(因为自动增长是依托于主键的)alter table tb_name modify col_name int;alter table tb_name drop primary key 数据完整性(data integrity) 实体完整性(entity intergrity) 每一条记录都是独一无二的,没有冗余 – 依托于主键primary key/唯一约束unique 参照完整性(referential intergrity) B表参照A表, A表没有的数据B表绝对不能出现 – 依托于外键foreign key 域完整性(domain intergrity) 录入的数据都是有效的 – 依托于数据类型 / 非空约束not null / 默认值约束default / 检查约束(可以写入, 但是在mysql中不生效) 数据一致性(data consistency) 事务 12345678910111213141516171819数据库在出现并发事务访问数据时, 数据库底层有锁机制来保护数据;但是通常我们书写SQL的时候不会显示锁, 数据库会根据我们设定的事务隔离级别自动加锁。事务隔离级别(由低到高)Read Uncommited 读未提交的数据Read Commited 读提交的数据Repeatable Read 可重复读Serializable 串行化修改事务隔离级别:set session/global transaction isolation level 级别字段;查询事务隔离级别:select @@tx_isolation;并发数据访问可能出现的问题:第1类丢失更新第2类丢失更新脏读 -- 一个事务读取到另外一个事务尚未提交的数据不可重复读 -- 一个事务正在查询的时候发现其他事务更新了数据导致无法查询幻读 -- 一个是事务在执行查询的时候被其他事务提交了新的数据 DCL(data control language) 创建用户 12-- %表示任意地址, 也可以直接指定地址, 本地地址可以是localhost或128.0.0.1create user &apos;cuser&apos;@&apos;%&apos; identified by&apos;123456&apos;; 授权(grant) 1234567891011# src为数据库名, 若为*.* 即是所有数据库中所有资料-- 授予特定的权限grant select on srs.* to &apos;cuser&apos;@&apos;%&apos;;grant insert, delete on srs.* to &apos;cuser&apos;@&apos;%&apos;;grant create, drop, alter on srs.* to &apos;cuser&apos;@&apos;%&apos;;-- 授予所有权限grant all privileges on srs.* to &apos;cuser&apos;@&apos;%&apos;;-- 授予所有权限且还能授权给他人grant all privileges on srs.* to &apos;cuser&apos;@&apos;%&apos; with grant option; 召回(revoke) 12-- 召回所有权限revoke all privileges on srs.* from &apos;cuser&apos;@&apos;%&apos;; DPL(transaction processing language) 事务控制 begin | start transaction 开启事务 commit 事务提交, 要全部任务成功执行则提交 rollback 事务回滚, 只要存在任务失败则回滚 instance 123456789-- 事务开启begin;# or start transactionupdate tb_score set mark=mark+2 where sid=1001;update tb_score set mark=mark+2 where sid=1002;-- 事务提交commit;-- 事务回滚rollback; 视图(view) 概念 12345视图是虚拟表，本身不存储数据，而是按照指定的方式进行查询。也可以说视图是查询的快照权限控制时将用户对表的访问权限,限制到对指定列的访问。可以通过给定查询视图的权限,而不给查询表的权限来实现。对创建好的视图, 可以通过查询语句直接使用视图 栗子 1234# create view vw_name as select ...create view vw_tbemp as select * from tbempselect * from vw_tbemp; 索引 概念 123456789索引相当于图书的目录为表创建索引而达到加速查询就是典型的(牺牲空间换取时间)索引会使增删改变慢, 不能滥用, 其原因是增删改操作可能导致所以索引的更新通常将索引建在经常被查询的字段上主键默认唯一索引 事务的ACID的特性 1234Atomicity原子性 不可分割Consistency 一致性 事务前后数据状态一致Isolation 隔离性 多个事务不能看到彼此的中间状态Duration 持久性 事务完成后数据要持久化 栗子12345678-- 对于模糊索引, 若它以%开头,索引失效; 若它不以%开头,索引有效(下划线_有效)-- 创建索引create index idx_emp_name on tbemp(ename);-- 创建唯一索引create unique index uidx_emp_name on tbemp(ename);-- 删除索引alter table tb_name drop index uidx_name; 12]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之-Window]]></title>
    <url>%2F2018%2F10%2F13%2FJS%E4%B9%8B-Window%2F</url>
    <content type="text"><![CDATA[navigator对象 属性 1.appCodeName -- 返回浏览器的代码名 Mozilla 2.appName -- 返回浏览器的名称 Netscape 3.appVersion -- 返回浏览器的平台和版本消息 4.cookieEnabled -- 启用cookie 5.platform -- 硬件平台 win32 6.userAgent --用户代理 7.systemLanguage -- 用户代理语言 浏览器版本黑历史:) 12345678910111213141516 Mosaic(马赛克)，最早的浏览器 Mozilla(魔斯拉)(意为Mosaic杀手) -- 后改名为Netscape Mozilla/1.0(Win3.1)，由于网景支持框架，而框架被大众喜爱，网站管理员探测userAgent时对Mozilla浏览器发送有框架的页面，对非Mozilla的浏览器发送没有框架的页面。网景拿微软寻开心，称微软是&quot;没有调试过的硬件驱动程序&quot;，微软很生气，开发了自己的浏览器。 微软 IE(Internet Explorer)--IE也支持框架，但它不是Mozilla，总是收不到含有框架的网页， 又等不及所有的网站管理员去了解IE，就宣布IE是兼容Mozilla的，并模仿Netscape，自称Mozilla/1.22(compatible; MSIE 2.0; Windows 95)，于是IE就能接受所有的含有框架的网页，微软开心了，网站管理员崩溃了。微软和Netscape的大战，由于微软的捆绑销售等原因，Netscape退出历史舞台。 FireFox火狐--Netscape以MOzilla的名义，开发了Gecko，它的渲染引擎很出色，Gecko变得出色，其他浏览器使用它的代码，并伪装成Mozilla，但是却使用Gecko。userAgent的探测规则偏向Gecko Linux下的conqueror -- 引擎是KHTML，但因为不是Gecko得不到好的页面，将自己伪装成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko) Opera欧朋 -- 跳出来说应该让用户决定想让我们伪装成什么浏览器。给定三个选项，“Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51”==IE或者“Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51”==火狐， 或者“Opera/9.51 (Windows NT 5.1; U; en)==欧朋 Safari苹果 -- 使用KHTML作为渲染引擎，后来基于KHTML另开辟分支WebKit，又不想抛弃哪些KHTML的页面，就自称Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5 chorme谷歌 --使用Webkit作为渲染引擎，它想要哪些Safari的页面，于是它伪装成Safari.Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36 于是Chrome使用WebKit，并将自己伪装成Safari，WebKit伪装成KHTML，KHTML伪装成Gecko，最后所有的浏览器都伪装成了Mozilla，这就是为什么所有的浏览器User-Agent里都有Mozilla。 Screen对象 123width/height --屏幕宽度/高度availWidth/availheight 可用宽度/高度 (如屏幕底部的状态栏就不含在可用高度内)colorDepth/pixelDepth -- 颜色深度/颜色分辨率 ，其实是一个意思，但是主流服浏览器多用前者 History 对象 属性 length 返回历史记录的地址数 方法 123back()加载history列表中的前一个url 》》 加载时只能加载当前标签对应的history列表，而不是整个历史记录forward() 加载history列表中的后一个urlgo(num) 加载到history列表中的第num个页面(以当前来看) -- go(0)就是刷新页面 Location对象 URL Uniform Resource Locator, 即统一资源定位符 属性 12345678hash -- 返回一个url的锚部分 -- 即是url中#后的部分。通常用于&lt;a name=&quot;location&quot;&gt;&lt;/a&gt;标记去向的位置；使用&lt;a href=&quot;#location&quot;&gt;&lt;/a&gt;可以直接转到指定的位置 。并且#后数据用于位置标识，在服务端没有作用。 但是改变#后值会增加增加一条历史记录到列表中，可以使用history加载)search -- 返回url的查询部分 即是?号之后的部分host -- 返回对应url的主机名和端口号（若端口号是80http 、443https，不会返回端口号）hostname -- 返回对应的url的主机名href -- 返回对应url的完整URLpathname -- 返回url路径名 即主机名之后的部分port -- 返回url的端口号 (若是80端口返回空串)protocol -- 返回url的协议(http/https/ftp ...) 关于hash部分的锚点, 详细请看锚点讲解 方法 123assign -- 加载一个文档 location.assign(url)reload -- 重新加载当前的文档，绕过缓存，重新在服务器上加载数据 与ctrl shift R相同 (若有post提交数据，也会重新提交)replace --替换到一个新文档中 location.replace(url) (网上说replace后的新页面会取代原网页的窗口，不能返回到上一个记录，但是好像可以。。。好像和assign功能上没什么不一样) 注: 以上实验在chorme上进行的. 弹窗 alert() 警告框, 可以提示内容 confirm() 确认框, 有确认和取消按钮 prompt() 提示框, 通常提示用户输入怎样的值 close() 关闭窗口 获取标签 document.getElementById() 通过标签ID选择器获取标签 document.getElementsByTagName() 通过标签标签名列表获取标签 document.getElementsByClassName() 通过类选择器列表获取标签 document.querySelector() 通过选择器获取标签(可以是类,id) document.querySelectorAll() 通过全部选择器的列表获取标签(可以是类,id) instances: 12345var h1 = document.getElementById(&quot;message&quot;); var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]var h1 = document.getElementsByClassName(&quot;msg&quot;)[0]var h1 = document.querySelector(&quot;#message&quot;)var h1 = document.querySelectorAll(&quot;#message&quot;)[0] 计时器 setInterval 设置计时器 setinterval(function, interval_time) 设置一个计时器, 它每隔interval_time的时间执行一次function函数, interval_time的时间单位是毫秒 删除计时器 在设置计时器的时候, 将计时器函数赋给一个变量, 如 var myVar =setInterval(func,1000), 当需要解除计时器的时候, 使用clearInterval(myVar) 即可. setTimeout 设置计时器setTimeout(function, timeout_time) 设置一个计时器, 它在timeout_time时间结束后执行function函数, timeout_time的时间单位是毫秒 删除计时器 在设置计时器的时候, 将计时器函数赋给一个变量, 如 var myVar =setTimeout(func,1000), 当需要解除计时器的时候, 使用clearTimeout(myVar) 即可.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js&#39;s BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识JS]]></title>
    <url>%2F2018%2F10%2F13%2F%E5%88%9D%E8%AF%86JS%2F</url>
    <content type="text"><![CDATA[js概要 JavaScript与java 123456JavaScript 与 Java 是两种完全不同的语言，无论在概念上还是设计上。Java（由 Sun 发明）是更复杂的编程语言。ECMA-262 是 JavaScript 标准的官方名称。JavaScript 由 Brendan Eich 发明。它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ECMA（一个标准协会）采纳。 JavaScript 是互联网上最流行的脚本语言, 对于网页来说, 它负责事件和渲染部分。因此通常我们将它放在网页的最后部分。 JS由ECMAScript + BOM + DOM 三部分组成 ECMAScript ,ECMA(European Computer Manufactures Association 欧洲电脑制造商协会)。它定义了JavaScript的标准, 现在我们大都使用ECMAScript 5.1，在ECMAScript 6以后添加了类和模块 BOM 是浏览器对象模型 对应window对象 DOM 是 文件对象模型 对应document对象 js基础 注释 单行注释使用// 多行注释使用/* */ 标识符 12341.要求是由数字、字母、下划线和$组成 2.对大小写敏感3.使用驼峰式命名, 不能是js中的关键字, 见名知意instance: var abc , var $12c 基本数据类型 123456789Number 数字类型(包含所有数字, 不支持复数) +12.2 10e2Boolean 布尔类型 true falseString 字符串 &apos;如果有来生&apos; &quot;apple&quot; 单双引号皆可Array 数组 [1,&apos;abc&apos;,true]Object 对象 &#123;a:100, name:&apos;张德帅&apos;,age:20&#125;特殊类型:NaN 不存在的数字null 空,一般用来清空变量的内容 underfined 变量没有赋值或没有结果时 js语句 12#1.一条语句结束后可以写分号，也可以不写,但是提倡写,便于js的压缩。如果一行有多条语句，必须写分号#2.js没有缩进语法的要求，需要使用代码块的时候使用大括号 变量 1231.变量声明: var 变量名 或 var 变量名 = 初值2.初值可有可无3.变量要声明再使用 运算符 123456数学运算符 + - * / % （**,js7）++ --比较运算符 &gt; &lt; = == != &gt;= &lt;= ===(完全相等) !== &gt;== &lt;==- ==只判断值相等 2 == &apos;2&apos; //true- ===类型和值都要相等逻辑运算符 &amp;&amp;与 ||或 !非三目运算符 表达式1？值1:值2 判断表达式，如果为真返回值1，否则返回值2 分支结构 1234567891011#if语句- if- if-else- if-else if-else#switch语句switch(表达式)&#123; case 值1: 代码段 break case 值2: 代码段 break ... default:代码段&#125; 循环结构 12345678910111213#for-in循环for(var 变量 in 序列)&#123;循环体&#125;#for循环for(表达式1:表达式2:表达式3)&#123;循环体&#125;#while循环while(条件语句)&#123;循环体&#125;#do-while循环do&#123;循环体&#125;while(条件语句) 函数 123456789function 函数名(参数列表)&#123; 函数体&#125;注:function:js中声明函数的关键字;函数名:标识符，不能是关键字,见名知意参数列表:形参js不能同时返回多个值js中函数能够作为变量 instance： var fn = function(参数列表) &#123;函数体&#125;js中函数能够作为参数或者返回值 ##]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷酷的aview]]></title>
    <url>%2F2018%2F10%2F12%2F%E9%85%B7%E9%85%B7%E7%9A%84aview%2F</url>
    <content type="text"><![CDATA[1.安装AAlibAA(Ascii Art),AAlib是一个便携式ascii艺术GFX库(GFX lib是一个小型的C库，用于开发针对伟大的MSX计算机的图形应用程序) aalib-1.2的最新版本是1.4, 但是后续安装bb是基于1.2的, 因此要先安装1.2的版本. 安装AAlib之前需要安装gcc和libtool,可以通过yum install xx直接安装. aalib-1.2默认安装在/usr/local下面 1234567891011121314#1 下载aalib-1.2wget http://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz#2 解压缩gunzip aalib-1.2.tar.gz#3 解归档tar -xvf aalib-1.2.tar#4 对安装的软件进行配置,检查依赖关系./configure#5 编译安装make &amp;&amp; make install (先执行make, 在执行make install) 出现的问题: 12345678ltconfig: you must specify a host type if you use `--no-verify&apos;Try `ltconfig --help&apos; for more information.configure: error: libtool configure failed出现这样的问题,其实是配置时不能识别系统类型,需要自己指定主机类型.解决方法是将下述的两个文件覆盖带/aalib-1.2/下面. (下述 . 指当前文件夹下)cp /usr/share/libtool/config/config.guess .cp /usr/share/libtool/config/config.sub . 2.安装bbbb是一种图形演示程序,它需要AAlib库 12345678910111213141516171819#1 下载bb源文件wget http://prdownloads.sourceforge.net/aa-project/bb-1.2.tar.gz#2 解压缩gunzip bb-1.2.tar.gz #3 解归档tar -xvf bb-1.2.tar #4 配置环境变量,使bb能找到AAlibexport CFLAGS=-I/usr/local/include#5 配置cd bb-1.2./configure注: 配置会出错,因为textform.c文件中很多位置缺少结束字符&quot; ,只要将报错的地方全部使用 &quot;&quot; 将之引起来就好了。(仿照正确的地方的格式)#6 编译生成可执行文件bbmake 3.安装aviewaview是一款高质量的图像(pnm)浏览器和动画(fli/flc)播放器，以ASCII-art方式输出。它是使用AA-lib实现的。 它提供了一个asciiview的脚本，利用convert转换图片格式，然后再传递给aview. aview是依赖aalib-1.4，因此需要先安装aalib-1.4, 安装方式与aalib-1.2相同, 链接https://downloads.sourceforge.net/aa-project/aalib-1.4rc5.tar.gz 123456789101112131415#1 安装aviewwget http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gz#2 解压缩gunzip aview-1.3.0rc1.tar.gz #3 解归档tar -xvf aview-1.3.0rc1.tar #4 配置cd aview-1.3.0./configure#5 编译安装make &amp;&amp; make install 4.安装ImageMagickImageMagick介绍在此http://www.imagemagick.org/script/index.php 它可以直接通过yum安装 5.try在此,应该是将所有软件安装完毕, 随便在浏览器上扣一张图,使用命令acsiiview 图片路径效果如下: 原图 ascii图 注: 上述使用linux的发行版本为CentOS 6.x。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>aview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xshell和linux]]></title>
    <url>%2F2018%2F10%2F11%2Fxshell%2F</url>
    <content type="text"><![CDATA[基本命令 who 显示当前连接服务器的所有用户 who am i 只显示本用户 w显示本用户详细信息 last显示最近登录的用户信息 ps 显示所有进程 1ps -ef 查看进程 kill pid 杀死指定id的进程 1kill -9 pid 强行杀死指定id的进程 用户管理 adduser username 添加新的用户 passwd username 为指定的用户建立密码(若是root用户, 可以修改任何用户的密码 userdel username 删除用户 userdel -r username 删除用户及其用户主目录(recursive递归的) userdel -f username 强制删除用户(force强制) su username 切换用户(switch user) tab制表键 自动补全 man 命令 查看指定命令的手册(manual手册) info 命令 查看命令的手册(以coder的角度) 命令 --help 查看指定命令的help pwd 查看工作目录(print work directory) cd 或 cd~ 返回到当前目录的主目录 cd /directory 绝对路径的方式改变当前目录 cd directory 相对路径的方式改变当前目录 wget 联网下载 cat filename 连接多个文件并查看文件内容(concatenates) history 查看历史命令 history -c 清除历史命令 ! historyid 执行历史命令编号的命令 pwd 打印当前工作目录(print name of work directory) ls 列出文件 123-a 显示隐藏文件-l 长格式显示文件-R 递归显示文件 alias newname = &quot;命令&quot; 将一个命令起一个别名 12alias rmd = &quot;rm -rf&quot; 使rmd称为直接强制删除的命令别名unalias rmd 取消所起的别名 rmdir 移除空目录(remove directory) mkdir 创建目录 (make directory) cp 拷贝文件 mv 剪切文件或文件夹 12mv index.html new.html 更改文件index.html为new.htmlmv index.html /abc/rz 剪切index.html到/abc/rz的目录下 rm 删除文件或目录 1234rm -f 直接删除指定的文件或目录rm -r 递归式的删除rm -i 交互式删除注:参数可以放在一起或分开 -r -f 等价于 -rf #表示root用户 $表示普通用户 echo 输出内容 1234echo &quot;print &apos;hello world!&apos;&quot; 在控制台打印字符串echo &quot;print &apos;hello world!&apos;&quot; &gt; hello.py 输出(覆盖)内容到hello.py文件中echo &quot;print &apos;hello world!&apos;&quot; &gt;&gt; hello.py 追加内容到hello.py文件中2&gt; 错误输出重定向 cal 查看日历 123cal 2018 查看2018整年的日历cal 2018 &gt; date.txt 将日历信息重定向到date.txt文件中cal 12 2018 查看2018年12月的日历 date 查看日期 bc 计算器 1scale = number number指小数点后几位的num shutdown / init 0 关机, 前者有1m的等待时间，后者直接关机 reboot / init 6 重启 head -n file 查看文件的前n行 tail -n file 查看文件最后n行 less/more file 分页查看文件 | 管道，用于进程间通信。把前一个进程的输出用于后一个进程的输入。 wc 用于统计(print newline, word, and byte counts for each file) 123-l 统计行数-c 统计字节数-m 统计单词个数 uniq 去重的作用(仅去重相邻的重复项) 1sort test.txt | uniq 先排序test.txt文件再去重 vim -d file1 file2比较2个文件的不同(通过创建2个子窗口) chmod 修改权限 chown 修改文件所有者 write 用户名 发送消息给用户,ctrl d结束 wall 发送消息给所有用户 !v 使用vim打开最近一次使用vim的文件 top 查看任务管理器 ls || cal 按顺序执行，若有一个命令执行成功，后续不执行 ls &amp;&amp; cal 按顺序执行，上一个命令执行成功，再执行后一个命令。若遇到执行不成功的,后续也不执行 ls; cal 按顺序执行命令(先ls 再cal) #Linux用户管理 用户添加 12345678910useradd [option] username -- 添加用户option:-c --&gt; 指定一段注释性描述-d --&gt; 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录-g --&gt; 指定用户所属的用户组-s --&gt; 指定用户登录的shell-u --&gt; 指定用户的用户号instance:# useradd -d /usr/mary -m Mary -- 创建名为Mary的用户,并指定其主目录为mary,若没有mary目录就创建一个目录# 默认下新建用户均会在/usr/目录下创建一个和用户名相同的用户主目录 删除账号 123userdel [option] username -- 删除用户option:-r --&gt; 删除用户的同时会删除用户的主目录和用户相关的记录 修改用户 12usermod [option] username -- 修改用户的信息option: 与添加用户部分的参数相同 口令管理(密码管理) 123456789passwd [option] [username]option:-l --&gt; 锁定口令,禁用账号-u --&gt; 解除锁定口令-d --&gt; 使账号无口令-f --&gt; 强迫用户下次登录时修改口令username:- 当没有指定username时, 修改当前用户的口令- 若当前用户是普通用户时, 修改口令需要指定旧口令; 若当前用户为root用户, 可以直接指定新的口令, 不需要旧口令。 Linux安装软件使用包管理工具yum/rpm123456yum search &lt;name&gt; -- 搜索相关包yum - y install &lt;name1&gt; &lt;name2&gt; -- -y参数是默认所有选项为yes，后可以接多个包进行安装yum -y remove &lt;name1&gt; &lt;name&gt; -- 卸载,也可以多个yum info &lt;name&gt; -- 查看软件的信息yum update &lt;name&gt; -- 更新指定的包,若没有指定name,则更新全部包yum list installed -- 将已经安装的包列出来 源代码构建安装 1gcc -- 通常linux系统自带 压缩文件 12gz --- 压缩gzip(解压缩gunzip)xz --- 压缩xzip(解压缩xz -d) 归档文件 12WinRAR --- 归档与解归档tar --- 归档文件(linux下) centos安装python3.x.x 12345678910111213141516171819201.下载源代码 -- wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz2.解压缩 -- gunzip Python-3.6.5.tgz 3.解归档 -- tar -xvf Python-3.6.5.tar (x抽离 v归档显示 f文件)4.安装Python依赖库 -- yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel5.安装前配置 -- 进入Python3.x.x文件，使用./configure --prefix=/usr/local/python36 --enable-optimizations6.源代码构建安装make &amp;&amp; make install(&amp;&amp;表示如果make成功马上执行make install)7.配置PATH环境变量export PATH=$PATH:/usr/local/python36/bin8.注册一个软链接(符号链接) --- 非必要注:软链接 -- 相当于文件的快捷方式，文件删除则链接失效硬链接 -- 文件的引用。只要引用数不为0，文件就会一直存在ln -s 带完整路径的文件名 链接文件名(不带s为硬链接，带s为软链接)对于一个可执行的文件: ./可执行文件配置永久环境变量ls -al | grep .bash_profilevim .bash_profilei修改第10行(:set nu) -- PATH=$PATH:/usr/local/python36/bin修改第11行 -- export PATH 系统目录介绍/bin 1bin是Binary的缩写, 这个目录存放着最经常使用的命令, 如cat cp ls等(通常为普通用户和root用户必备的命令) /sbin 1sbin是Superuser Binary, 这个用户存放系统管理的命令(也称程序) 如reboot shutdown init ifconfig等 /boot 1存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /dev 1device，存放linux的外部设备文件(在linux中访问设备和访问文件的方式相同) /etc 1234存放所有的系统管理所需要的配置文件/etc/profile /etc/csh.login /etc/csh.cshrc 启动shell执行的文件。修改此文件,能够在登录用户后给提示信息./etc/passwd 用户数据库, 其中给出了用户名, 家目录, 命令目录/etc/shells 列出所有可以使用的shell /usr 12345678/usr/bin -- usr下的bin目录放置可执行程序/usr/local -- 手动安装软件的默认目录/usr/share -- 放置共享数据,帮助手册(/usr/share/man)/usr/lib -- 程序和子系统的库文件/usr/include -- c语言编程中的头文件/usr/bin -- 通常放置应用软件工具的必备命令 如gcc zip man等/usr/sbin -- 通常放置放置网路管理的必备程序, 如httpd dhcpd sendmail等/usr/src -- 内核源代码默认的放置目录 /home 1用户的主目录, 里面放置所有用户的主目录文件 /lib 1放置最基本的动态链接共享库, 类似window下的dll文件, 几乎所有程序都需要用到这些共享库 /proc 1process - 放置进程文件,它是系统内存的映射, 是一个虚拟目录 /var 1234存放系统运行时要改变的数据/var/lib -- 存放系统正常运行要改变的文件/var/local -- 存放/usr/local中安装的程序的可变数据/var/log -- 存放各种程序的日志文件 /root 1作为系统管理员的主目录 vim命令模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344按 i 可切换到 编辑模式h/left -- 光标左移1j/down -- 光标下移1k/top -- 光标上移1l/right -- 光标右移1同时可以 10right/10l 的组合键向右移动10个字符0或home 移动到一行的首字符$或end 移动到一行的末字符H 光标移动到屏幕的第一行首字符M 光标移动弄到屏幕的中间行首字符L 光标移动到屏幕最后一行的首字符w 光标移动一个单词G 光标移动到文件的最后一行gg 光标移动到文件的第一行(相当于1G)nG 光标移动到第n行(20G -- 第20行) -- 配合set nu使用n&lt;Enter&gt; 光标向下移动n行/word 向光标之下寻找名称为word的字符串n/N 对应/word使用,前者为下一个,后者为上一个:n1,n2s/word1/word2/g 在n1到n2行之间,将word1字符串替换成word2:1,$s/word1/word2/g 在第一行到最后一行间,将word1字符串替换成word2:1,$s/word1/word2/gice c是confirm确认,i是ignore忽略大小写,g是global全局模式,e是error忽略错误?正则表达式 反向搜索(与/相反)ctrl f 屏幕向下移动1页(page down)ctrl b 屏幕向上移动1页(page up)ctrl e 向下翻1行ctrl y 向上翻1行x 向后删除一个字符 X 向前删除一个字符dd 删除光标所在一整行ndd 删除含光标所有n行yy 复制光标所在一行nyy 复制含光标所在n行p 将复制的数据在光标下一行贴上 P将复制的数据在上一行贴上u 复原前一个动作ctrl r 重做上一个动作 . 重做上一个动作ctrl x + ctrl o 代码提示r/R 进入取代模式(replace) r会取代光标所在的字符一次, R会一直取代ZZ --- 没改动则直接离开，若改动则保存退出 编辑模式 1234567enter 换行backspace 删除光标前一个字符delete 删除光标后一个字符home/end 移动光标到行首/行尾pg up/pg dn 上/下翻页insert 切换光标为输入/替换模式(replace)esc 切换到命令模式 底线命令模式 123456789101112131415在命令模式下,按下:冒号进入底线命令模式:systax off/on --- 关闭/打开高亮语法:set nu/nonu --- 设置行号/关闭行号:wq --- 保存退出:ls 查看打开的文件:b &lt;编号&gt; 查看指定编号文件(可实现vim同时打开多个文件):vs 垂直拆分窗口:sp 水平拆分ctrl w + ctrl w 切换窗口:qa 退出全部:wqa 全部保存退出:qa! 全部强制退出:map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行:inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 .vimrc(vim配置文件) 12345678syntax on/off 高亮语法打开/关闭set number 设置行号set tabstop=4 设置tab缩进为4 set ruler 显示标尺set nohls 搜索时去除高亮set autoindent 设置换行时自动缩进map &lt;F2&gt; gg10000dd 映射命令模式下的快捷键 删除从第一行开始到10000行的所有行inoremap &lt;_py3&gt; #!/usr/bin/python3 i是insert,nore是no递归,用于编辑模式下映射快捷键 linux锁屏与解锁 12ctrl s 会将终端terminal锁屏,造成假死的现象ctrl q 进行解除锁屏 ssh远程登录 1远程登录命令 ssh &lt;user&gt;@公网ip password ssh远程传输 12345scp &lt;local file&gt; &lt;user&gt;@公网ip:/传输的路径 passwd(注意用户的级别与所放置文件的目录访问权限有关) --- 将本地文件发送给别的用户的某个路径下例如:scp sohu2.html rzlong@120.77.178.218:/home/rzlongscp &lt;user&gt;@公网ip:/传输的路径 &lt;user&gt;@公网ip:/传输的路径 passwd1 passwd2 将用户1的某个文件发给用户2,如果要发送文件可以加上 -r 参数例如:scp rzlong@120.77.178.218:/home/rzlong/sohu2.html lnx@47.93.248.0:/home/lnx sftp安全文件传输 12345678910111213sftp &lt;user&gt;@公网ip passwd 进入sftp模式help可以查看相关命令相关命令:get [-Ppr] remote [local] Download filereget remote [local] Resume download fileput [-Ppr] local [remote] Upload filels [-1afhlnrSt] [path] Display remote directory listingmkdir path Create remote directoryrename oldpath newpath Rename remote filerm path Delete remote filermdir path Remove remote directorypwd Display remote working directory此时要在sftp模式中操纵本地 在以上命名前加上l(local),如lcd, lls, lpwd DoS和DDoS 12 查看端口情况 12netstat -anp | grep 80 查看所有占用80端口的情况 n数值型ip a是all p是进程例如:tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2033/sshd 进程id为2033, ip为0.0.0.0，端口号22, 传输协议为tcp, sshd是secure shell deamon安全外壳守护进程(后台程序) 服务相关 1234567891011121314151617centos 6.xservice &lt;name&gt; startservice &lt;name&gt; stopcentos 7.xsystemctl start &lt;name&gt; - 启动服务systemctl stop &lt;name&gt; - 停止服务systemctl restart &lt;name&gt; - 重启服务systemctl status &lt;name&gt; - 服务状态syatemctl enable &lt;name&gt; - 设置服务开机自启systemctl disable &lt;name&gt; - 设置服务不启动安装Appache服务器yum -y install httpdps -ef | grep nginx 进程后台运行 12345678910111213141516171819top -- 查看任务管理器jobs -- 查看后台运行的进程ctrl c -- 结束进程ctrl z -- 进程暂停置于后台ctrl d -- 停止输入bg %编号 -- 让暂停的进程继续在后台运行 backgroundfg %编号 -- 让后台的进程在前台(terminal)运行 foreground./hello.py &amp; -- 将一个程序置于后台运行说明:Key FunctionCtrl-c Kill foreground process Ctrl-z Suspend foreground processCtrl-d Terminate input, or exit shellCtrl-s Suspend output 暂停输出Ctrl-q Resume output 回复输出Ctrl-o Discard output 抛弃输出Ctrl-l Clear screen 清屏 计算机网络分层架构模型 1234567TCP/IP 协议族TCP -- Transfer Control Protocol 传输控制协议UDP -- User DataGram Protocol 用户数据报协议IP -- Internet Protocol 网际协议应用层(定义应用级协议)- HTTP / SMTP / POP3 / FTP / SSH / linux下防火墙firewall 123456789systemctl start firewalld -- 开启防火墙 firewall-cmd -- 配置防火墙 firewall-cmd --help 查看相关命令firewall-cmd --permanent --add-port=80/tcp 配置永久开启80端口firewall-cmd --remove-port=80/tcp 删除80端口firewall-cmd --query-port-80/tcp 查看端口是否开启firewall-cmd --query-service=ssh 查看ssh服务是否开启注:当修改了端口(打开或关闭),需要重启防火墙才能生效。 iptables Linux关于python代码风格检测12yun install pycodestyleyum install pylint Linux中好玩的命令pv 通过yum install pv命令进行安装, 其效果是输出的内容达到边敲边显示的样子。 sl 通过yum install sl 命令进行安装, 其效果为跑火车。 xeyes 通过yum install xeyes 命令进行安装,运行命令,会在图形显示界面会看到一双萌萌的眼睛盯着你。 Linux历史GNU和GPL GNU 建立一个自由、开放的 Unix 操作系统(FreeUnix) GPL(GNU General Public License) 为了避免 GNU 所开发的自由软件被其他人所利用而成为专利软件， 史托曼与律师草拟了有名的通用公共许可证(General Public License, GPL)， 并且称呼他为copyleft(相对于专利软件的 copyright！) Free Software和Close Software free software它更被能称为freedom software,自由软件。不是指免费的价格，而是拥有自由的权利。同时它还具有open source 开放源代码的特点。 1&quot;Free software&quot; is a matter of liberty, not price. To understand the concept, you should think of &quot;freespeech&quot;, not &quot;free beer&quot;. &quot;Free software&quot; refers to the users&apos; freedom to run, copy,distribute, study, change,and improve the software close software 即推出的可执行的二进制程序，是专利软件copyright常见的软件出售方式。 但是也有专利软件是免费使用的.Freeware和Shareware : 前者为免费软件，可以免费使用但是不会公开源代码；后者为共享软件，通常为有试用期，再试用期后就必须续费或者停止使用，它已经撰写好了失效程序。 Linux核心版本 可以使用uname -r查看当前linux版本: 12[root@izwz9gn12m5wual96636l2z ~]# uname -r3.10.0-514.26.2.el7.x86_64 主版本.次版本.释出版本-修改版本 在2.6.x版本前，托瓦兹将主次版本为奇数的定位发展中版本development，主要用于测试与发展；对于主次版本为偶数的定位稳定版本stable 在3.0版本后，依据主线版本MainLine开发，例如 3.10 就是在 3.9 的架构下继续开发出来的新的主线版本。而对于旧的版本，有两种机制来处理: 其一为结束开发End Of Live(EOL)，不会再维护；其二是长期维护版本Longterm，例如3.10为一个长期维护版本。 Linux Distrubution linux distrubution 即linux发行版，它是linux kernel+softwares+Tools+可完全安装程序 。常见的有Redhat /OpenSuSe/Fedora/Ubuntu/Debian/CentOS等，它们都是支持于标准的。 12 12]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本控制工具]]></title>
    <url>%2F2018%2F10%2F05%2Fgit-md%2F</url>
    <content type="text"><![CDATA[版本控制工具CVS/VSS – 锁定模式 2000年 - Subversion(SVN) – 合并模式上述为集中控制式的版本系统,必须有中央服务器。 2005年 - Git – 版本控制Mercury分布式的版本系统 区域划分工作区 — 暂存区 — 仓库 基本命令 git init 初始化，使当前目录初始化为git仓库，并创建.git的隐藏目录 git config –global user.name “name” 全局用户名可以随便写,仅标记主机 git config –global user.email “email@example.com“ 全局邮箱,可随便写 git add 将文件加入到暂存区 git add . 将当前目录下的所有文件加入到暂存区 git commit -m “版本提示内容” 将暂存区的内容提交到本地仓库 git status 查看暂存区状态 git log 查看当前版本日志(之前的版本) git reflog 查看所有版本git reset HEAD -将文件从暂存区移除 git checkout – 将暂存区回退到工作区，可用于文件恢复(用于上一次,并且还没有提交到本地仓库中；若是已经提交到仓库中，就可以使用hard来还原版本) git reset –hard 版本号 去往指定的版本 git reset –hard HEAD^ 还原到上个版本(HEAD^^还原到上上个版本) git reset –hard HEAD~num 还原到前num个版本 git clone - 将服务器的项目(仓库)克隆到本地 git push - 将代码推送到服务器(上传) git pull - 将服务器上代码同步到本地(下载) 代码托管平台用别人提供的git服务器github.comgitee.comcoding.net]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F10%2F05%2Fmutiphreading-md%2F</url>
    <content type="text"><![CDATA[##多线程技术 主线程 每个进程都会有一个线程, 这个线程是主线程。默认情况下, 所有代码都是在主线程中执行。 子线程 一个进程可以有多个线程,除了主线程的其他子线程需要去创建 创建线程通过导入threading模块。 threading是python中创建线程的内置模块，用来支持多线程。Thread类的对象就是线程，需要线程时，可创建这个类或其子类的对象。 实例 1234567891011121314151617181920212223242526272829303132333435363738394041import threadingfrom datetime import datetimeimport time# 模拟下载电影def download(file): print(threading.currentThread()) print(file+&apos; 开始下载&apos;,datetime.now()) time.sleep(10) print(file+&apos; 结束下载&apos;, datetime.now())# 在两个子线程中去下载电影&apos;&apos;&apos;Thread(target,args)target:需要在在线程中调用的函数的函数名args: 函数的实参返回值:创建好的线程对象&apos;&apos;&apos;if __name__ == &apos;__main__&apos;: print(threading.current_thread()) print(&apos;主线程位置&apos;) print(&apos;===============================&apos;) t1 = threading.Thread(target=download, args=(&apos;闻香识女人&apos;,)) # t1.start()#想要子线程执行任务，通过线程对象调用start方法 print(&apos;=============================&apos;) t2 = threading.Thread(target=download, args=(&apos;猫鼠游戏&apos;,)) # t2.start() # 执行线程的代码result:&lt;_MainThread(MainThread, started 10552)&gt;主线程位置===============================&lt;Thread(Thread-1, started 8712)&gt;闻香识女人 开始下载 2018-09-15 09:27:07.418839=============================&lt;Thread(Thread-2, started 10564)&gt;猫鼠游戏 开始下载 2018-09-15 09:27:07.418839猫鼠游戏 结束下载 2018-09-15 09:27:17.419411闻香识女人 结束下载 2018-09-15 09:27:17.419411 ##面向对象的多线程 步骤1.声明一个类，继承Thread类2.重写run()方法,将需要在子线程中执行的任务，放到run()方法中3.在需要线程的位置，去创建这个类的对象然后用对象调用start方法，去执行run中的任务。 案例1234567891011121314151617rom threading import Threadfrom datetime import datetime # 从datetime包中引入datetime模块import timeclass R_Thread(Thread): &quot;&quot;&quot;下载线程类&quot;&quot;&quot; def __init__(self,name): super().__init__() self.name = name def run(self): print(self.name+&apos; 开始下载&apos;,datetime.now()) time.sleep(5) print(self.name+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: print(&apos;=========================&apos;) t1 = R_Thread(&apos;闻香识女人&apos;) t1.start() print(&apos;============================&apos;) ##join方法如果希望某个线程结束后才执行后续的操作，调用join方法 案例12345678910111213141516171819202122232425262728from threading import Threadfrom datetime import datetimeimport timefrom random import randint# 在两个子线程中下载两个电影,在主线程中国统计两个电影下载的总时间class R_Thread(Thread): def __init__(self,file): super().__init__() self.file = file def run(self): print(self.file+&apos; 开始下载&apos;,datetime.now()) time.sleep(randint(5,15)) print(self.file+&apos; 下载结束&apos;,datetime.now())if __name__ == &apos;__main__&apos;: t1 = R_Thread(&apos;闻香识女人&apos;) start = time.time() print(start) t1.start() t2 = R_Thread(&apos;美丽人生&apos;) t2.start() &apos;&apos;&apos; 如果希望某个线程结束后才执行后续的操作，调用join方法 &apos;&apos;&apos; t1.join() #这句代码后面的代码需要在t1对应的线程结束后执行 t2.join() end = time.time() print(end) print(end-start) ##多个线程数据共享通过加锁的方式，以解决多个线程同时对一个数据进行操作二带来的数据紊乱的问题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import timefrom datetime import datetimefrom threading import Thread,Lock,RLockclass Account: &quot;&quot;&quot;账号类&quot;&quot;&quot; def __init__(self,balance): self.balance = balance # 创建锁对象 self.lock = Lock() # 存钱: 读余额, 确定钱的数目 def save_money(self,amount): self.lock.acquire() # 获取原来的余额 old_amount = self.balance # 模拟时间消耗 time.sleep(5) # 修改余额 self.balance = old_amount + amount print(&apos;存钱成功,余额&apos;,self.balance) self.lock.release() # 取钱 def get_money(self,amount): self.lock.acquire() old_amount = self.balance if old_amount &lt; amount: print(&apos;余额不足&apos;) return time.sleep(10) self.balance = old_amount - amount print(&apos;取钱成功,余额&apos;,self.balance) self.lock.release() def show_balance(self): print(&apos;余额:&apos;,self.balance)if __name__ == &apos;__main__&apos;: account = Account(1000) account.show_balance() &apos;&apos;&apos; 当多个线程同时对一个数据进行操作的时候,可能出现数据紊乱的问题 &apos;&apos;&apos; t1 = Thread(target=account.save_money,args=(200,)) t2 = Thread(target=account.get_money,args=(400,)) t1.start() t2.start() t1.join() account.show_balance() t2.join() account.show_balance() **]]></content>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
